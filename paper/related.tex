\section{Related Work}
\label{sec:related}

\citet{DBLP:conf/snapl/MarinoMMNS15} argue that the ``silently shifting
semicolon'' is sufficiently problematic for programmers that concurrent
languages should guarantee sequential abstraction, despite the performance
penalties (see also \citet{10.1145/3462206}).  In this paper, we take the
opposite approach.  We have attempted to find the most intellectually
tractable model that encompasses all of the messiness of relaxed memory.

There are few prior studies of relaxed memory that include sequential
composition and/or precise calculation of semantic dependencies.
\citet{DBLP:journals/pacmpl/JagadeesanJR20} give a denotational semantics,
using prefixing rather than sequential compositions.
\citet{DBLP:conf/esop/PaviottiCPWOB20} give a denotational semantics,
calculating dependencies using event structures rather than logic.  They give
the semantics of sequential composition in continuation passing style,
whereas we give it in direct style.  This paper provides a general technique
for computing sequential dependencies and applies it to these two approaches.

There are many differences between \PwP{}
\cite{DBLP:journals/pacmpl/JagadeesanJR20} and \PwT{}.  Two of these are
motivated by requirements unique to \PwT{}: First, \PwP{} uses substitution
to define read actions; \PwT{} Skolemizes in order to satisfy disjunction
closure for predicate transformers (\textsection\ref{sec:ex:assoc}).  Second,
\PwP{} requires \emph{consistency} and \emph{causal strengthening}; \PwT{}
drops these in order to satisfy associativity (\reflem{lem:monoid}).  Other
differences are stylistic: For example, we replaced the termination
\emph{actions} of \PwP{} by termination \emph{conditions}---our formulation
fixes an error in \citeauthor{DBLP:journals/pacmpl/JagadeesanJR20}'s
definition of parallel composition.  We also fix an error in their treatment
of redundant read elimination.

\citet{DBLP:journals/corr/abs-1804-04214} define a semantics
using pomsets without preconditions. Instead, their model uses syntactic
dependencies, thus invalidating many compiler optimizations.  They also
require a fence after every relaxed read on \armeight{}.
%
\citet{Pichon-Pharabod:2016:CSR:2837614.2837616} use event structures to
calculate dependencies, combined with an operational semantics that
incorporates program transformations.  This approach seems to require
whole-program analysis.




Other studies of relaxed memory can be categorized by their approach to
dependency calculation.  Hardware models use syntactic dependencies
\cite{alglave}.  Many software models do not bother with dependencies at all
\cite{Batty:2011:MCC:1926385.1926394, DBLP:journals/pacmpl/WattRP19,
  DBLP:conf/pldi/WattPPBDFPG20, goMM}.  Others have strong dependencies that
disallow compiler optimizations and efficient implementation, typically
requiring fences for every relaxed read on Arm
\cite{Lamport:1979:MMC:1311099.1311750, DBLP:conf/pldi/LahavVKHD17,
  Dolan:2018:BDR:3192366.3192421, DBLP:conf/lics/JeffreyR16,
  Boehm:2014:OGA:2618128.2618134}. %, DBLP:journals/corr/abs-1804-04214}.
%
Many of the most prominent models are operational models based
on speculative execution \cite{Manson:2005:JMM:1047659.1040336,
  DBLP:conf/esop/JagadeesanPR10,
  DBLP:conf/popl/KangHLVD17,DBLP:journals/pacmpl/ChakrabortyV19,DBLP:conf/pldi/LeeCPCHLV20,promising-ldrf}.
Morally, \PwT{} fits between the strong models and the speculative ones.
% We provide a detailed comparison with these approaches in \textsection\ref{sec:promising}.


% \todo{We agree that a new memory model needs to be positioned against existing
% models.  The usual result here is a compilation correctness to hardware
% memory models.  For PwT-MCA, we address this by showing compilation result
% for Armv8 model (ยง5).
% %
% Comparing software models, however, is unsatisfying: they are all
% incomparable, i.e., there are examples which are allowed by one/disallowed by
% the other and vice versa.
% %
% Morally, our model sits between the strong models (exemplified by RC11
% [Lahav-al:PLDI17]) and the speculative models (exemplified by the promising
% semantics [Kang-al:POPL17]).  As we argue in ยง1:
% %
% - The strong models require too much synchronization.
% %
% - The speculative models allow thin air behaviors.
% %
% Looking at the details, however, PwT-MCA is incomparable to both RC11 and
% promising semantics.  RC11 allows non-MCA behaviors that PwT-MCA disallows.
% PwT-MCA has a weaker notion of coherence than the promising semantics.
% %
% Some differences reflect an attempt to fix a bug.  For example, Weakestmo
% [Chakraborty-Vafeiadis:POPL19] purposefully disallows thin-air-like
% behaviors of the promising semantics.
% %
% Other differences reflect a different balance between allowed optimizations
% and reasoning principles.  There are fundamental conflicts, for example:
% %
% - between Common Subexpression Elimination (CSE) and read-read coherence
%   (ยงD.1)
% %
% - between if-introduction (aka, case analysis, if-closure) and java-style
%   final-field semantics.  (If-introduction requires that address dependencies
%   and control dependencies are the same.  Final-fields require that they be
%   different.)
% }
\citet{DBLP:journals/pacmpl/JagadeesanJR20} argue that the speculative models
allow too many executions, resulting in a failure of temporal reasoning and
potentially jeopardizing type safety and other security properties.  In a
similar vein, \citet{promising-ldrf} argue that local \drf{} guarantees are
violated when read-introduction is followed by if-introduction, branching on
the read just introduced.  These optimizations are validated by the
speculative models---\citeauthor{promising-ldrf} manage to avoid the problem
by adopting a sub-optimal lowering for \RMW{}s.  \PwT{} does not suffer from
this problem, since \PwT{} does not validate read-introduction.  Nonetheless,
read introduction is ubiquitous in some compilers
\cite{DBLP:conf/pldi/LeeKSHDMRL17}.  There appears to be a genuine tension
between temporal reasoning, as supported by \PwT{}, and read-introduction, as
supported by the speculative models.

Other work in relaxed memory has shown that tooling is especially useful to
researchers, architects, and language specifiers, enabling them to build
intuitions
experimentally~\cite{DBLP:conf/esop/PaviottiCPWOB20,PrideMM,alglave,Batty:2011:MCC:1926385.1926394}.
Unfortunately, it is not obvious that tools can be built for all
thin-air-free models, the calculation of
\citet{Pichon-Pharabod:2016:CSR:2837614.2837616} does not have a termination
proof for an arbitrary input, and the enormous state space for the
operational models of \citet{DBLP:conf/popl/KangHLVD17} and
\citet{DBLP:journals/pacmpl/ChakrabortyV19} is a daunting prospect for a tool
builder -- and as yet no tool exists for automatically evaluating these
models.  We described a tool, \PwTer, for automatically evaluating \PwT{} in
\textsection\ref{sec:tool}.
