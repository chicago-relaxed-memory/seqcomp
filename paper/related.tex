\section{Related Work}
\label{sec:related}

\citet{DBLP:conf/snapl/MarinoMMNS15} argue that the ``silently shifting
semicolon'' is sufficiently problematic for programmers that concurrent
languages should guarantee sequential abstraction, despite the performance
penalties (see also \citet{10.1145/3462206}).  In this paper, we take the
opposite approach.  We have attempted to find the most intellectually
tractable model that encompasses all of the messiness of relaxed memory.

There are few prior studies of relaxed memory that include sequential
composition and/or precise calculation of semantic dependencies.  No prior
work gives the semantics of sequential composition in direct style.
\citet{DBLP:conf/esop/PaviottiCPWOB20} defined \MRD{}, which calculates
dependencies using event structures rather than logic.  This strategy is
brittler than ours, leading to false positives (\textsection\ref{sec:lir}).
\citet{DBLP:journals/pacmpl/JagadeesanJR20} defined \PwP{}, using logical
entailment to define dependency.  Although \PwT{} is based on \PwP{}, there
are many differences.
Some of these are motivated by requirements unique to
\PwT{} (see \textsection\ref{sec:ex:assoc}).
% Two of these are motivated by requirements unique to
% \PwT{}: First, \PwP{} uses substitution to define read actions; \PwT{}
% Skolemizes in order to satisfy disjunction closure for predicate transformers
% (\textsection\ref{sec:ex:assoc}).  Second, \PwP{} requires \emph{consistency}
% and \emph{causal strengthening}; \PwT{} drops these in order to satisfy
% associativity (\reflem{lem:monoid}).
Other differences are stylistic: For
example, we use termination \emph{conditions} rather than termination
\emph{actions}---our formulation fixes an error in
\citeauthor{DBLP:journals/pacmpl/JagadeesanJR20}'s definition of parallel
composition.  We also fix an error in their treatment of redundant read
elimination (\textsection\ref{sec:semreg}).

\citet{DBLP:journals/corr/abs-1804-04214} define a semantics
using pomsets without preconditions. Instead, their model uses syntactic
dependencies, thus invalidating many compiler optimizations.  They also
require a fence after every relaxed read on \armeight{}.
%
\citet{Pichon-Pharabod:2016:CSR:2837614.2837616} use event structures to
calculate dependencies, combined with an operational semantics that
incorporates program transformations.  This approach seems to require
whole-program analysis.




Other studies of relaxed memory can be categorized by their approach to
dependency calculation.  Hardware models use syntactic dependencies
\cite{alglave}.  Many software models do not bother with dependencies at all
\cite{Batty:2011:MCC:1926385.1926394, DBLP:journals/pacmpl/WattRP19,
  DBLP:conf/pldi/WattPPBDFPG20, goMM}.  Others have strong dependencies that
disallow compiler optimizations and efficient implementation, typically
requiring fences for every relaxed read on Arm
\cite{Lamport:1979:MMC:1311099.1311750, DBLP:conf/pldi/LahavVKHD17,
  Dolan:2018:BDR:3192366.3192421, DBLP:conf/lics/JeffreyR16,
  Boehm:2014:OGA:2618128.2618134}. %, DBLP:journals/corr/abs-1804-04214}.
%
Many of the most prominent models are operational models based on speculative
execution \cite{Manson:2005:JMM:1047659.1040336,
  DBLP:conf/esop/JagadeesanPR10,
  DBLP:conf/popl/KangHLVD17,DBLP:journals/pacmpl/ChakrabortyV19,DBLP:conf/pldi/LeeCPCHLV20,promising-ldrf}.

Morally, \PwT{} fits between the strong models and the speculative ones.
Looking at the details, however, \PwTmca{} is incomparable to both \rcXI{}
\cite{DBLP:conf/pldi/LahavVKHD17} and the promising semantics
\cite{DBLP:conf/popl/KangHLVD17}, to take two examples.  \rcXI{} allows
non-\mca{} behaviors that \PwTmca{} disallows.  \PwTmca{} has a weaker notion
of coherence than the promising semantics.

% We provide a detailed comparison with these approaches in \textsection\ref{sec:promising}.


% \todo{We agree that a new memory model needs to be positioned against existing
% models.  The usual result here is a compilation correctness to hardware
% memory models.  For PwT-MCA, we address this by showing compilation result
% for Armv8 model (ยง5).
% %
% Comparing software models, however, is unsatisfying: they are all
% incomparable, i.e., there are examples which are allowed by one/disallowed by
% the other and vice versa.
% %
% Morally, our model sits between the strong models (exemplified by RC11
% [Lahav-al:PLDI17]) and the speculative models (exemplified by the promising
% semantics [Kang-al:POPL17]).  As we argue in ยง1:
% %
% - The strong models require too much synchronization.
% %
% - The speculative models allow thin air behaviors.
% %
% Looking at the details, however, PwT-MCA is incomparable to both RC11 and
% promising semantics.  RC11 allows non-MCA behaviors that PwT-MCA disallows.
% PwT-MCA has a weaker notion of coherence than the promising semantics.
% %
% Some differences reflect an attempt to fix a bug.  For example, Weakestmo
% [Chakraborty-Vafeiadis:POPL19] purposefully disallows thin-air-like
% behaviors of the promising semantics.
% %
% Other differences reflect a different balance between allowed optimizations
% and reasoning principles.  There are fundamental conflicts, for example:
% %
% - between Common Subexpression Elimination (CSE) and read-read coherence
%   (ยงD.1)
% %
% - between if-introduction (aka, case analysis, if-closure) and java-style
%   final-field semantics.  (If-introduction requires that address dependencies
%   and control dependencies are the same.  Final-fields require that they be
%   different.)
% }
\citet{DBLP:journals/pacmpl/JagadeesanJR20} argue that the speculative models
allow too many executions, resulting in a failure of temporal reasoning and
potentially jeopardizing type safety and other security properties.  In a
similar vein, \citet{promising-ldrf} argue that local \drf{} guarantees are
violated when read-introduction is followed by if-introduction, branching on
the read just introduced.  These optimizations are validated by the
speculative models---\citeauthor{promising-ldrf} manage to avoid the problem
by adopting a sub-optimal lowering for \RMW{}s.  \PwT{} does not suffer from
this problem, since \PwT{} does not validate read-introduction.  Nonetheless,
read-introduction is ubiquitous in some compilers
\cite{DBLP:conf/pldi/LeeKSHDMRL17}.  There appears to be a genuine tension
between temporal reasoning, as supported by \PwT{}, and read-introduction, as
supported by the speculative models.

Other work in relaxed memory has shown that tooling is especially useful to
researchers, architects, and language specifiers, enabling them to build
intuitions
experimentally~\cite{DBLP:conf/esop/PaviottiCPWOB20,PrideMM,alglave,Batty:2011:MCC:1926385.1926394}.
Unfortunately, it is not obvious that tools can be built for all
thin-air-free models, the calculation of
\citet{Pichon-Pharabod:2016:CSR:2837614.2837616} does not have a termination
proof for an arbitrary input, and the enormous state space for the
operational models of \citet{DBLP:conf/popl/KangHLVD17} and
\citet{DBLP:journals/pacmpl/ChakrabortyV19} is a daunting prospect for a tool
builder -- and as yet no tool exists for automatically evaluating these
models.  We described a tool, \PwTer, for automatically evaluating \PwT{} in
\textsection\ref{sec:tool}.
