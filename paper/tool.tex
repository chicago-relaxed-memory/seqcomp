\section{\PwTerTITLE: automatic litmus test evaluator}
\label{sec:tool}

\PwTer{} automatically and exhaustively calculates the allowed outcomes of litmus tests for the \PwT, \PwTpo, and \PwTc{} models. It is built in OCaml, and uses Z3~\cite{Z3Solver} to judge the truth of predicates constructed by the models. \PwTer{} obviates the need for error-prone hand evaluation.

\PwTer{} allows several modes of evaluation: it can evaluate the rules of Fig.~\ref{fig:seq}, implementing \PwT; it can generate program order according to \textsection\ref{sec:c11}, implementing \PwTpo; and similar to \MRD~\cite{DBLP:conf/esop/PaviottiCPWOB20}, it can construct C11-style pre-executions and filter them according to the rules of \rcXI{} as described in \textsection\ref{sec:c11}, implementing \PwTc{}.
Finally, \PwTer{} also allows us to toggle the complete check of~\ref{def:complete}, providing an interface for understanding how fragments of code might compose by exposing preconditions and termination conditions that are not yet tautologies.
We have run \PwTer{} over the Java Causality Tests~\cite{PughWebsite} supported in the input syntax, and tabulated the results in Figure~\ref{fig:tool}.

The execution times give a good indication the poor scaling of the tool with program size: for larger test cases, the tool takes exponentially longer to compute, and for the largest tests the memory footprint is too large for even a well-equipped computer.
The compositional nature of the semantics makes tool building practical, but it is not enough to make it scalable for large tests.
The definitions of $\sSEMI{\aPSS_1}{\aPSS_2}$ and $\sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$ -- in combination with the rules for reads and writes has exponential complexity.
This is compounded by the hidden complexity of calculating the possible merges between pomsets through union in rules \ref{seq-E} and \ref{if-E}.
Significant effort has been put into throwing away spurious merges early in \PwTer, so that executing the tool remains manageable for small examples.
Some further optimisations may be possible within the tool to improve the situation further, such as killing 'dead-end' pomsets at each sequence operator, or by doing a directed search for particular execution outcomes.
Unsurprisingly the execution time is dominated by the calculation of the denotation, with the additional axiomatic filtering step of \PwTc{} being within margin of error difference of just calculating the \PwT{} semantics. 
% \PwTer{} will be made open source upon publication.
\PwTer{} is available online at \url{https://github.com/graymalkin/pomsets-with-predicate-transformers}.

%% [Simon] I am not a fan of how this looks on the page.
\begin{figure}[t]
\begin{center}
  \begin{tabularx}{0.7\textwidth}{c||c|c|c}
    \multirow{2}{*}{\bf Causality Test}   & \multicolumn{2}{c|}{\PwTc{}}    & \PwT{}\\
    \cline{2-4}
                                     & Result & Execution Time (s)  & Execution Time (s) \\
    \cline{1-4}
    jctc1                            & pass   & 2.397               & 2.608              \\
    jctc2                            & pass   & 25.780              & 25.754             \\
    jctc3                            & pass   & 196.935             & 205.120            \\
    jctc4                            & pass   & 2.269               & 2.110              \\
    jctc5                            & pass   & 63.714              & 69.441             \\
    jctc6                            & pass   & 11.245              & 12.489             \\
    jctc7                            & pass   & 88.250              & 96.099             \\
    jctc8                            & pass   & 2.482               & 2.473              \\
    jctc9                            & pass   & 13.592              & 15.384             \\
    jctc10                           & pass   & 494.133             & 513.234            \\
    jctc11                           & $\bot$ & --                  & --                 \\
    jctc12                           & $\bot$ & --                  & --                 \\
    jctc13                           & pass   & 2.101               & 2.247              \\
    jctc17                           & pass   & 178.304             & 186.228            \\
    jctc18                           & pass   & 177.292             & 2.247              \\
  \end{tabularx}
  \caption{\label{fig:tool} Tool results for supported Java Causality Test Cases~\cite{PughWebsite}. $\bot$ indicates the tool failed to run for this test due to a memory overflow. Tests run on an Intel i9-9980HK with 64 GB of memory, execution times are the mean of 3 runs.}
\end{center}
\end{figure}
