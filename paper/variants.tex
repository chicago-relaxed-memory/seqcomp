\section{Refinements and Additional Features} %Case Analysis, Address Calculation, RMWs, Elimination}
\label{sec:additional}

In the paper so far, we have assumed that registers are assigned at most
once.  We have done this primarily for readability.  In the first subsection
below, we drop this assumption, instead using substitution to rename
registers.  We use the set
$\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$.  By assumption
(\textsection\ref{sec:prelim}), these registers do not appear in programs:
$\aCmd[\bExp/\uReg{\aEv}]=\aCmd$.  The resulting semantics satisfies
redundant read elimination.

In this section we consider several mostly-orthogonal features: address
calculation, if-closure, fences, and read-modify-write operations.  Address
calculation and if-closure do have some interaction, and we spell out the
combined semantics in \textsection\ref{sec:semcaaddr}.

It is worth pointing out that address calculation and if-closure only affect
the semantics of read and write.  Fences introduce new trivial actions.
\RMW{}s require more infrastructure in order to ensure atomicity while
compiling to \armeight{}.

These extensions preserve all of the program transformation discussed thus
far, and apply equally to the various semantics we have discussed: \PwT{},
\PwTmca{1}, \PwTmca{2}, and \PwTc{}.  The results discussed in
\textsection\ref{sec:results} also apply equally, with the exception of
\RMW{}s: we have not proven \drfsc{} or \armeight lowering for \RMW{}s.


\subsection{Register Recycling and Redundant Read Elimination}
\label{sec:semreg}

\jmm{} Test Case 2 \citep{PughWebsite} states the following
execution should be allowed ``since redundant read elimination could result
in simplification of $\aReg{=}\bReg$ to true, allowing $\PW{y}{1}$ to be
moved early.''
\begin{gather*}
  \PR{x}{r}\SEMI
  \PR{x}{s}\SEMI
  \IF{r{=}s}\THEN \PW{y}{1}\FI
  \PAR
  \PW{x}{y}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \eventl{\bEv}{a1}{\DR{x}{1}}{}
      % \event{a2}{\DR{x}{1}}{right=of a1}
      \eventr{\aEv}{a3}{\DW{y}{1}}{right=of a1}
      % \po{a1}{a3}
      % \po[out=-20,in=-160]{a1}{a3}
      \event{b1}{\DR{y}{1}}{right=3em of a3}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \rf{a3}{b1}
      \po{b1}{b2}
      % \rf[out=169,in=11]{b2}{a2}
      \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
Under the semantics of \reffig{fig:seq}, the precondition of
$\aEv$ in the independent case is
\begin{displaymath}
  \tag{$*$}\label{eq3}
  (1{=}r \lor x{=}r)\limplies (1{=}s \lor r{=}s)\limplies (r{=}s),
\end{displaymath}
which is equivalent to
\begin{math}
  (x{=}r)\limplies (1{=}s)\limplies (r{=}s),
\end{math}
which is not a tautology, and thus \reffig{fig:seq} requires order from
$\bEv$  to $\aEv$ in order to complete the pomset.

This execution is allowed, however, if we rename registers using a map from
event names to register names.  By using this renaming, coalesced events must
choose the same register name.  In the above example, the precondition of
$\aEv$ in the independent case becomes
\begin{displaymath}
  \tag{$**$}\label{eq4}
  (1{=}\uReg{\aEv} \lor x{=}\uReg{\aEv})\limplies (1{=}\uReg{\aEv} \lor \uReg{\aEv}{=}\uReg{\aEv})\limplies (\uReg{\aEv}{=}\uReg{\aEv}),
\end{displaymath}
which is a tautology.  In \eqref{eq4}, the first read resolves the
nondeterminism in both the first and the second read.  Given the choice of
event names, the outcome of the second read is predetermined!  In
\eqref{eq3}, the second read remains nondeterministic, even in the case that
the events are destined to coalesce.  

\begin{definition}
  Let $\semreg{}$ be defined as in \reffig{fig:seq}, changing \ref{read-tau}
  of $\sLOAD{}{}$:

  \noindent
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
    % \item \label{read-E}
    %   if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
    % \item \label{read-lambda}
    %   $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
    %   \stepcounter{enumi}
    %   \stepcounter{enumi}
    \setcounter{enumi}{4}
  \item[] \labeltext[\textsc{r}4]{}{read-tau-reg}
    \begin{enumerate}[leftmargin=0pt]
    \item \label{read-tau-dep-reg}
      if $\aEv\in\aEvs$ and $\aEv\in\bEvs$ then
      \begin{math}
        \aTr{\bEvs}{\bForm} \riff
        \aVal{=}\uReg{\aEv}
        \limplies \bForm[\uReg{\aEv}/\aReg]
      \end{math},    
    \item \label{read-tau-ind-reg}
      if $\aEv\in\aEvs$ and $\aEv\notin\bEvs$ then
      \begin{math}
        \aTr{\bEvs}{\bForm} \riff
        \PBR{\aVal{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}} \limplies
        \bForm[\uReg{\aEv}/\aReg],
      \end{math}
    \item \label{read-tau-empty-reg}
      if $\aEvs=\emptyset$ then $(\forall\bReg)$
      \begin{math}
        \aTr{\bEvs}{\bForm} \riff
        \bForm[\bReg/\aReg].
      \end{math}
    \end{enumerate}
  \end{enumerate}
  % \medskip
  % Similarly, let $\frf{\semreg{}}$ be defined as for
  % $\frf{\semrr{}}$ in \refdef{def:sem:frf}, with this definition of
  % $\sLOAD{}{}$.
\end{definition}


With this semantics, it is straightforward to see that redundant load
elimination is sound:
\begin{displaymath}
  \semreg{\PR[\amode]{\aLoc}{\aReg} \SEMI \PR[\amode]{\aLoc}{\bReg}} \supseteq 
  \semreg{\PR[\amode]{\aLoc}{\aReg} \SEMI \bReg  \GETS \aReg}
\end{displaymath}

As a further example, consider \cite[Fig.~5]{DBLP:conf/ecoop/SevcikA08},
referenced in \cite[\textsection6.4]{DBLP:conf/esop/PaviottiCPWOB20}.
Consider the case where the reads are merged, both seeing 1:
\begin{align*}
  \PR{y}{r}
  \SEMI
  \IF{r{=}1}\THEN \PR{y}{s} \SEMI \PW{x}{s}
  \ELSE \PW{x}{1}
  \FI
  &&
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DR{y}{1}}{}
      \event{b}{\aForm\mid\DW{x}{1}}{right=of a}
    \end{tikzinline}}
\end{align*}
In order to independent of both reads, we take the precondition $\aForm$ to be:
\begin{displaymath}
  \PBR{
    1{=}r\lor y{=}r
  }
  \limplies
  \SBR{
    r{=}1
    \land
    \PBRbig{
      \PBR{
        1{=}s\lor y{=}s
      }
      \limplies
      s{=}1
    }
  }
  \lor
  \SBR{
    r{\neq}1
  }
\end{displaymath}
Then collapsing $r$ and $s$ and substituting the initial value of $y$ (say $0$), we have a tautology:
\begin{displaymath}
  \PBR{
    1{=}r\lor 0{=}r
  }
  \limplies
  \SBR{
    r{=}1
    \land
    \PBRbig{
      \PBR{
        1{=}r\lor 0{=}r
      }
      \limplies
      r{=}1
    }
  }
  \lor
  \SBR{
    r{\neq}1
  }
\end{displaymath}


\subsection{Address Calculation}
\label{sec:addr}

Inevitably, address calculation complicates the definitions of $\sSTORE{}{}$ and $\sLOAD{}{}$.
\begin{definition}
  \label{def:semaddr}
  Let $\semaddr{}$ be defined as in \reffig{fig:seq}, changing $\sSTORE{}{}$ and $\sLOAD{}{}$:

  \noindent
  If $\aPS \in \sSTORE[\amode]{\cExp}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\cVal\in\Val)$
  $(\exists\aVal\in\Val)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
    \item \label{write-E-addr}
      if $\fcard{\aEvs}\leq1$,
    \item \label{write-lambda-addr}
      $\labelingAct(\aEv) = \DW[\amode]{\REF{\cVal}}[\ascope]{\aVal}[\aThrd]$,
    \item \label{write-kappa-addr}
      \begin{math}
        \labelingForm(\aEv) \riff
        \cExp{=}\cVal
        \land \aExp{=}\aVal
      \end{math},      
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{w}4]{}{write-tau-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-tau-dep-addr}
        if $\aEvs\neq\emptyset$ then 
        \makebox[0pt][l]{\begin{math}
          \aTr{\bEvs}{\bForm} \riff 
          (\cExp{=}\cVal)
          \limplies 
          \bForm[\aExp/\REF{\cVal}][\aExp{=}\aVal/\Q{\REF{\cVal}}]
        \end{math},}
      \item \label{write-tau-empty-addr}
        if $\aEvs=\emptyset$ then
        \makebox[0pt][l]{\begin{math}
          (\forall\dVal)
        \end{math}        
        \begin{math}
          \aTr{\bEvs}{\bForm} \riff 
          (\cExp{=}\dVal)
          \limplies 
          \bForm
          [\aExp/\REF{\dVal}][\FALSE/\Q{\REF{\dVal}}],
        \end{math}}
      \end{enumerate}
      \columnbreak
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{w}5]{}{write-term-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-term-nonempty-addr}
        if $\aEvs\neq\emptyset$ then $\aTerm \riff \cExp{=}\cVal \land \aExp{=}\aVal$,
      \item \label{write-term-empty-addr}
        if $\aEvs=\emptyset$ then $\aTerm \riff \FALSE$.
      \end{enumerate}
    \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\cExp}[\aThrd]$ then
  $(\exists\cVal\in\Val)$
  $(\exists\aVal\in\Val)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
    \item \label{read-E-addr}
      if $\fcard{\aEvs}\leq1$,
    \item \label{read-lambda-addr}
      $\labelingAct(\aEv) = \DR[\amode]{\REF{\cVal}}[\ascope]{\aVal}[\aThrd]$
    \item \label{read-kappa-addr}
      \begin{math}
        \labelingForm(\aEv) 
        \riff
        \cExp{=}\cVal
        \land \Q{\REF{\cVal}}
      \end{math},
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}4]{}{read-tau-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-tau-dep-addr}
        if $\aEv\in\aEvs$ and $\aEv\in\bEvs$ then
        % \begin{math}
        %   (\forall\aEv\in\aEvs\cap\bEvs)
        % \end{math}
        \makebox[0pt][l]{\begin{math}
            \aTr{\bEvs}{\bForm} \riff
            (\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv})
            \limplies \bForm[\uReg{\aEv}/\aReg]
          \end{math},}
      \item \label{read-tau-ind-addr}
        if $\aEv\in\aEvs$ and $\aEv\not\in\bEvs$ then
        % \begin{math}
        %   (\forall\aEv\in\aEvs\setminus\bEvs)
        % \end{math}
        \makebox[0pt][l]{\begin{math}
            \aTr{\bEvs}{\bForm} \riff
            \PBR{(\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv}) \lor (\cExp{=}\cVal\limplies\REF{\cVal}{=}\uReg{\aEv})}
            \limplies
            \bForm[\uReg{\aEv}/\aReg]
          \end{math},}
        \columnbreak
      \item \label{read-tau-empty-addr}
        if $\aEvs=\emptyset$ then 
        \begin{math}
          (\forall\bReg)
        \end{math}
        \begin{math}
          \aTr{\bEvs}{\bForm} \riff 
          \bForm[\bReg/\aReg],
        \end{math}  
      \end{enumerate}  
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}5]{}{read-term-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-term-nonempty-addr}
        if $\aEvs\neq\emptyset$ or $\amode\lemode\mRLX$ then $\aTerm \riff \TRUE$. 
      \item \label{read-term-empty-addr}
        if $\aEvs=\emptyset$ and $\amode\gemode\mACQ$ then $\aTerm \riff \FALSE$. 
      \end{enumerate}      
    % \item \label{read-term-addr}
    %   if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \riff \FALSE$. 
    \end{enumerate}
  \end{multicols}
\end{definition}

The combination of read-read independency (\textsection\ref{sec:read-read}) and address
calculation is somewhat delicate.  
% , in
% \ref{read-tau-dep-addr}.  The subsection of \textsection\ref{sec:diff} on
% \ref{xCausal} discusses this example using the semantics of \jjr{}.
Consider the following program, from \cite[\textsection5]{DBLP:journals/pacmpl/JagadeesanJR20}, where initially $x=0$, $y=0$, $\REF{0}=0$,
$\REF{1}=2$, and $\REF{2}=1$.  It should only be possible to read $0$,
disallowing the attempted execution below:
\begin{gather*}
  \begin{gathered}
    \PR{y}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{x}{s}
    \PAR
    \PR{x}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{y}{s}
    \\[-1ex]
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a1}{\DR{y}{2}}{}
        \event{a2}{\DR{\REF{2}}{1}}{right=of a1}
        \event{a3}{\DW{x}{1}}{right=of a2}
        \po{a2}{a3}
        \po[out=15,in=165]{a1}{a3}
        \event{b1}{\DR{x}{1}}{right=3em of a3}
        \event{b2}{\DR{\REF{1}}{2}}{right=of b1}
        \event{b3}{\DW{y}{2}}{right=of b2}
        \po{b2}{b3}
        \po[out=15,in=165]{b1}{b3}
        \rf[out=-170,in=-10]{b3}{a1}
        \rf{a3}{b1}
      \end{tikzinline}}
  \end{gathered}
\end{gather*}
This execution would become possible, however, if we were to replace
$(\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv})$ by $(\aVal{=}\uReg{\aEv})$ in
\ref{read-tau-dep-addr}.  In this case, $\DRP{y}{2}$ would not necessarily be dependency
ordered before $\DWP{x}{1}$.
% % 
% In isolation, the precondition of $\DWP{x}{1}$ is $(s=1)$.  Using the erroneous
% definition of \ref{read-tau-dep-addr}, the precondition becomes $(1{=}s)\limplies (s=1)$

% Looking at the left thread:
% \begin{align*}
%   \begin{gathered}[t]
%     \PR{y}{r}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a}{\DR{y}{2}}{}
%       \xform{xi}{(2{=}r\lor\RW)\limplies\bForm}{above=of a}
%       \xform{xd}{2{=}r\limplies\bForm}{below=of a}
%       \xo[xright]{a}{xd}
%     \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}[t]
%     \PR{\REF{r}}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{b}{r\EQ2\mid\DR{\REF{2}}{1}}{}
%       \xform{xd}{(r\EQ2\limplies 1\EQ s) \limplies\bForm}{below=of b}
%       \xform{xi}{((r\EQ2\limplies 1\EQ s)\lor\RW) \limplies\bForm}{above=of b}
%       \xo[xright]{b}{xd}
%     \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}[t]
%     \PW{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{b}{s\EQ1\mid\DW{x}{1}}{}
%       \xform{xd}{\bForm}{below=of b}
%       \xform{xi}{\bForm}{above=of b}
%       \xo[out=-30]{b}{xd}
%     \end{tikzinline}}
%   \end{gathered}
% \end{align*}
% Composing, we have:
% \begin{gather*}
%   \begin{gathered}
%     \PR{y}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DR{y}{2}}{}
%       \event{a2}{(2{=}r\lor\RW)\limplies r\EQ2\mid\DR{\REF{2}}{1}}{right=of a1}
%       \event{a3}{(2{=}r\lor\RW)\limplies (r\EQ2\limplies 1\EQ s)
%       \limplies s\EQ1\mid\DW{x}{1}}{below right=.5em and -8em of a2}
%       \po{a2}{a3}
%     \end{tikzinline}}
%   \end{gathered}
% \end{gather*}  
% Substituting for $\RW$:
% \begin{gather*}
%   \begin{gathered}
%     %     \PR{y}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{x}{s}
%     %     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DR{y}{2}}{}
%       \event{a2}{(2{=}r\lor\FALSE)\limplies r\EQ2\mid\DR{\REF{2}}{1}}{right=of a1}
%       \event{a3}{(2{=}r\lor\TRUE)\limplies (r\EQ2\limplies 1\EQ s)
%       \limplies s\EQ1\mid\DW{x}{1}}{below right=.5em and -8em of a2}
%       \po{a2}{a3}
%     \end{tikzinline}}
%   \end{gathered}
% \end{gather*}
% Which is:
% \begin{gather*}
%   \begin{gathered}
%     %     \PR{y}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{x}{s}
%     %     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DR{y}{2}}{}
%       \event{a2}{2{=}r\limplies r\EQ2\mid\DR{\REF{2}}{1}}{right=of a1}
%       \event{a3}{(r\EQ2\limplies 1\EQ s)
%       \limplies s\EQ1\mid\DW{x}{1}}{below right=.5em and -8em of a2}
%       \po{a2}{a3}
%     \end{tikzinline}}
%   \end{gathered}
% \end{gather*}
% The precondition of $\DRP{\REF{2}}{1}$ is a tautology, but the precondition
% of $\DWP{x}{1}$ is not.  This forces a dependency:
% \begin{gather*}
%   \begin{gathered}
%     \PR{y}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DR{y}{2}}{}
%       \event{a2}{2{=}r\limplies r\EQ2\mid\DR{\REF{2}}{1}}{right=of a1}
%       \event{a3}{2{=}r\limplies (r\EQ2\limplies 1\EQ s)
%       \limplies s\EQ1\mid\DW{x}{1}}{below right=.5em and -5em of a2}
%       \po[out=-20,in=180]{a1}{a3}
%       \po{a2}{a3}
%     \end{tikzinline}}
%   \end{gathered}
% \end{gather*}
% All the preconditions are now tautologies.

\subsection{Fences and Read-Modify-Write Operations}
\label{sec:fences}
\label{sec:rmw}

The semantics of fences is straightforward.
Let
\begin{math}
  \sembase{\PF[\ascope]{\fmode}} = \sFENCE[\ascope]{\fmode}[\aThrd],
\end{math}
where
if $\aPS \in \sFENCE[\ascope]{\amode}[\aThrd]$ then
% $(\exists\aLocs\subseteq\Loc)$
% $(\exists\bmode\in\{\amode,\mRLX\})$
\begin{multicols}{3}
  \begin{enumerate}[topsep=0pt,label=(\textsc{f}\arabic*),ref=\textsc{f}\arabic*]
  \item \label{fence-E}
    % $\aEvs\neq\emptyset$ and
    % if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
    $\fcard{\aEvs}\leq 1$,
  \item \label{fence-lambda}
    $\labelingAct(\aEv) = \DF[\ascope]{\amode}[\aThrd]$,
  \item \label{fence-kappa}
    $\labelingForm(\aEv) \riff \TRUE$,
  \item \label{fence-tau}
    $\aTr{\bEvs}{\bForm} \riff \bForm$,
    \stepcounter{enumi}      
  \item[] \labeltext[\textsc{f}5]{}{fence-term}
    \begin{enumerate}[leftmargin=0pt]
    \item \label{fence-term-nonempty}
      if $\aEvs\neq\emptyset$ then $\aTerm \riff \TRUE$,
    \item \label{fence-term-empty}
      if $\aEvs=\emptyset$ then $\aTerm \riff \FALSE$.
    \end{enumerate}
    % \item \label{fence-term}
    %   if $\aEvs=\emptyset$ then $\aTerm \riff \FALSE$.
  \end{enumerate}
\end{multicols}
This semantics is identical to that of
\cite{DBLP:journals/pacmpl/JagadeesanJR20}; see there for examples.

% \subsection{}

%We give the semantics of \RMW{}s without address calculation or if-closure.

% From the data model, we require an additional binary relation over
% $\Act\times\Act$: $\roverlapsdef$.  For the actions in this paper, we say
% $\aAct \roverlapsdef \bAct$ if they access the same location.

\RMW{} operations are more complex.  To support \RMW{}s, we add a relation
${\xrmw}\subseteq\aEvs\times\aEvs$ that relates the read of a successful
\RMW{} to the succeeding write.
% Let two actions \emph{overlap} if they access the same location.
% \begin{enumerate}
% \item
%   ${\rrmw} \subseteq {\le}$ is a relation capturing
%   \emph{read-modify-write atomicity}, such that for any $\cEv$, $\bEv$, $\aEv\in\aEvs$,
%   where $\labeling(\cEv)$ and
%   $\labeling(\bEv)$ access the same location:
%   \begin{itemize}
%   \item if $\bEv \xrmw \aEv$ and $\cEv\le \aEv$ then $\cEv\le \bEv$,
%   \item if $\bEv \xrmw \aEv$ and $\bEv\le \cEv$ then $\aEv\le \cEv$.
%   \end{itemize}
% \end{enumerate}

\begin{definition}
  Extend the definition of a pomset as follows. % where two actions \emph{overlap} if they access the same location:
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
    \setcounter{enumi}{9}
  \item \label{pom-rmw}
    ${\rrmw} : \aEvs\fun\aEvs$ is a partial function capturing
    read-modify-write \emph{atomicity}, such that
    \begin{enumerate}
    \item \label{pom-rmw-block}
      if $\bEv\xrmw\aEv$ then $\labeling(\aEv) \rblocks \labeling(\bEv)$,
    \item \label{pom-rmw-le}
      if $\bEv\xrmw\aEv$ then $\bEv \le \aEv$,    
    \item \label{pom-rmw-atomic}
      if $\labeling(\cEv) \roverlaps \labeling(\bEv)$ then
      \begin{enumerate}        
      \item \label{pom-rmw-atomic1}
        if $\bEv \xrmw \aEv$ then
        $\cEv\le \aEv$ implies $\cEv\le \bEv$,
      \item \label{pom-rmw-atomic2}
        if $\bEv \xrmw \aEv$ then
        $\bEv\le \cEv$ implies $\aEv\le \cEv$.
      \end{enumerate}
    \end{enumerate}
  \end{enumerate}

  Extend the definition of $\sSEMI{}{}$ and $\sIF{}{}{}$ to include:
  \begin{enumerate}
  \item[(\textsc{s}10)] (\textsc{i}10)\; % (\textsc{p}10)\; 
    ${\rrmw}=\PBR{{\rrmw_1}\cup{\rrmw_2}}$,
  \end{enumerate}
\end{definition}

To define specific operations, we extend the syntax:
\begin{align*}
  \aCmd
  \BNFDEF& \cdots 
  \BNFSEP \PCAS[\amode][\bmode]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
  \BNFSEP \PFADD[\amode][\bmode]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  \BNFSEP \PEXCHG[\amode][\bmode]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
\end{align*}
We require that $\aReg$ does not occur in $\cExp$.  The corresponding semantic functions are as follows.
\begin{definition}
  Let $\sLOADP{}{}$ be defined as for $\sLOAD{}{}$, adding the constraint:
  \begin{itemize}
  \item[{\labeltext[\textsc{r}4d]{(\textsc{r}4d)}{read-tau-rmw}}]
    if $(\aEvs\cap\bEvs)=\emptyset$ then
    \begin{math}
      \aTr{\bEvs}{\bForm} \rimplies
      \bForm.
    \end{math}
  \end{itemize}
  If $\aPS\in\mathit{FADD}(\aReg,\cExp,\aExp,\amode,\bmode)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode]{\aReg}{\cExp}}{\sSTORE[\bmode]{\cExp}{\aReg{+}\aExp}})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
  \end{enumerate}
  If $\aPS\in\mathit{EXCHG}(\aReg,\cExp,\aExp,\amode,\bmode)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode]{\aReg}{\cExp}}{\sSTORE[\bmode]{\cExp}{\aExp}})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
  \end{enumerate}
  If $\aPS\in\mathit{CAS}(\aReg,\cExp,\aExp,\bExp,\amode,\bmode)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode]{\aReg}{\cExp}}{\sIF{\aReg{=}\aExp}\sTHEN\sSTORE[\bmode]{\cExp}{\bExp}\sELSE\sSKIP\sFI})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
  \end{enumerate}
\end{definition}
  % If $\aPS\in\mathit{FADD}(\aReg,\aLoc,\aExp,\amode_1,\amode_2)$ then
  % $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode_1]{\aReg}{\aLoc}}{\sSTORE[\amode_2]{\aLoc}{\aReg{+}\aExp}})$
  % \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  % \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
  %   $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
  %   $\bEv\xrmw\aEv$.
  %   % \item if $\labeling_1(\bEv)$ is a read, then there is a write $\labeling_1(\aEv)$ such that 
  %   %   $\labelingForm(\bEv)\rimplies\labelingForm(\aEv)$ and 
  %   %   $\bEv\xrmw\aEv$.
  % \end{enumerate}
  % If $\aPS\in\mathit{EXCHG}(\aReg,\aLoc,\aExp,\amode_1,\amode_2)$ then
  % $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode_1]{\aReg}{\aLoc}}{\sSTORE[\amode_2]{\aLoc}{\aExp}})$
  % \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  % \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
  %   $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
  %   $\bEv\xrmw\aEv$.
  %   % \item if $\labeling_1(\bEv)$ is a read, then there is a write $\labeling_1(\aEv)$ such that 
  %   %   $\labelingForm(\bEv)\rimplies\labelingForm(\aEv)$ and 
  %   %   $\bEv\xrmw\aEv$.
  % \end{enumerate}
  % If $\aPS\in\mathit{CAS}(\aReg,\aLoc,\aExp,\bExp,\amode_1,\amode_2)$ then
  % $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode_1]{\aReg}{\aLoc}}{\sIF{\aReg{=}\aExp}\sTHEN\sSTORE[\amode_2]{\aLoc}{\bExp}\sELSE\sSKIP\sFI})$
  % \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  % \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
  %   $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
  %   $\bEv\xrmw\aEv$.
  %   % \item if $\labeling_1(\bEv)$ is a read, then either
  %   %   \begin{enumerate}
  %   %   \item there is a write $\labeling_1(\aEv)$ such that $\labelingForm(\bEv)\rimplies\labelingForm(\aEv)$ and $\bEv\xrmw\aEv$, or
  %   %   \item 
  %   %   \end{enumerate}
  % \end{enumerate}
  % \begin{multicols}{2}
  %   \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  %   \item if $\labeling_1(\aEv)$ is a write, then $(\exists\bEv)$ such that
  %     \begin{enumerate}
  %     \item $\labeling_1(\aEv)\rblocks \labeling_1(\bEv)$,
  %     \item $\bEv\xrmw\aEv$,
  %     \end{enumerate}
  %     \columnbreak
  %   \item if $\labeling_1(\bEv)$ is a read, then $(\exists\aEv)$ such that
  %     \begin{enumerate}
  %     \item $\labeling_1(\aEv)\rblocks \labeling_1(\bEv)$,
  %     \item $\bEv\xrmw\aEv$,
  %     \item
  %       if $(\aEvs\cap\bEvs)=\emptyset$ then
  %       \begin{math}
  %         \aTr{\bEvs}{\bForm} \rimplies \bForm[\aExp/\aLoc].
  %       \end{math}
  %     \end{enumerate}
  %   \end{enumerate}
  % \end{multicols}

This definition ensures atomicity and supports lowering to Arm load/store
exclusive operations.  See \cite{DBLP:journals/pacmpl/JagadeesanJR20} for examples.

One subtlety of the definition is that we use $\sLOADP{}{}$ rather than
$\sLOAD{}{}$.  Thus, for \RMW{} operations, the independent case for a read
is the same as the empty case.  To see why this should be, consider the
relaxed variant of the \textsc{cdrf} example from
\cite{DBLP:conf/pldi/LeeCPCHLV20}, using $\sLOAD{}{}$ rather than $\sLOADP{}{}$.
\begin{gather*}
  \begin{gathered}
    \PW{x}{0}\SEMI
    \begin{aligned}[t]
      (&\PFADD[\mRLX][\mRLX]{x}{r}{1}\SEMI \IF{\BANG r}\THEN \IF{y}\THEN \PW{x}{0} \FI \FI \;\;\PAR
      \\&
      \PFADD[\mRLX][\mRLX]{x}{r}{1}\SEMI \IF{\BANG r}\THEN \PW{y}{1} \FI)
    \end{aligned}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{i}{\DW{x}{0}}{}
        \event{b0}{\DR{x}{0}}{right=3em of i}
        \event{b0b}{\DW{x}{1}}{right=of b0}
        \event{b1}{\DR{y}{1}}{right=of b0b}
        \event{b2}{\DW{x}{0}}{right=of b1}
        \event{a1}{\DR{x}{0}}{right=3em of b2}
        \event{a1b}{\DW{x}{1}}{right=of a1}
        \event{a2}{\DW{y}{1}}{right=of a1b}
        \rmw{a1}{a1b}
        \rmw{b0}{b0b}
        \rf{i}{b0}
        \rf[out=-165,in=-12]{a2}{b1}
        \wki[out=20,in=160]{b0b}{b2}
        % \sync{a1}{a2}
        % \sync{b0}{b1}
        \po{b1}{b2}
        \rf{b2}{a1}
      \end{tikzinline}}
  \end{gathered}
\end{gather*}
A write should only be visible to one $\PFADD{}{}{}$ instruction, but here
the write of $0$ is visible to two.  This is allowed because no order is
required from $\DRP{x}{0}$ to $\DWP{y}{1}$ in the last thread.  To see why,
consider the independent transformers of the last thread and initializer:
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{0}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\DW{x}{0}}{}      
        \xform{xi}{\bForm[0/x]}{left=of a}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \smash{\FADD^{\mRLX,\mRLX}(x,1)}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a0}{\DR{x}{0}}{}
        %\node(a)[right=of a0]{};
        \event{a1}{\DW{x}{1}}{right=of a0}
        \rmw{a0}{a1}
        \xform{xi}{(0{=}r\lor x{=}r)\limplies\bForm[1/x]}{left=.5em of a0}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN \PW{y}{1} \FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a2}{r{=}0\mid\DW{y}{1}}{}      
        \xform{xi}{\bForm[1/y]}{left=of a2}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
After sequencing, the precondition of $\DWP{y}{1}$ is a tautology:
$(0{=}r\lor 0{=}r)\limplies r{=}0$.

By including \ref{read-tau-rmw}, $\sLOADP{}{}$ constrains the independent
predicate transformer of the $\PFADD{}{}{}$:
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{0}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\DW{x}{0}}{}      
        \xform{xi}{\bForm[0/x]}{left=of a}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \smash{\FADD^{\mRLX,\mRLX}(x,1)}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a0}{\DR{x}{0}}{}
        %\node(a)[right=of a0]{};
        \event{a1}{\DW{x}{1}}{right=of a0}
        \rmw{a0}{a1}
        \xform{xi}{\bForm[1/x]}{left=.5em of a0}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN \PW{y}{1} \FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a2}{r{=}0\mid\DW{y}{1}}{}      
        \xform{xi}{\bForm[1/y]}{left=of a2}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
After sequencing, the precondition of $\DWP{y}{1}$ is $r{=}0$, which is
\emph{not} a tautology.  This forces any top-level pomset to include
dependency order from $\DRP{x}{0}$ to $\DWP{y}{1}$.

% Here, local invariant reasoning is using the initializing write to $x$ to
% justify the independence of the write to $y$.  But this write is made
% unavailable by the first thread's successful \RMW{}.


\begin{comment}
  For case analysis of RMWs, we can use a general purpose expansion operator:

  \begin{definition}
    \noindent
    If $\aPS \in \sEXPAND\aPSS$ then
    $(\exists\aPS_1,\ldots,\aPS_n\in\aPSS)$
    $(\exists\cForm_1,\ldots,\cForm_n\in\Formulae)$
    % \\ let $\aPS_\aEv=\aPS_i$ if $\aEv\in\aEvs_i$ and $\cForm_\aEv=\cForm_i$ if $\aEv\in\aEvs_i$
    \begin{multicols}{2}
      \begin{enumerate}[topsep=0pt,label=(\textsc{e}\arabic*),ref=\textsc{e}\arabic*]
      \item[] \label{ca-psi}
        \begin{enumerate}[leftmargin=0pt]
        \item if $\cForm_i\land\cForm_j$ is satisfiable then $i=j$,        
        \item $\bigvee_i\cForm_i\riff\TRUE$,        
        \end{enumerate}
        \stepcounter{enumi}
      \item[] \label{ca-E}
        \begin{enumerate}[leftmargin=0pt]
        \item if $\aEvs_i\cap\aEvs_j\neq\emptyset$ then $i=j$,
        \item $\aEvs=\bigcup_i\aEvs_i$, %(\aEvs_1\cup\cdots\cup\aEvs_n)$,
          % \item if $\cForm_\aEv\land\cForm_\bEv$ is satisfiable then
          %   $(\exists i)$ $\aEv,\bEv\in\aEvs_i$,
        \end{enumerate}
      \item \label{ca-lambda}
        ${\labeling}=\bigcup_i{\labeling_i}$,%\PBR{{\labeling_1}\cup\cdots \cup {\labeling_n}}$,       
      \item \label{ca-kappa}
        \begin{math}
          \labelingForm(\aEv) \riff
          \cForm_\aEv\land \labelingForm_\aEv(\aEv)
        \end{math},
      \item \label{ca-tau}
        \begin{math}
          \aTr{\bEvs}{\bForm} \riff 
          \bigvee_i (\cForm_i\land \aTr[i]{\bEvs}{\bForm})
        \end{math},
      \item \label{ca-term}
        $\aTerm \riff \bigvee_i (\cForm_i\land \aTerm[i])$,
      \item ${\rrfx}=\bigcup_i{\rrfx_i}$,
      \item ${\le}=\bigcup_i{\le_i}$.
      \end{enumerate}
    \end{multicols}
  \end{definition}
\end{comment}


\subsection{If-Closure}
\label{sec:semca}

In order to model sequential composition, we must allow inconsistent
predicates in a single pomset, unlike \PwP{}
\cite{DBLP:journals/pacmpl/JagadeesanJR20}.  For example, if
$\aCmd=(\PW{x}{1})$, then the semantics \reffig{fig:seq} does \emph{not} allow:
\begin{gather*}
  \IF{\aExp}\THEN\PW{x}{1}\FI
  \SEMI
  \aCmd
  \SEMI
  \IF{\lnot\aExp}\THEN\PW{x}{1}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DW{x}{1}}{}
      \event{b}{\DW{x}{1}}{right=of a}
      \wki{a}{b}
    \end{tikzinline}}
\end{gather*}
However, if
$\aCmd=(\IF{\lnot\aExp}\THEN\PW{x}{1}\FI\SEMI\IF{\aExp}\THEN\PW{x}{1}\FI)$,
then it %\refdef{def:pomsets-trans}
\emph{does} allow the execution.  Looking at the initial program:
\begin{align*}
  \begin{gathered}
    \IF{\aExp}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{a}{\aExp\mid\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{a}{\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{\lnot\aExp}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{a}{\lnot\aExp\mid\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
\noindent
The difficulty is that the middle action can coalesce either with the right
action, or the left, but not both.  Thus, we are stuck with some
non-tautological precondition.  Our solution is to allow a pomset to
contain many events for a single action, as long as the events have
disjoint preconditions.

\refdef{def:semca} allows the execution, by splitting the middle command:
\begin{align*}
  \begin{gathered}
    \IF{\aExp}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \eventl{d}{a}{\aExp\mid\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \eventl{d}{a}{\lnot\aExp\mid\DW{x}{1}}{}
        \eventl{e}{b}{\aExp\mid\DW{x}{1}}{right=of a}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{\lnot\aExp}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \eventl{e}{a}{\lnot\aExp\mid\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
Coalescing events gives the desired result.


This is not simply a theoretical question; it is observable.  For example,
the semantics of \reffig{fig:seq} does not allow the following, since it must add order in the
first thread from the read of $y$ to one of the writes to $x$.
\begin{gather*}
  \begin{gathered}
    \PR{y}{r}\SEMI
    \IF{r}\THEN\PW{x}{1}\FI \SEMI
    \PW{x}{1} \SEMI
    \IF{\lnot r}\THEN\PW{x}{1}\FI\SEMI
    \PW{z}{r}
    \\[-.5ex]{}\PAR{}
    \IF{x}\THEN
    \PW{x}{0} \SEMI
    \IF{x}\THEN \PW{y}{1} \FI
    \FI
  \end{gathered}    
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DW{x}{1}}{}
      \event{a2}{\DW{x}{1}}{right=of a1}
      \event{a0}{\DR{y}{1}}{left=of a1}
      \event{a3}{\DW{z}{1}}{right=of a2}
      \wki{a1}{a2}
      \po[out=15,in=165]{a0}{a3}
      \event{b0}{\DR{x}{1}}{below right=1em and -1em of a0}
      \event{b1}{\DW{x}{0}}{right=of b0}
      \event{b2}{\DR{x}{1}}{right=of b1}
      \event{b3}{\DW{y}{1}}{right=of b2}
      \wki{b0}{b1}
      \wki{b1}{b2}
      \po{b2}{b3}
      \rf[out=158,in=-22]{b3}{a0}
      \rf{a1}{b0}
      \rf{a2}{b2}
      \wk{b1}{a2}
    \end{tikzinline}}
\end{gather*}  
% \begin{example}
%   \label{ex:if1}
%   \refdef{def:pomsets-trans} does \emph{not} allow:
%   \begin{gather*}
%     \aCmd=\PBR{
%     \PW{x}{0}\SEMI
%     \PW{x}{\BANG\BANG r}\SEMI
%     \PW{x}{1}
%   }
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%       \event{a}{\DW{x}{0}}{}
%       \event{b}{\DW{x}{1}}{right=of a}
%       \wk{a}{b}
%     \end{tikzinline}}
%   \end{gather*}
%   However, for any $\aExp$, \refdef{def:pomsets-trans} \emph{does} allow:
%   \begin{gather*}
%     \IF{\aExp}\THEN\aCmd\ELSE\aCmd\FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%       \event{a}{\DW{x}{0}}{}
%       \event{b}{\DW{x}{1}}{right=of a}
%       \wk{a}{b}
%     \end{tikzinline}}
%   \end{gather*}
%   If $r=0$, the middle store can merge left; otherwise, it can merge right.
% \end{example}

% The difficulty is that any pomset can contain at most one event for the
% middle store.  

\begin{definition}
  \label{def:semca}
  Let $\semca{}$ be defined as in \reffig{fig:seq}, changing $\sSTORE{}{}$ and $\sLOAD{}{}$:

  
  \noindent
  If $\aPS \in \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  \begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
  \item \label{write-E-ca}
    if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{write-lambda-ca}
    $\labelingAct(\aEv) = \DW[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$,
  \item \label{write-kappa-ca}
    \begin{math}
      \labelingForm(\aEv) \riff
      \cForm_\aEv
      \land \aExp{=}\aVal_\aEv
    \end{math},
    
    
  \item \label{write-tau-ca}
    % \begin{math}
    %   %   (\forall\aEv\in\aEvs\cap\bEvs)
    %   (\forall\aEv\in\aEvs)
    % \end{math}
    % \begin{math}
    %   \aTr{\bEvs}{\bForm} \riff 
    %   \cForm_\aEv
    %   \limplies 
    %   \bForm[\aExp/\aLoc]
    % \end{math},
    \begin{math}
      \begin{aligned}[t]
        \aTr{\bEvs}{\bForm} \riff
        &\textstyle\bigwedge_{\aEv\in\aEvs}
        \cForm_\aEv
        \limplies 
        \bForm[\aExp/\aLoc][\aExp{=}\aVal_\aEv/\Q{\aLoc}]
        \\[-.5ex]
        \land
        &\textstyle (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\aExp/\aLoc][\FALSE/\Q{\aLoc}]
      \end{aligned}
    \end{math}
    % \item
    %   \begin{math}    
    %     (\forall\aEv\in\aEvs\setminus\bEvs)
    %   \end{math}
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     \cForm_\aEv
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}
    % \item
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}.
  \item \label{write-term-ca}
    \begin{math}
      \aTerm \riff
      \PBR{\bigvee_{\aEv\in\aEvs}\cForm_\aEv}
      \land
      \PBR{\bigwedge_{\aEv\in\aEvs}\cForm_\aEv \limplies \aExp{=}\aVal_\aEv},
    \end{math}
    % \stepcounter{enumi}
    % \item[] \labeltext[\textsc{w}5]{}{write-term-ca}
    %   \begin{enumerate}[leftmargin=0pt]
    %   \item \label{write-term-nonempty-ca}
    %     $\aTerm \riff \cForm_\aEv \limplies \aExp{=}\aVal_\aEv$,
    %   \item \label{write-term-empty-ca}
    %     $\aTerm \riff \bigvee_{\aEv\in\aEvs}\cForm_\aEv$.
    %   \end{enumerate}
  \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  \begin{minipage}{1.0\linewidth}
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$ 
  \begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-ca}
    if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{read-lambda-ca}
    $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  \item \label{read-kappa-ca}
    \begin{math}
      \labelingForm(\aEv) \riff      
      \cForm_\aEv
      \land\Q{\aLoc}
    \end{math},
  \item \label{read-tau-ca}
    \begin{math}
      \begin{aligned}[t]
        (\forall\bReg)
        \aTr{\bEvs}{\bForm} \riff
        &\textstyle\bigwedge_{\aEv\in\aEvs\cap\bEvs}
        \cForm_\aEv
        \limplies \aVal_\aEv{=}\uReg{\aEv}
        \limplies \bForm[\uReg{\aEv}/\aReg]
        \\[-.5ex]
        \land
        &\textstyle\bigwedge_{\aEv\in\aEvs\setminus\bEvs}
        \cForm_\aEv 
        \limplies
        \PBR{\aVal_\aEv{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}}
        \limplies
        \bForm[\uReg{\aEv}/\aReg]
        \\[-.5ex]
        \land
        &\textstyle (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\bReg/\aReg]
      \end{aligned}
    \end{math}
    \columnbreak
  % \item[] \labeltext[\textsc{r}4]{}{read-tau-ca}
  %   \begin{enumerate}[leftmargin=0pt]
  %   \item \label{read-tau-dependent-ca}
  %     \begin{math}
  %       (\forall\aEv\in\aEvs\cap\bEvs)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff
  %       \cForm_\aEv
  %       \limplies \aVal_\aEv{=}\uReg{\aEv}
  %       \limplies \bForm[\uReg{\aEv}/\aReg]
  %     \end{math},
      
  %   \item \label{read-tau-independent-ca}
  %     \begin{math}
  %       (\forall\aEv\in\aEvs\setminus\bEvs)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff
  %       \cForm_\aEv 
  %       \limplies
  %       \PBR{\aVal_\aEv{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}}
  %       \limplies
  %       \bForm[\uReg{\aEv}/\aReg]
  %     \end{math},
      
  %   \item \label{read-tau-empty-ca}
  %     \begin{math}
  %       (\forall\bReg)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff 
  %       % (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
  %       (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
  %       \limplies 
  %       \bForm[\bReg/\aReg],
  %     \end{math}  
  %   \end{enumerate}  
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}5]{}{read-term-ca}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-term-nonempty-ca}
        if $\amode\lemode\mRLX$ then $\aTerm \riff \TRUE$. 
      \item \label{read-term-empty-ca}
        if $\amode\gemode\mACQ$ then $\aTerm \riff \bigvee_{\aEv\in\aEvs}\cForm_\aEv$. 
      \end{enumerate}      
  % \item \label{read-term-ca}
  %   if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \riff \FALSE$. 
  \end{enumerate}
  % \begin{multicols}{2}
  %   \noindent
  %   And either
  %   \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  %     \setcounter{enumi}{1}
  %   \item \label{read-lambda-x}
  %     $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  %   \item \label{read-kappa-x}
  %     \begin{math}
  %       \labelingForm(\aEv) \riff
  %       \cForm_\aEv
  %     \end{math},
  %   \end{enumerate}
  %   or $\amode\neq\mRLX$ and
  %   \begin{enumerate}[topsep=0pt,label=(\textsc{d}\arabic*),ref=\textsc{d}\arabic*]
  %     \setcounter{enumi}{1}
  %   \item \label{read-lambda-x}
  %     $\labelingAct(\aEv) = \DR[\mRLX]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  %   \item \label{read-kappa-x}
  %     \begin{math}
  %       \labelingForm(\aEv) \riff
  %       \cForm_\aEv\land \aLoc{=}\aVal_\aEv
  %     \end{math},
  %   \end{enumerate}
  \end{multicols}
  \end{minipage}
  % \medskip
  % Could make \textsc{d}4b:
  % \begin{math}
  %   (\forall\aEv\in\aEvs\setminus\bEvs)
  % \end{math}
  % \begin{math}
  %   \aTr{\bEvs}{\bForm} \riff
  %   \cForm_\aEv 
  %   \limplies
  %   \PBR{\aVal_\aEv{=}\uReg{\aEv} \land \aLoc{=}\uReg{\aEv}}
  %   \limplies
  %   \bForm[\uReg{\aEv}/\aReg][\uReg{\aEv}/\aLoc]
  % \end{math},
  % \medskip Similarly, let $\frf{\semca{}}$ be defined as for $\frf{\semrr{}}$
  % in \refdef{def:sem:frf}, with these definitions of $\sSTORE{}{}$ and
  % $\sLOAD{}{}$.
\end{definition}
The definition allows multiple events to represent a single action, each with
a disjoint precondition.  The predicate transformers are derived from those
defined for the conditional.

We show how to combine address calculation and if-closure in
\textsection\ref{sec:semcaaddr}.


\endinput

\begin{example}
  This definition ensures atomicity, disallowing executions such as
  \cite[Ex.~3.2]{DBLP:journals/pacmpl/PodkopaevLV19}:
  \begin{gather*}
    % \taglabel{RMW1}
    \begin{gathered}
      \PW{x}{0}\SEMI \PFADD[\mRLX][\mRLX]{x}{s}{1}
      \PAR
      \PW{x}{2}\SEMI \PR{x}{s}
      \\
      \hbox{\begin{tikzinline}[node distance=1.5em]
          \event{a2}{\DR{x}{0}}{}
          \event{a1}{\DW{x}{0}}{left=of a2}
          \rf{a1}{a2}
          \event{a3}{\DW{x}{2}}{right=of a2}
          \wk{a2}{a3}
          \event{b2}{\DW{x}{1}}{right=of a3}
          \event{b3}{\DR{x}{1}}{right=of b2}
          \rmw[out=-15,in=-165]{a2}[below]{b2}
          \wk{a3}{b2}
          \rf{b2}{b3}
        \end{tikzinline}}
    \end{gathered}
  \end{gather*}
  By \ref{pom-rmw-atomic1}, since $\DWP{x}{2}\xwk\DWP{x}{1}$, it must be that
  $\DWP{x}{2}\xwk\DRP{x}{0}$, creating a cycle.
\end{example}

\begin{example}
  \label{ex:rmw-33}
  Two successful \RMW{}s cannot see the same write:
  \begin{gather*}
    \begin{gathered}
      \PW{x}{0}\SEMI (\FADD^{\mRLX,\mRLX}(\aLoc,1)\PAR \FADD^{\mRLX,\mRLX}(\aLoc,1))
      \\
      \hbox{\begin{tikzinline}[node distance=1.5em]
          \event{i}{\DW{x}{0}}{}
          \event{a1}{a{:}\DR{x}{0}}{right=3em of i}
          \event{a2}{b{:}\DW{x}{1}}{right=of a1}
          \event{b1}{c{:}\DR{x}{0}}{right=3em of a2}
          \event{b2}{d{:}\DW{x}{1}}{right=of b1}
          \rmw{a1}{a2}
          \rmw{b1}{b2}
          \rf{i}{a1}
          \rf[out=15,in=165]{i}{b1}
          \wk[out=-15,in=-165]{a1}{b2}
          % \wk{a1}{b2}
          \wk{b1}{a2}
        \end{tikzinline}}
    \end{gathered}
  \end{gather*}
  The order from read-to-write is required by fulfillment.  
  Apply \ref{A1} to $a\xwk d$, we have that $a\xwk c$.  Subsequently
  applying \ref{A2}, we have $b \xwk c$, creating a cycle.
\end{example}

\begin{example}
  By using two actions rather than one, the definition allows examples such as the
  following, which is allowed by \armeight{} 
  \cite[Ex.~3.10]{DBLP:journals/pacmpl/PodkopaevLV19}:
  \begin{gather*}
    % \taglabel{RMW2}
    \begin{gathered}
      \PR{y}{r}\SEMI
      \PW{z}{r}
      \PAR
      \PR{z}{r}\SEMI
      \PW{x}{0}\SEMI
      \PFADD[\mRLX][\mREL]{x}{s}{1} \SEMI
      \PW{y}{s}{+}1
      \\[-1ex]
      \hbox{\begin{tikzinline}[node distance=1.5em]
          \event{a1}{\DR{y}{1}}{}
          \event{a2}{\DW{z}{1}}{right=of a1}
          \po{a1}{a2}
          \event{b1}{\DR{z}{1}}{right=3em of a2}
          \rf{a2}{b1}
          \event{b2}{\DW{x}{0}}{right=of b1}
          \event{b3}{\DR{x}{0}}{right=of b2}
          \rf{b2}{b3}
          \event{b4}{\DWRel{x}{1}}{right=2em of b3}
          \rmw{b3}{b4}
          \event{b5}{\DW{y}{1}}{right=of b4}
          \sync[out=-15,in=-165]{b1}{b4}
          \po[out=-20,in=-160]{b3}{b5}
          \rf[out=170,in=10]{b5}{a1}
        \end{tikzinline}}
    \end{gathered}
  \end{gather*}
\end{example}

\begin{example}
  Consider the \textsc{cdrf} example from \cite{DBLP:conf/pldi/LeeCPCHLV20}:
  \begin{gather*}
    \begin{gathered}
      \begin{aligned}
        &\PFADD[\mACQ][\mREL]{x}{r}{1}\SEMI \IF{r{=}0}\THEN \PW{y}{1} \FI
        \\\PAR\;\;&
        \PFADD[\mACQ][\mREL]{x}{r}{1}\SEMI \IF{r{=}0}\THEN \IF{y}\THEN \PW{x}{0} \FI \FI
      \end{aligned}
      \\
      \hbox{\footnotesize\begin{tikzinline}[node distance=1.5em]
          \raevent{a1}{\DR[\mACQ]{x}{0}}{}
          \raevent{a1b}{\DW[\mREL]{x}{1}}{right=of a1}
          \event{a2}{\DW{y}{1}}{right=of a1b}
          \raevent{b0}{\DR[\mACQ]{x}{0}}{right=3em of a2}
          \raevent{b0b}{\DW[\mREL]{x}{1}}{right=of b0}
          \event{b1}{\DR{y}{1}}{right=of b0b}
          \event{b2}{\DW{x}{0}}{right=of b1}
          \rmw{a1}{a1b}
          \rmw{b0}{b0b}
          \rf[out=-13,in=-163]{a2}{b1}
          \sync[out=20,in=160]{a1}{a2}
          \sync[out=20,in=160]{b0}{b1}
          \po{b1}{b2}
          \rf[out=-165,in=-12]{b2}{a1}
        \end{tikzinline}}
    \end{gathered}
  \end{gather*}
\end{example}
\begin{example}
  Consider this example from \cite[\textsection C]{DBLP:conf/pldi/LeeCPCHLV20}:
  \begin{gather*}
    \begin{gathered}
      \begin{aligned}
        &\PCAS[\mRLX][\mRLX]{x}{r}{0}{1}\SEMI \IF{r{\leq}1}\THEN \PW{y}{1} \FI
        \\\PAR\;\;&
        \PCAS[\mRLX][\mRLX]{x}{r}{0}{2}\SEMI \IF{r{=}0}\THEN \IF{y}\THEN \PW{x}{0} \FI \FI
      \end{aligned}
      \\
      \hbox{\footnotesize\begin{tikzinline}[node distance=1.5em]
          \event{a1}{\DR{x}{0}}{}
          \event{a1b}{\DW{x}{1}}{right=of a1}
          \event{a2}{\DW{y}{1}}{right=of a1b}
          \event{b0}{\DR{x}{0}}{right=3em of a2}
          \event{b0b}{\DW{x}{2}}{right=of b0}
          \event{b1}{\DR{y}{1}}{right=of b0b}
          \event{b2}{\DW{x}{0}}{right=of b1}
          \rmw{a1}{a1b}
          \rmw{b0}{b0b}
          \rf[out=-13,in=-163]{a2}{b1}
          \sync[out=20,in=160]{a1}{a2}
          \sync[out=20,in=160]{b0}{b1}
          \po{b1}{b2}
          \rf[out=-165,in=-12]{b2}{a1}
        \end{tikzinline}}
    \end{gathered}
  \end{gather*}
\end{example}
% \begin{example}
%   Let $\CAS$ return the value read, which is sufficient to determine whether
%   the $\CAS$ succeeded.
%   \begin{align*}
%     \begin{gathered}
%       \DW{x}{0}\SEMI(
%       \IF{\BANG \CAS(x,0,1)}\THEN \PW{y}{1} \FI
%       \PAR
%       \IF{\BANG \CAS(x,0,1)}\THEN \PW{z}{1} \FI
%       )
%       \\
%       \hbox{\begin{tikzinline}[node distance=1.5em]
%         \event{a1}{\DR{x}{0}}{}
%         \event{a2}{\DW{x}{1}}{right=of a1}
%         \event{a3}{\DW{y}{1}}{right=of a2}
%         \event{b1}{\DR{x}{1}}{right=4em of a3}
%         \event{b2}{\DW{z}{1}}{right=of b1}          
%         \event{i}{\DW{x}{0}}{left=4em of a1}          
%         \rmw{a1}{a2}
%         \rf{i}{a1}
%         \rf[out=-15,in=-165]{a2}{b1}
%       \end{tikzinline}}
%     \end{gathered}
%   \end{align*}
%   This clearly should not be allowed.
%   What's gone wrong here is that 
% \end{example}

