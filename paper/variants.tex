\section{Additional Features} %Case Analysis, Address Calculation, RMWs, Elimination}
\label{sec:additional}

In the paper so far, we have assumed that registers are assigned at most
once.  We have done this primarily for readability.  In the first subsection
of this paper, drop this assumption, instead using substitution to rename
registers.  We use the set
$\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$.  By assumption
(\textsection\ref{sec:prelim}), these registers do not appear in programs:
$\aCmd[\bExp/\uReg{\aEv}]=\aCmd$.  The resulting semantics satisfies
redundant read elimination.

In the rest of this section we consider several orthogonal features: address
calculation, if-closure, read-modify-write operations, and access
elimination.

These extensions preserve all of the valid transformations discussed thus far.
We state the extensions with respect to the base semantics of
\reffig{fig:sem}, but they apply equally to the variants described in
\textsection\ref{sec:arm}.

\subsection{Register Recycling and Redundant Read Elimination}
\label{sec:semreg}

JMM Test Case 2 \citep{PughWebsite} states the following
execution should be allowed ``since redundant read elimination could result
in simplification of $\aReg{=}\bReg$ to true, allowing $\PW{y}{1}$ to be
moved early.''
\begin{gather*}
  \PR{x}{r}\SEMI
  \PR{x}{s}\SEMI
  \IF{r{=}s}\THEN \PW{y}{1}\FI
  \PAR
  \PW{x}{y}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \eventl{\bEv}{a1}{\DR{x}{1}}{}
      % \event{a2}{\DR{x}{1}}{right=of a1}
      \eventr{\aEv}{a3}{\DW{y}{1}}{right=of a1}
      % \po{a1}{a3}
      % \po[out=-20,in=-160]{a1}{a3}
      \event{b1}{\DR{y}{1}}{right=3em of a3}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \rf{a3}{b1}
      \po{b1}{b2}
      % \rf[out=169,in=11]{b2}{a2}
      \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
This execution is not allowed by $\sembase{}$: the precondition of
$\aEv$ in the independent case is
\begin{displaymath}
  (1{=}r \lor x{=}r)\limplies (1{=}s \lor r{=}s)\limplies (r{=}s),
\end{displaymath}
which is not a tautology, and thus $\sembase{}$ requires order from
$\bEv$  to $\aEv$.

This execution is allowed, however, if we rename registers using a map from
event names to register names.  By using this renaming, coalesced events must
choose the same register name.  In the above example, the precondition of
$\aEv$ in the independent case becomes
\begin{displaymath}
  (1{=}\uReg{\aEv} \lor x{=}\uReg{\aEv})\limplies (1{=}\uReg{\aEv} \lor \uReg{\aEv}{=}\uReg{\aEv})\limplies (\uReg{\aEv}{=}\uReg{\aEv}),
\end{displaymath}
which is a tautology.

\begin{definition}
  Let $\semreg{}$ be defined as in \reffig{fig:sem}, changing \ref{read-tau}
  of $\sLOAD{}{}$:

  \noindent
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
    % \item \label{read-E}
    %   if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
    % \item \label{read-lambda}
    %   $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
    %   \stepcounter{enumi}
    %   \stepcounter{enumi}
    \setcounter{enumi}{4}
  \item[] \labeltext[\textsc{r}4]{}{read-tau-reg}
    \begin{enumerate}[leftmargin=0pt]
    \item \label{read-tau-dep-reg}
      if $(\aEvs\cap\bEvs)\neq\emptyset$ then
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \aVal{=}\uReg{\aEv}
        \limplies \bForm[\uReg{\aEv}/\aReg]
      \end{math},    
    \item \label{read-tau-ind-reg}
      if $\aEvs\neq\emptyset$ and $(\aEvs\cap\bEvs)=\emptyset$ then
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \PBR{\aVal{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}} \limplies
        \bForm[\uReg{\aEv}/\aReg],
      \end{math}
    \item \label{read-tau-empty-reg}
      if $\aEvs=\emptyset$ then $(\forall\bReg)$
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \bForm[\bReg/\aReg].
      \end{math}
    \end{enumerate}
  \end{enumerate}
  % \medskip
  % Similarly, let $\frf{\semreg{}}$ be defined as for
  % $\frf{\semrr{}}$ in \refdef{def:sem:frf}, with this definition of
  % $\sLOAD{}{}$.
\end{definition}


With this semantics, it is straightforward to see that redundant load
elimination is sound:
\begin{displaymath}
  \semreg{\PR[\amode]{\aLoc}{\aReg} \SEMI \PR[\amode]{\aLoc}{\bReg}} \supseteq 
  \semreg{\PR[\amode]{\aLoc}{\aReg} \SEMI \bReg  \GETS \aReg}
\end{displaymath}

\subsection{Address Calculation}
\label{sec:addr}

Inevitably, address calculation complicates the definitions of $\sSTORE{}{}$ and $\sLOAD{}{}$.
\begin{definition}
  \label{def:semaddr}
  Let $\semaddr{}$ be defined as in \reffig{fig:sem}, changing $\sSTORE{}{}$ and $\sLOAD{}{}$:

  \noindent
  If $\aPS \in \sSTORE[\amode]{\cExp}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\cVal\in\Val)$
  $(\exists\aVal\in\Val)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
    \item \label{write-E-addr}
      if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
    \item \label{write-lambda-addr}
      $\labelingAct(\aEv) = \DW[\amode]{\REF{\cVal}}[\ascope]{\aVal}[\aThrd]$,
    \item \label{write-kappa-addr}
      \begin{math}
        \labelingForm(\aEv) \rimplies
        \cExp{=}\cVal
        \land \aExp{=}\aVal
      \end{math},      
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{w}4]{}{write-tau-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-tau-addr}
        if $\aEvs\neq\emptyset$ then 
        \begin{math}
          \aTr{\bEvs}{\bForm} \rimplies 
          (\cExp{=}\cVal)
          \limplies 
          \bForm[\aExp/\REF{\cVal}]
        \end{math},
      \item \label{write-tau-empty-addr}
        if $\aEvs=\emptyset$ then \\
        \begin{math}
          (\forall\dVal)
        \end{math}        
        \begin{math}
          \aTr{\bEvs}{\bForm} \rimplies 
          (\cExp{=}\dVal)
          \limplies 
          \bForm
          [\aExp/\REF{\dVal}]
        \end{math}  
      \end{enumerate}  
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{w}5]{}{write-term-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-term-nonempty-addr}
        if $\aEvs\neq\emptyset$ then $\aTerm \rimplies \cExp{=}\cVal \land \aExp{=}\aVal$,
      \item \label{write-term-empty-addr}
        if $\aEvs=\emptyset$ then $\aTerm \rimplies \FALSE$.
      \end{enumerate}
    \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\cExp}[\aThrd]$ then
  $(\exists\cVal\in\Val)$
  $(\exists\aVal\in\Val)$
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-addr}
    if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item \label{read-lambda-addr}
    $\labelingAct(\aEv) = \DR[\amode]{\REF{\cVal}}[\ascope]{\aVal}[\aThrd]$
  \item \label{read-kappa-addr}
    \begin{math}
      \labelingForm(\aEv) 
      \land \cExp{=}\cVal
    \end{math},
    \stepcounter{enumi}
  \item[] \labeltext[\textsc{r}4]{}{read-tau-addr}
    \begin{enumerate}[leftmargin=0pt]
    \item \label{read-tau-dep-addr}
      \begin{math}
        (\forall\aEv\in\aEvs\cap\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        (\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv})
        \limplies \bForm[\uReg{\aEv}/\aReg]
      \end{math},      
    \item \label{read-tau-ind-addr}
      \begin{math}
        (\forall\aEv\in\aEvs\setminus\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \PBR{(\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv}) \lor (\cExp{=}\cVal\limplies\REF{\cVal}{=}\uReg{\aEv})}
        \limplies
        \bForm[\uReg{\aEv}/\aReg]
      \end{math},      
    \item \label{read-tau-empty-addr}
      \begin{math}
        (\forall\bReg)
      \end{math}
      if $\aEvs=\emptyset$ then 
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies 
        \bForm[\bReg/\aReg].
      \end{math}  
    \end{enumerate}  
  \end{enumerate}
\end{definition}

The combination of read-read independency (\refdef{def:semrr}) and address
calculation is somewhat delicate.  
% , in
% \ref{read-tau-dep-addr}.  The subsection of \textsection\ref{sec:diff} on
% \ref{xCausal} discusses this example using the semantics of \jjr{}.
Consider the following program, from \jjr{\textsection5}, where initially $x=0$, $y=0$, $\REF{0}=0$,
$\REF{1}=2$, and $\REF{2}=1$.  It should only be possible to read $0$,
disallowing the attempted execution below:
\begin{gather*}
  \begin{gathered}
    \PR{y}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{x}{s}
    \PAR
    \PR{x}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{y}{s}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a1}{\DR{y}{2}}{}
        \event{a2}{\DR{\REF{2}}{1}}{right=of a1}
        \event{a3}{\DW{x}{1}}{right=of a2}
        \po{a2}{a3}
        \po[out=10,in=170]{a1}{a3}
        \event{b1}{\DR{x}{1}}{right=3em of a3}
        \event{b2}{\DR{\REF{1}}{2}}{right=of b1}
        \event{b3}{\DW{y}{2}}{right=of b2}
        \po{b2}{b3}
        \po[out=10,in=170]{b1}{b3}
        \rf[out=-170,in=-10]{b3}{a1}
        \rf{a3}{b1}
      \end{tikzinline}}
  \end{gathered}
\end{gather*}
This execution is possible, however, if we replace
$(\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv})$ by $(\aVal{=}\uReg{\aEv})$ in
\ref{read-tau-dep-addr}.  In this case, there is not necessarily a dependency
order from $\DRP{y}{2}$ to $\DWP{x}{1}$.
% % 
% In isolation, the precondition of $\DWP{x}{1}$ is $(s=1)$.  Using the erroneous
% definition of \ref{read-tau-dep-addr}, the precondition becomes $(1{=}s)\limplies (s=1)$

% Looking at the left thread:
% \begin{align*}
%   \begin{gathered}[t]
%     \PR{y}{r}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a}{\DR{y}{2}}{}
%       \xform{xi}{(2{=}r\lor\RW)\limplies\bForm}{above=of a}
%       \xform{xd}{2{=}r\limplies\bForm}{below=of a}
%       \xo[xright]{a}{xd}
%     \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}[t]
%     \PR{\REF{r}}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{b}{r\EQ2\mid\DR{\REF{2}}{1}}{}
%       \xform{xd}{(r\EQ2\limplies 1\EQ s) \limplies\bForm}{below=of b}
%       \xform{xi}{((r\EQ2\limplies 1\EQ s)\lor\RW) \limplies\bForm}{above=of b}
%       \xo[xright]{b}{xd}
%     \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}[t]
%     \PW{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{b}{s\EQ1\mid\DW{x}{1}}{}
%       \xform{xd}{\bForm}{below=of b}
%       \xform{xi}{\bForm}{above=of b}
%       \xo[out=-30]{b}{xd}
%     \end{tikzinline}}
%   \end{gathered}
% \end{align*}
% Composing, we have:
% \begin{gather*}
%   \begin{gathered}
%     \PR{y}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DR{y}{2}}{}
%       \event{a2}{(2{=}r\lor\RW)\limplies r\EQ2\mid\DR{\REF{2}}{1}}{right=of a1}
%       \event{a3}{(2{=}r\lor\RW)\limplies (r\EQ2\limplies 1\EQ s)
%       \limplies s\EQ1\mid\DW{x}{1}}{below right=.5em and -8em of a2}
%       \po{a2}{a3}
%     \end{tikzinline}}
%   \end{gathered}
% \end{gather*}  
% Substituting for $\RW$:
% \begin{gather*}
%   \begin{gathered}
%     %     \PR{y}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{x}{s}
%     %     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DR{y}{2}}{}
%       \event{a2}{(2{=}r\lor\FALSE)\limplies r\EQ2\mid\DR{\REF{2}}{1}}{right=of a1}
%       \event{a3}{(2{=}r\lor\TRUE)\limplies (r\EQ2\limplies 1\EQ s)
%       \limplies s\EQ1\mid\DW{x}{1}}{below right=.5em and -8em of a2}
%       \po{a2}{a3}
%     \end{tikzinline}}
%   \end{gathered}
% \end{gather*}
% Which is:
% \begin{gather*}
%   \begin{gathered}
%     %     \PR{y}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{x}{s}
%     %     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DR{y}{2}}{}
%       \event{a2}{2{=}r\limplies r\EQ2\mid\DR{\REF{2}}{1}}{right=of a1}
%       \event{a3}{(r\EQ2\limplies 1\EQ s)
%       \limplies s\EQ1\mid\DW{x}{1}}{below right=.5em and -8em of a2}
%       \po{a2}{a3}
%     \end{tikzinline}}
%   \end{gathered}
% \end{gather*}
% The precondition of $\DRP{\REF{2}}{1}$ is a tautology, but the precondition
% of $\DWP{x}{1}$ is not.  This forces a dependency:
% \begin{gather*}
%   \begin{gathered}
%     \PR{y}{r}\SEMI \PR{\REF{r}}{s}\SEMI \PW{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DR{y}{2}}{}
%       \event{a2}{2{=}r\limplies r\EQ2\mid\DR{\REF{2}}{1}}{right=of a1}
%       \event{a3}{2{=}r\limplies (r\EQ2\limplies 1\EQ s)
%       \limplies s\EQ1\mid\DW{x}{1}}{below right=.5em and -5em of a2}
%       \po[out=-20,in=180]{a1}{a3}
%       \po{a2}{a3}
%     \end{tikzinline}}
%   \end{gathered}
% \end{gather*}
% All the preconditions are now tautologies.

\subsection{If-Closure}
\label{sec:semca}

In order to model sequential composition, we must allow inconsistent
predicates in a single pomset, unlike \jjr{}.  For example, if
$\aCmd=(\PW{x}{1})$, then $\sembase{}$ does \emph{not} allow:
\begin{gather*}
  \IF{\aExp}\THEN\PW{x}{1}\FI
  \SEMI
  \aCmd
  \SEMI
  \IF{\lnot\aExp}\THEN\PW{x}{1}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DW{x}{1}}{}
      \event{b}{\DW{x}{1}}{right=of a}
      \wk{a}{b}
    \end{tikzinline}}
\end{gather*}
However, if
$\aCmd=(\IF{\lnot\aExp}\THEN\PW{x}{1}\FI\SEMI\IF{\aExp}\THEN\PW{x}{1}\FI)$,
then it %\refdef{def:pomsets-trans}
\emph{does} allow the execution.  Looking at the initial program:
\begin{align*}
  \begin{gathered}
    \IF{\aExp}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{a}{\aExp\mid\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{a}{\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{\lnot\aExp}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{a}{\lnot\aExp\mid\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
\noindent
The difficulty is that the middle action can coalesce either with the right
action, or the left, but not both.  Thus, we are stuck with some
non-tautological precondition.  Our solution is to allow a pomset to
contain many events for a single action, as long as the events have
disjoint preconditions.

\refdef{def:semca} allows the execution, by splitting the middle command:
\begin{align*}
  \begin{gathered}
    \IF{\aExp}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \eventl{d}{a}{\aExp\mid\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \eventl{d}{a}{\lnot\aExp\mid\DW{x}{1}}{}
        \eventl{e}{b}{\aExp\mid\DW{x}{1}}{right=of a}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{\lnot\aExp}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \eventl{e}{a}{\lnot\aExp\mid\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
Coalescing events gives the desired result.


This is not simply a theoretical question; it is observable.
For example, $\sembase{}$ does not allow the following.
\begin{gather*}
  \begin{gathered}
    \PR{y}{r}\SEMI
    \IF{r}\THEN\PW{x}{1}\FI \SEMI
    \PW{x}{1} \SEMI
    \IF{\lnot r}\THEN\PW{x}{1}\FI\SEMI
    \PW{z}{r}
    \\[-.5ex]{}\PAR{}
    \IF{x}\THEN
    \PW{x}{0} \SEMI
    \IF{x}\THEN \PW{y}{1} \FI
    \FI
  \end{gathered}    
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DW{x}{1}}{}
      \event{a2}{\DW{x}{1}}{right=of a1}
      \wk{a1}{a2}
      \event{a0}{\DR{y}{1}}{left=of a1}
      \event{a3}{\DW{z}{1}}{right=of a2}
      \po[out=20,in=160]{a0}{a3}
      \event{b0}{\DR{x}{1}}{below right=1em and -1em of a0}
      \event{b1}{\DW{x}{0}}{right=of b0}
      \event{b2}{\DR{x}{1}}{right=of b1}
      \event{b3}{\DW{y}{1}}{right=of b2}
      \wk{b0}{b1}
      \wk{b1}{b2}
      \po{b2}{b3}
      \rf{b3}{a0}
      \rf{a1}{b0}
      \rf{a2}{b2}
      \wk{b1}{a2}
    \end{tikzinline}}
\end{gather*}  
% \begin{example}
%   \label{ex:if1}
%   \refdef{def:pomsets-trans} does \emph{not} allow:
%   \begin{gather*}
%     \aCmd=\PBR{
%     \PW{x}{0}\SEMI
%     \PW{x}{\BANG\BANG r}\SEMI
%     \PW{x}{1}
%   }
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%       \event{a}{\DW{x}{0}}{}
%       \event{b}{\DW{x}{1}}{right=of a}
%       \wk{a}{b}
%     \end{tikzinline}}
%   \end{gather*}
%   However, for any $\aExp$, \refdef{def:pomsets-trans} \emph{does} allow:
%   \begin{gather*}
%     \IF{\aExp}\THEN\aCmd\ELSE\aCmd\FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%       \event{a}{\DW{x}{0}}{}
%       \event{b}{\DW{x}{1}}{right=of a}
%       \wk{a}{b}
%     \end{tikzinline}}
%   \end{gather*}
%   If $r=0$, the middle store can merge left; otherwise, it can merge right.
% \end{example}

% The difficulty is that any pomset can contain at most one event for the
% middle store.  

\begin{definition}
  \label{def:semca}
  Let $\semca{}$ be defined as in \reffig{fig:sem}, changing $\sSTORE{}{}$ and $\sLOAD{}{}$:

  
  \noindent
  If $\aPS \in \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  % \begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
  \item \label{write-E-ca}
    if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{write-lambda-ca}
    $\labelingAct(\aEv) = \DW[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$,
  \item \label{write-kappa-ca}
    \begin{math}
      \labelingForm(\aEv) \rimplies
      \cForm_\aEv
      \land \aExp{=}\aVal_\aEv
    \end{math},
    
    
  \item \label{write-tau-ca}
    % \begin{math}
    %   %   (\forall\aEv\in\aEvs\cap\bEvs)
    %   (\forall\aEv\in\aEvs)
    % \end{math}
    \begin{math}
      \aTr{\bEvs}{\bForm} \rimplies 
      \cForm_\aEv
      \limplies 
      \bForm[\aExp/\aLoc]
    \end{math},
    % \item
    %   \begin{math}    
    %     (\forall\aEv\in\aEvs\setminus\bEvs)
    %   \end{math}
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     \cForm_\aEv
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}
    % \item
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}.
  \item \label{write-term-ca}
    $\aTerm \rimplies \cForm_\aEv \limplies \aExp{=}\aVal_\aEv$,
    % \stepcounter{enumi}
    % \item[] \labeltext[\textsc{w}5]{}{write-term-ca}
    %   \begin{enumerate}[leftmargin=0pt]
    %   \item \label{write-term-nonempty-ca}
    %     $\aTerm \rimplies \cForm_\aEv \limplies \aExp{=}\aVal_\aEv$,
    %   \item \label{write-term-empty-ca}
    %     $\aTerm \rimplies \bigvee_{\aEv\in\aEvs}\cForm_\aEv$.
    %   \end{enumerate}
  \end{enumerate}
  % \end{multicols}

  \medskip
  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$ 
  % \begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-ca}
    if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{read-lambda-ca}
    $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  \item \label{read-kappa-ca}
    \begin{math}
      \labelingForm(\aEv) \rimplies
      \cForm_\aEv
    \end{math},
    \stepcounter{enumi}
  \item[] \labeltext[\textsc{r}4]{}{read-tau-ca}
    \begin{enumerate}[leftmargin=0pt]
    \item \label{read-tau-dependent-ca}
      \begin{math}
        (\forall\aEv\in\aEvs\cap\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \cForm_\aEv
        \limplies \aVal_\aEv{=}\uReg{\aEv}
        \limplies \bForm[\uReg{\aEv}/\aReg]
      \end{math},
      
    \item \label{read-tau-independent-ca}
      \begin{math}
        (\forall\aEv\in\aEvs\setminus\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \cForm_\aEv 
        \limplies
        \PBR{\aVal_\aEv{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}}
        \limplies
        \bForm[\uReg{\aEv}/\aReg]
      \end{math},
      
    \item \label{read-tau-empty-ca}
      \begin{math}
        (\forall\bReg)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies 
        % (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
        (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\bReg/\aReg].
      \end{math}  
    \end{enumerate}  
  \end{enumerate}
  % \begin{multicols}{2}
  %   \noindent
  %   And either
  %   \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  %     \setcounter{enumi}{1}
  %   \item \label{read-lambda-x}
  %     $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  %   \item \label{read-kappa-x}
  %     \begin{math}
  %       \labelingForm(\aEv) \rimplies
  %       \cForm_\aEv
  %     \end{math},
  %   \end{enumerate}
  %   or $\amode\neq\mRLX$ and
  %   \begin{enumerate}[topsep=0pt,label=(\textsc{d}\arabic*),ref=\textsc{d}\arabic*]
  %     \setcounter{enumi}{1}
  %   \item \label{read-lambda-x}
  %     $\labelingAct(\aEv) = \DR[\mRLX]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  %   \item \label{read-kappa-x}
  %     \begin{math}
  %       \labelingForm(\aEv) \rimplies
  %       \cForm_\aEv\land \aLoc{=}\aVal_\aEv
  %     \end{math},
  %   \end{enumerate}
  % \end{multicols}
  % \medskip
  % Could make \textsc{d}4b:
  % \begin{math}
  %   (\forall\aEv\in\aEvs\setminus\bEvs)
  % \end{math}
  % \begin{math}
  %   \aTr{\bEvs}{\bForm} \rimplies
  %   \cForm_\aEv 
  %   \limplies
  %   \PBR{\aVal_\aEv{=}\uReg{\aEv} \land \aLoc{=}\uReg{\aEv}}
  %   \limplies
  %   \bForm[\uReg{\aEv}/\aReg][\uReg{\aEv}/\aLoc]
  % \end{math},
  % \medskip Similarly, let $\frf{\semca{}}$ be defined as for $\frf{\semrr{}}$
  % in \refdef{def:sem:frf}, with these definitions of $\sSTORE{}{}$ and
  % $\sLOAD{}{}$.
\end{definition}



\subsection{Combining Address Calculation and If-Closure}

\refdef{def:semaddr} is naive with respect to merging events.  Consider the
following example:
\begin{align*}
  \begin{gathered}
    \PW{\REF{r}}{0}\SEMI \PW{\REF{0}}{\BANG r}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \eventl{c}{a}{r\EQ1\mathbin{\mid}\DW{\REF{1}}{0}}{}
        \eventl{d}{b}{r\EQ1\mathbin{\mid}\DW{\REF{0}}{0}}{right=of a}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PW{\REF{r}}{0}\SEMI \PW{\REF{0}}{\BANG r}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \eventl{d}{a}{r\EQ0\mathbin{\mid}\DW{\REF{0}}{0}}{}
        \eventl{e}{b}{r\EQ0\mathbin{\mid}\DW{\REF{0}}{1}}{right=of a}
        \wk{a}{b}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
Merging, we have:
% Thus, the disjunction closure also includes both of the following: % By using \!$\PAR$\!, it also includes:
\begin{align*}
  \begin{gathered}
    \IF{\aExp}\THEN
    \PW{\REF{r}}{0}\SEMI \PW{\REF{0}}{\BANG r}
    \ELSE
    \PW{\REF{r}}{0}\SEMI \PW{\REF{0}}{\BANG r}
    \FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \eventl{c}{a}{r\EQ1\mathbin{\mid}\DW{\REF{1}}{0}}{}
        \eventl{d}{b}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{\REF{0}}{0}}{right=of a}
        \eventl{e}{c}{r\EQ0\mathbin{\mid}\DW{\REF{0}}{1}}{right=of b}
        \wk{b}{c}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
% \begin{align*}
%   \begin{gathered}
%     \IF{\aExp}\THEN
%     \PW{\REF{r}}{0}\SEMI \PW{\REF{0}}{\BANG r}
%     \ELSE
%     \PW{\REF{r}}{0}\SEMI \PW{\REF{0}}{\BANG r}
%     \FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%       \eventl{c}{a}{r\EQ1\mathbin{\mid}\DW{\REF{1}}{0}}{}
%       \eventl{d}{b}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{\REF{0}}{0}}{right=of a}
%     \end{tikzinline}}
%   \end{gathered}
% \end{align*}
The precondition of $\DWREF{0}{0}$ is a tautology; however, this is not
possible for $(\PW{\REF{r}}{0}\SEMI \PW{\REF{0}}{\BANG r})$ alone, using \refdef{def:semaddr}.

\refdef{def:semcaaddr}, enables this execution using if-closure.  Under this
semantics, we have:
\begin{align*}
  \begin{gathered}
    \PW{\REF{r}}{0}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \eventl{c}{a}{r\EQ1\mathbin{\mid}\DW{\REF{1}}{0}}{}
        \eventl{d}{b}{r\EQ0\mathbin{\mid}\DW{\REF{0}}{0}}{right=of a}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PW{\REF{0}}{\BANG r}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \eventl{d}{b}{r\EQ1\mathbin{\mid}\DW{\REF{0}}{0}}{}
        \eventl{e}{c}{r\EQ0\mathbin{\mid}\DW{\REF{0}}{1}}{right=of b}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
% These pomsets contain inconsistent preconditions.  This is disallowed in
% \jjr{}, but allowed here.
Sequencing and merging: 
\begin{align*}
  \begin{gathered}
    \PW{\REF{r}}{0}
    \SEMI
    \PW{\REF{0}}{\BANG r}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \eventl{c}{a}{r\EQ1\mathbin{\mid}\DW{\REF{1}}{0}}{}
        \eventl{d}{b}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{\REF{0}}{0}}{right=of a}
        \eventl{e}{c}{r\EQ0\mathbin{\mid}\DW{\REF{0}}{1}}{right=of b}
        \wk{b}{c}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
The precondition of $\DWP{\REF{0}}{0}$ is a tautology, as required.

\begin{definition}
  \label{def:semcaaddr}
  Let $\semcaaddr{}$ be defined as in \reffig{fig:sem}, changing
  $\sSTORE{}{}$ and $\sLOAD{}{}$:

  \noindent
  If $\aPS \in \sSTORE[\amode]{\cExp}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\cVal:\aEvs\fun\Val)$
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
    \item \label{write-E-ca-addr}
      if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
    \item \label{write-lambda-ca-addr}
      $\labelingAct(\aEv) = \DW[\amode]{\REF{\cVal}}[\ascope]{\aVal_\aEv}[\aThrd]$,
    \item \label{write-kappa-ca-addr}
      \begin{math}
        \labelingForm(\aEv) \rimplies
        \cForm_\aEv
        \land \cExp{=}\cVal_\aEv
        \land \aExp{=}\aVal_\aEv
      \end{math},      
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{w}4]{}{write-tau-ca-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-tau-ca-addr}
        \begin{math}
          \aTr{\bEvs}{\bForm} \rimplies 
          \cForm_\aEv
          \limplies (\cExp{=}\cVal)
          \limplies 
          \bForm[\aExp/\REF{\cVal}]
        \end{math},
      \item \label{write-tau-empty-ca-addr}
        \begin{math}
          (\forall\dVal)
        \end{math}
        \\
        \begin{math}
          \aTr{\bEvs}{\bForm} \rimplies 
          % (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
          (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
          \limplies (\cExp{=}\dVal)
          \limplies 
          \bForm
          [\aExp/\REF{\dVal}]
        \end{math}  
      \end{enumerate}  
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{w}5]{}{write-term-ca-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-term-nonempty-ca-addr}
        $\aTerm \rimplies \cForm_\aEv \limplies \cExp{=}\cVal_\aEv \land \aExp{=}\aVal_\aEv$,
      \item \label{write-term-empty-ca-addr}
        $\aTerm \rimplies \bigvee_{\aEv\in\aEvs}\cForm_\aEv$.
      \end{enumerate}
    \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\cExp}[\aThrd]$ then
  $(\exists\cVal:\aEvs\fun\Val)$
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$ 
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-ca-addr}
    if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{read-lambda-ca-addr}
    $\labelingAct(\aEv) = \DR[\amode]{\REF{\cVal}}[\ascope]{\aVal_\aEv}[\aThrd]$
  \item \label{read-kappa-ca-addr}
    \begin{math}
      \labelingForm(\aEv) \rimplies
      \cForm_\aEv
      \land \cExp{=}\cVal_\aEv
    \end{math},
    \stepcounter{enumi}
  \item[] \labeltext[\textsc{r}4]{}{read-tau-ca-addr}
    \begin{enumerate}[leftmargin=0pt]
    \item \label{read-tau-dependent-ca-addr}
      \begin{math}
        (\forall\aEv\in\aEvs\cap\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \cForm_\aEv
        \limplies (\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv})
        \limplies \bForm[\uReg{\aEv}/\aReg]
      \end{math},      
    \item \label{read-tau-independent-ca-addr}
      \begin{math}
        (\forall\aEv\in\aEvs\setminus\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \cForm_\aEv 
        \limplies
        \PBR{(\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv}) \lor (\cExp{=}\cVal_\aEv\limplies\REF{\cVal}{=}\uReg{\aEv})}
        \limplies
        \bForm[\uReg{\aEv}/\aReg]
      \end{math},      
    \item \label{read-tau-empty-ca-addr}
      \begin{math}
        (\forall\bReg)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies 
        (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\bReg/\aReg].
      \end{math}  
    \end{enumerate}  
  \end{enumerate}
  % \medskip Similarly, let $\frf{\semaddr{}}$ be defined as for $\frf{\semrr{}}$
  % in \refdef{def:sem:frf}, with these definitions of $\sSTORE{}{}$ and
  % $\sLOAD{}{}$.
\end{definition}



\subsection{Read-Modify-Write Operations}

We give the semantics of \RMW{}s without address calculation or if-closure.

From the data model, we require an additional binary relation over
$\Act\times\Act$: $\roverlapsdef$.  For the actions in this paper, we say
$\aAct \roverlapsdef \bAct$ if they access the same location.

\RMW{} operations are formalized by adding a relation
${\xrmw}\subseteq\aEvs\times\aEvs$ that relates the read of a successful
\RMW{} to the succeeding write.
% Let two actions \emph{overlap} if they access the same location.
% \begin{enumerate}
% \item
%   ${\rrmw} \subseteq {\le}$ is a relation capturing
%   \emph{read-modify-write atomicity}, such that for any $\cEv$, $\bEv$, $\aEv\in\aEvs$,
%   where $\labeling(\cEv)$ and
%   $\labeling(\bEv)$ access the same location:
%   \begin{itemize}
%   \item if $\bEv \xrmw \aEv$ and $\cEv\le \aEv$ then $\cEv\le \bEv$,
%   \item if $\bEv \xrmw \aEv$ and $\bEv\le \cEv$ then $\aEv\le \cEv$.
%   \end{itemize}
% \end{enumerate}

\begin{definition}
  Extend the definition of a pomset as follows. % where two actions \emph{overlap} if they access the same location:
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
    \setcounter{enumi}{7}
  \item \label{pom-rmw}
    ${\rrmw} : \Event\fun\Event$ is a partial function capturing
    read-modify-write \emph{atomicity}, such that
    \begin{enumerate}
    \item \label{pom-rmw-block}
      if $\bEv\xrmw\aEv$ then $\labeling(\aEv) \rblocks \labeling(\bEv)$,
    \item \label{pom-rmw-le}
      if $\bEv\xrmw\aEv$ then $\bEv \le \aEv$,    
    \item \label{pom-rmw-atomic}
      if $\labeling(\cEv) \roverlaps \labeling(\bEv)$ then
      \begin{enumerate}        
      \item \label{pom-rmw-atomic1}
        if $\bEv \xrmw \aEv$ then
        $\cEv\le \aEv$ implies $\cEv\le \bEv$,
      \item \label{pom-rmw-atomic2}
        if $\bEv \xrmw \aEv$ then
        $\bEv\le \cEv$ implies $\aEv\le \cEv$.
      \end{enumerate}
    \end{enumerate}
  \end{enumerate}

  Extend the definition of par, if, seq to include:
  \begin{enumerate}
    \setcounter{enumi}{7}
  \item[(\textsc{p}0)] (\textsc{s}0)\; (\textsc{c}0)\; ${\rrmw}=\PBR{{\rrmw_1}\cup{\rrmw_2}}$,
  \end{enumerate}
\end{definition}

To define specific operations, we extend the syntax:
\begin{align*}
  \aCmd
  \BNFDEF& \cdots 
  \BNFSEP \PCAS[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
  \BNFSEP \PFADD[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  \BNFSEP \PEXCHG[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
\end{align*}
The corresponding semantic functions are as follows.
\begin{definition}
  Let $\sLOADP{}{}$ be defined as for $\sLOAD{}{}$, adding the constraint:
  \begin{itemize}
  \item[{\labeltext[\textsc{r}4d]{(\textsc{r}4d)}{read-tau-rmw}}]
    if $(\aEvs\cap\bEvs)=\emptyset$ then
    \begin{math}
      \aTr{\bEvs}{\bForm} \rimplies
      \bForm.
    \end{math}
  \end{itemize}
  If $\aPS\in\mathit{FADD}(\aReg,\aLoc,\aExp,\amode_1,\amode_2)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode_1]{\aReg}{\aLoc}}{\sSTORE[\amode_2]{\aLoc}{\aReg{+}\aExp}})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
    % \item if $\labeling_1(\bEv)$ is a read, then there is a write $\labeling_1(\aEv)$ such that 
    %   $\labelingForm(\bEv)\rimplies\labelingForm(\aEv)$ and 
    %   $\bEv\xrmw\aEv$.
  \end{enumerate}
  If $\aPS\in\mathit{EXCHG}(\aReg,\aLoc,\aExp,\amode_1,\amode_2)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode_1]{\aReg}{\aLoc}}{\sSTORE[\amode_2]{\aLoc}{\aExp}})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
    % \item if $\labeling_1(\bEv)$ is a read, then there is a write $\labeling_1(\aEv)$ such that 
    %   $\labelingForm(\bEv)\rimplies\labelingForm(\aEv)$ and 
    %   $\bEv\xrmw\aEv$.
  \end{enumerate}
  If $\aPS\in\mathit{CAS}(\aReg,\aLoc,\aExp,\bExp,\amode_1,\amode_2)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode_1]{\aReg}{\aLoc}}{\sIF{\aReg{=}\aExp}\sTHEN\sSTORE[\amode_2]{\aLoc}{\bExp}\sELSE\sSKIP\sFI})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
    % \item if $\labeling_1(\bEv)$ is a read, then either
    %   \begin{enumerate}
    %   \item there is a write $\labeling_1(\aEv)$ such that $\labelingForm(\bEv)\rimplies\labelingForm(\aEv)$ and $\bEv\xrmw\aEv$, or
    %   \item 
    %   \end{enumerate}
  \end{enumerate}
  % \begin{multicols}{2}
  %   \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  %   \item if $\labeling_1(\aEv)$ is a write, then $(\exists\bEv)$ such that
  %     \begin{enumerate}
  %     \item $\labeling_1(\aEv)\rblocks \labeling_1(\bEv)$,
  %     \item $\bEv\xrmw\aEv$,
  %     \end{enumerate}
  %     \columnbreak
  %   \item if $\labeling_1(\bEv)$ is a read, then $(\exists\aEv)$ such that
  %     \begin{enumerate}
  %     \item $\labeling_1(\aEv)\rblocks \labeling_1(\bEv)$,
  %     \item $\bEv\xrmw\aEv$,
  %     \item
  %       if $(\aEvs\cap\bEvs)=\emptyset$ then
  %       \begin{math}
  %         \aTr{\bEvs}{\bForm} \rimplies \bForm[\aExp/\aLoc].
  %       \end{math}
  %     \end{enumerate}
  %   \end{enumerate}
  % \end{multicols}
\end{definition}

This definition ensures atomicity and supports lowering to Arm load/store
exclusive operations.  See \jjr{} for examples.

One subtlety of the definition is that we use $\sLOADP{}{}$ rather than
$\sLOAD{}{}$.  Thus, for \RMW{} operations, the independent case for a read
is the same as the empty case.  To see why this should be, consider the
relaxed variant of the \textsc{cdrf} example from
\cite{DBLP:conf/pldi/LeeCPCHLV20}, using $\sLOAD{}{}$ rather than $\sLOADP{}{}$.
\begin{gather*}
  \begin{gathered}
    \PW{x}{0}\SEMI
    \begin{aligned}[t]
      (&\PFADD[\mRLX][\mRLX]{x}{r}{1}\SEMI \IF{\BANG r}\THEN \IF{y}\THEN \PW{x}{0} \FI \FI \;\;\PAR
      \\&
      \PFADD[\mRLX][\mRLX]{x}{r}{1}\SEMI \IF{\BANG r}\THEN \PW{y}{1} \FI)
    \end{aligned}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{i}{\DW{x}{0}}{}
        \event{b0}{\DR{x}{0}}{right=3em of i}
        \event{b0b}{\DW{x}{1}}{right=of b0}
        \event{b1}{\DR{y}{1}}{right=of b0b}
        \event{b2}{\DW{x}{0}}{right=of b1}
        \event{a1}{\DR{x}{0}}{right=3em of b2}
        \event{a1b}{\DW{x}{1}}{right=of a1}
        \event{a2}{\DW{y}{1}}{right=of a1b}
        \rmw{a1}{a1b}
        \rmw{b0}{b0b}
        \rf{i}{b0}
        \rf[out=-165,in=-12]{a2}{b1}
        \wk[out=20,in=160]{b0b}{b2}
        % \sync{a1}{a2}
        % \sync{b0}{b1}
        \po{b1}{b2}
        \rf{b2}{a1}
      \end{tikzinline}}
  \end{gathered}
\end{gather*}
A write should only be visible to one $\PFADD{}{}{}$ instruction, but here
the write of $0$ is visible to two.  This is allowed because no order is
required from $\DRP{x}{0}$ to $\DWP{y}{1}$ in the last thread.  To see why,
consider the independent transformers of the last thread and initializer:
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{0}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\DW{x}{0}}{}      
        \xform{xi}{\bForm[0/x]}{left=of a}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \smash{\FADD^{\mRLX,\mRLX}(x,1)}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a0}{\DR{x}{0}}{}
        %\node(a)[right=of a0]{};
        \event{a1}{\DW{x}{1}}{right=of a0}
        \rmw{a0}{a1}
        \xform{xi}{(0{=}r\lor x{=}r)\limplies\bForm[1/x]}{left=.5em of a0}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN \PW{y}{1} \FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a2}{r{=}0\mid\DW{y}{1}}{}      
        \xform{xi}{\bForm[1/y]}{left=of a2}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
After sequencing, the precondition of $\DWP{y}{1}$ is a tautology:
$(0{=}r\lor 0{=}r)\limplies r{=}0$.

By including \ref{read-tau-rmw}, $\sLOADP{}{}$ constrains the independent
predicate transformer of the $\PFADD{}{}{}$:
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{0}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\DW{x}{0}}{}      
        \xform{xi}{\bForm[0/x]}{left=of a}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \smash{\FADD^{\mRLX,\mRLX}(x,1)}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a0}{\DR{x}{0}}{}
        %\node(a)[right=of a0]{};
        \event{a1}{\DW{x}{1}}{right=of a0}
        \rmw{a0}{a1}
        \xform{xi}{\bForm[1/x]}{left=.5em of a0}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN \PW{y}{1} \FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a2}{r{=}0\mid\DW{y}{1}}{}      
        \xform{xi}{\bForm[1/y]}{left=of a2}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
After sequencing, the precondition of $\DWP{y}{1}$ is $r{=}0$, which is
\emph{not} a tautology.  This forces any top-level pomset to include
dependency order from $\DRP{x}{0}$ to $\DWP{y}{1}$.

% Here, local invariant reasoning is using the initializing write to $x$ to
% justify the independence of the write to $y$.  But this write is made
% unavailable by the first thread's successful \RMW{}.


For case analysis of RMWs, we can use a general purpose expansion operator:

\begin{definition}
\noindent
If $\aPS \in \sEXPAND\aPSS$ then
$(\exists\aPS_1,\ldots,\aPS_n\in\aPSS)$
$(\exists\cForm_1,\ldots,\cForm_n\in\Formulae)$
% \\ let $\aPS_\aEv=\aPS_i$ if $\aEv\in\aEvs_i$ and $\cForm_\aEv=\cForm_i$ if $\aEv\in\aEvs_i$
\begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{e}\arabic*),ref=\textsc{e}\arabic*]
  \item[] \label{ca-psi}
    \begin{enumerate}[leftmargin=0pt]
    \item if $\cForm_i\land\cForm_j$ is satisfiable then $i=j$,        
    \item $\bigvee_i\cForm_i\rimplies\TRUE$,        
    \end{enumerate}
    \stepcounter{enumi}
  \item[] \label{ca-E}
    \begin{enumerate}[leftmargin=0pt]
    \item if $\aEvs_i\cap\aEvs_j\neq\emptyset$ then $i=j$,
    \item $\aEvs=\bigcup_i\aEvs_i$, %(\aEvs_1\cup\cdots\cup\aEvs_n)$,
      % \item if $\cForm_\aEv\land\cForm_\bEv$ is satisfiable then
      %   $(\exists i)$ $\aEv,\bEv\in\aEvs_i$,
    \end{enumerate}
  \item \label{ca-lambda}
    ${\labeling}=\bigcup_i{\labeling_i}$,%\PBR{{\labeling_1}\cup\cdots \cup {\labeling_n}}$,       
  \item \label{ca-kappa}
    \begin{math}
      \labelingForm(\aEv) \rimplies
      \cForm_\aEv\land \labelingForm_\aEv(\aEv)
    \end{math},
  \item \label{ca-tau}
    \begin{math}
      \aTr{\bEvs}{\bForm} \rimplies 
      \bigvee_i (\cForm_i\land \aTr[i]{\bEvs}{\bForm})
    \end{math},
  \item \label{ca-term}
    $\aTerm \rimplies \bigvee_i (\cForm_i\land \aTerm[i])$,
  \item ${\rrfx}=\bigcup_i{\rrfx_i}$,
  \item ${\le}=\bigcup_i{\le_i}$.
  \end{enumerate}
\end{multicols}
\end{definition}


\subsection{Access Elimination}
% For writes, change the label rules of sequential composition to:
% \begin{enumerate}
% \item %\label{par-lambda1}
%   if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labeling(\aEv) = \labeling_1(\aEv)$, 
% \item %\label{par-lambda2}
%   if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labeling(\aEv) = \labeling_2(\aEv)$,
% \item %\label{par-lambda2}
%   if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labeling(\aEv) \in \fmerge{\labeling_1(\aEv)}{\labeling_2(\aEv)}$.
% \end{enumerate}

% \begin{definition}
%   %   Fences use the three point order:
%   %   \begin{math}
%   %     \fREL \ltmode \mSC
%   %   \end{math}
%   %   and 
%   %   \begin{math}
%   %     \fACQ \ltmode \mSC.
%   %   \end{math}
%   \noindent    
%   \begin{align*}
%     \fmerge{\DR[\amode]{\aLoc}{\aVal}}{\DR[\bmode]{\aLoc}{\aVal}} &= \{ \DR[\amode\lubmode\bmode]{\aLoc}{\aVal} \}
%     \\
%     \fmerge{\DW[\amode]{\aLoc}{\aVal}}{\DW[\bmode]{\aLoc}{\bVal}} &= \{ \DW[\amode\lubmode\bmode]{\aLoc}{\bVal} \}
%     \\
%     \fmerge{\DF{\amode}}{\DF{\bmode}} &= \{ \DF{\amode\lubmode\bmode} \}
%     \\
%     \fmerge{\aAct}{\bAct} &= \emptyset, \textotherwise
%   \end{align*}
% \end{definition}  

Reordering and Merging:
\cite[\textsection7.1]{Kang19}
\cite[\textsection E]{DBLP:conf/cgo/ChakrabortyV17}

Examples of Unsafe Reorderings
\cite[\textsection D]{DBLP:conf/cgo/ChakrabortyV17}
See the slides for this paper...

Note that for associativity, you have to take the join of modes.
\begin{definition}
  \label{def:compat}
  Define $\fmerge{}{}:\Act\times\Act\fun2^{\Act}$ as follows.  If
  $\aAct_0\in\fmerge{\aAct_1}{\aAct_2}$, then $\aAct_1$ and $\aAct_2$ can
  coalesce, resulting in $\aAct_0$.  This is useful for replacing
  $(\PW{x}{1}\SEMI \PW{x}{2})$ by $(\PW{x}{2})$.
  \begin{align*}
    \fmerge{\DR[\amode]{\aLoc}{\aVal}}{\DR[\bmode]{\aLoc}{\aVal}}
    &= \{ \DR[\amode\lubmode\bmode]{\aLoc}{\aVal} \}
    \\
    \fmerge{\DW[\amode]{\aLoc}{\aVal}}{\DW[\bmode]{\aLoc}{\bVal}}
    &= \{ \DW[\amode\lubmode\bmode]{\aLoc}{\bVal} \}
    \\
    \fmerge{\DW[\amode]{\aLoc}{\aVal}}{\DR[\mRLX]{\aLoc}{\aVal}}
    &= \{ \DW[\amode]{\aLoc}{\aVal} \}
    \\
    \fmerge{\DW[\bmode]{\aLoc}{\aVal}}{\DR[\gemode\mACQ]{\aLoc}{\aVal}}
    &= \{ \DW[\mSC]{\aLoc}{\aVal} \}
    \\
    \fmerge{\DF{\amode}}{\DF{\bmode}} &= \{ \DF{\amode\lubmode\bmode} \}
    \\
    \fmerge{\aAct}{\bAct} &= \emptyset, \textotherwise
  \end{align*}
\end{definition}  

\begin{enumerate}
\item \label{seq-lambda1}
  if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labeling(\aEv)=\labeling_1(\aEv)$,
\item \label{seq-lambda2}
  if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labeling(\aEv)=\labeling_2(\aEv)$,
\item \label{seq-lambda12}
  if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labeling(\aEv)\in
  \fmerge{\labeling_1(\aEv)}{\labeling_2(\aEv)}$, the first has no rf,
\end{enumerate}

\endinput

\begin{example}
  This definition ensures atomicity, disallowing executions such as
  \cite[Ex.~3.2]{DBLP:journals/pacmpl/PodkopaevLV19}:
  \begin{gather*}
    % \taglabel{RMW1}
    \begin{gathered}
      \PW{x}{0}\SEMI \PFADD[\mRLX][\mRLX]{x}{s}{1}
      \PAR
      \PW{x}{2}\SEMI \PR{x}{s}
      \\
      \hbox{\begin{tikzinline}[node distance=1.5em]
          \event{a2}{\DR{x}{0}}{}
          \event{a1}{\DW{x}{0}}{left=of a2}
          \rf{a1}{a2}
          \event{a3}{\DW{x}{2}}{right=of a2}
          \wk{a2}{a3}
          \event{b2}{\DW{x}{1}}{right=of a3}
          \event{b3}{\DR{x}{1}}{right=of b2}
          \rmw[out=-15,in=-165]{a2}[below]{b2}
          \wk{a3}{b2}
          \rf{b2}{b3}
        \end{tikzinline}}
    \end{gathered}
  \end{gather*}
  By \ref{pom-rmw-atomic1}, since $\DWP{x}{2}\xwk\DWP{x}{1}$, it must be that
  $\DWP{x}{2}\xwk\DRP{x}{0}$, creating a cycle.
\end{example}

\begin{example}
  \label{ex:rmw-33}
  Two successful \RMW{}s cannot see the same write:
  \begin{gather*}
    \begin{gathered}
      \PW{x}{0}\SEMI (\FADD^{\mRLX,\mRLX}(\aLoc,1)\PAR \FADD^{\mRLX,\mRLX}(\aLoc,1))
      \\
      \hbox{\begin{tikzinline}[node distance=1.5em]
          \event{i}{\DW{x}{0}}{}
          \event{a1}{a{:}\DR{x}{0}}{right=3em of i}
          \event{a2}{b{:}\DW{x}{1}}{right=of a1}
          \event{b1}{c{:}\DR{x}{0}}{right=3em of a2}
          \event{b2}{d{:}\DW{x}{1}}{right=of b1}
          \rmw{a1}{a2}
          \rmw{b1}{b2}
          \rf{i}{a1}
          \rf[out=15,in=165]{i}{b1}
          \wk[out=-15,in=-165]{a1}{b2}
          % \wk{a1}{b2}
          \wk{b1}{a2}
        \end{tikzinline}}
    \end{gathered}
  \end{gather*}
  The order from read-to-write is required by fulfillment.  
  Apply \ref{A1} to $a\xwk d$, we have that $a\xwk c$.  Subsequently
  applying \ref{A2}, we have $b \xwk c$, creating a cycle.
\end{example}

\begin{example}
  By using two actions rather than one, the definition allows examples such as the
  following, which is allowed by \armeight{} 
  \cite[Ex.~3.10]{DBLP:journals/pacmpl/PodkopaevLV19}:
  \begin{gather*}
    % \taglabel{RMW2}
    \begin{gathered}
      \PR{y}{r}\SEMI
      \PW{z}{r}
      \PAR
      \PR{z}{r}\SEMI
      \PW{x}{0}\SEMI
      \PFADD[\mRLX][\mREL]{x}{s}{1} \SEMI
      \PW{y}{s}{+}1
      \\[-1ex]
      \hbox{\begin{tikzinline}[node distance=1.5em]
          \event{a1}{\DR{y}{1}}{}
          \event{a2}{\DW{z}{1}}{right=of a1}
          \po{a1}{a2}
          \event{b1}{\DR{z}{1}}{right=3em of a2}
          \rf{a2}{b1}
          \event{b2}{\DW{x}{0}}{right=of b1}
          \event{b3}{\DR{x}{0}}{right=of b2}
          \rf{b2}{b3}
          \event{b4}{\DWRel{x}{1}}{right=2em of b3}
          \rmw{b3}{b4}
          \event{b5}{\DW{y}{1}}{right=of b4}
          \sync[out=-15,in=-165]{b1}{b4}
          \po[out=-20,in=-160]{b3}{b5}
          \rf[out=170,in=10]{b5}{a1}
        \end{tikzinline}}
    \end{gathered}
  \end{gather*}
\end{example}

\begin{example}
  Consider the \textsc{cdrf} example from \cite{DBLP:conf/pldi/LeeCPCHLV20}:
  \begin{gather*}
    \begin{gathered}
      \begin{aligned}
        &\PFADD[\mACQ][\mREL]{x}{r}{1}\SEMI \IF{r{=}0}\THEN \PW{y}{1} \FI
        \\\PAR\;\;&
        \PFADD[\mACQ][\mREL]{x}{r}{1}\SEMI \IF{r{=}0}\THEN \IF{y}\THEN \PW{x}{0} \FI \FI
      \end{aligned}
      \\
      \hbox{\footnotesize\begin{tikzinline}[node distance=1.5em]
          \raevent{a1}{\DR[\mACQ]{x}{0}}{}
          \raevent{a1b}{\DW[\mREL]{x}{1}}{right=of a1}
          \event{a2}{\DW{y}{1}}{right=of a1b}
          \raevent{b0}{\DR[\mACQ]{x}{0}}{right=3em of a2}
          \raevent{b0b}{\DW[\mREL]{x}{1}}{right=of b0}
          \event{b1}{\DR{y}{1}}{right=of b0b}
          \event{b2}{\DW{x}{0}}{right=of b1}
          \rmw{a1}{a1b}
          \rmw{b0}{b0b}
          \rf[out=-13,in=-163]{a2}{b1}
          \sync[out=20,in=160]{a1}{a2}
          \sync[out=20,in=160]{b0}{b1}
          \po{b1}{b2}
          \rf[out=-165,in=-12]{b2}{a1}
        \end{tikzinline}}
    \end{gathered}
  \end{gather*}
\end{example}
\begin{example}
  Consider this example from \cite[\textsection C]{DBLP:conf/pldi/LeeCPCHLV20}:
  \begin{gather*}
    \begin{gathered}
      \begin{aligned}
        &\PCAS[\mRLX][\mRLX]{x}{r}{0}{1}\SEMI \IF{r{\leq}1}\THEN \PW{y}{1} \FI
        \\\PAR\;\;&
        \PCAS[\mRLX][\mRLX]{x}{r}{0}{2}\SEMI \IF{r{=}0}\THEN \IF{y}\THEN \PW{x}{0} \FI \FI
      \end{aligned}
      \\
      \hbox{\footnotesize\begin{tikzinline}[node distance=1.5em]
          \event{a1}{\DR{x}{0}}{}
          \event{a1b}{\DW{x}{1}}{right=of a1}
          \event{a2}{\DW{y}{1}}{right=of a1b}
          \event{b0}{\DR{x}{0}}{right=3em of a2}
          \event{b0b}{\DW{x}{2}}{right=of b0}
          \event{b1}{\DR{y}{1}}{right=of b0b}
          \event{b2}{\DW{x}{0}}{right=of b1}
          \rmw{a1}{a1b}
          \rmw{b0}{b0b}
          \rf[out=-13,in=-163]{a2}{b1}
          \sync[out=20,in=160]{a1}{a2}
          \sync[out=20,in=160]{b0}{b1}
          \po{b1}{b2}
          \rf[out=-165,in=-12]{b2}{a1}
        \end{tikzinline}}
    \end{gathered}
  \end{gather*}
\end{example}
% \begin{example}
%   Let $\CAS$ return the value read, which is sufficient to determine whether
%   the $\CAS$ succeeded.
%   \begin{align*}
%     \begin{gathered}
%       \DW{x}{0}\SEMI(
%       \IF{\BANG \CAS(x,0,1)}\THEN \PW{y}{1} \FI
%       \PAR
%       \IF{\BANG \CAS(x,0,1)}\THEN \PW{z}{1} \FI
%       )
%       \\
%       \hbox{\begin{tikzinline}[node distance=1.5em]
%         \event{a1}{\DR{x}{0}}{}
%         \event{a2}{\DW{x}{1}}{right=of a1}
%         \event{a3}{\DW{y}{1}}{right=of a2}
%         \event{b1}{\DR{x}{1}}{right=4em of a3}
%         \event{b2}{\DW{z}{1}}{right=of b1}          
%         \event{i}{\DW{x}{0}}{left=4em of a1}          
%         \rmw{a1}{a2}
%         \rf{i}{a1}
%         \rf[out=-15,in=-165]{a2}{b1}
%       \end{tikzinline}}
%     \end{gathered}
%   \end{align*}
%   This clearly should not be allowed.
%   What's gone wrong here is that 
% \end{example}

