% This paper presents the first compositional definition of sequential
% composition that applies to a relaxed memory model weak enough to allow
% efficient implementation on Arm.  We extend the denotational model of pomsets
% with preconditions with predicate transformers. Previous work has shown that
% pomsets with preconditions are a model of concurrent composition, and that
% predicate transformers are a model of sequential composition.  This paper
% show how they can be combined.

% Program logics and semantics tell us that in order to derive
% \begin{math}
%   ((S_1\SEMI S_2), \sigma_0) \Downarrow \sigma_2,
% \end{math}
% we derive 
% \begin{math}
%   (S_1, \sigma_0) \Downarrow \sigma_1
% \end{math}
% and then
% \begin{math}
%   (S_2, \sigma_1) \Downarrow \sigma_2.
% \end{math}
Program logics and semantics tell us that when executing ((S1; S2), state0),
we execute (S1, state0) to arrive at state1, then execute (S2, state1) to
arrive at the final state2.  This is, of course, and abstraction.  Processors
execute instructions out of order, due to pipelines and caches.  Compilers
reorder programs even more dramatically.  All of this reordering is meant to
be unobservable in single-threaded code.  In multi-threaded code, however,
all bets are off.  A formal attempt to understand the resulting mess is known
as a ``relaxed memory model.''  The relaxed memory models that have been
proposed to date either fail to address sequential composition, or overly
restrict processors and compilers.

To support sequential composition, we propose adding families of predicate
transformers to the existing model of ``Pomsets with Preconditions,'' which
already supports parallel composition.  When composing (S1;S2), the predicate
transformer used to validate the precondition of an event in S2 is chosen
based on the semantic dependencies from S1 into this event.  Our model
retains the good properties of the prior work, including efficient
implementation on Arm8, support for compiler optimizations, support for
logics that prove the absence of thin-air behaviors, and a local data race
freedom theorem.
