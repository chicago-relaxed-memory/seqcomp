%\subsection{\PwTmcaTITLE{2}: Pomsets with Predicate Transformers for MCA (Part 2)}
\subsection{\PwTmcaTITLE{2}}
\label{sec:mca2}

Lowering \PwTmca{1} to \armeight{} requires a full fence before every
acquiring read.\footnote{\citet{DBLP:journals/pacmpl/JagadeesanJR20}
  erroneously elide the required synchronization on acquiring reads.}  To see
why, consider the following attempted execution, where the final values of
both $x$ and $y$ are $2$.
\begin{gather*}
  \taglabel{internal-acq}
  \begin{gathered}
  \PW{x}{2}\SEMI 
  \PR[\mACQ]{x}{r}\SEMI
  \PW{y}{r{-}1} \PAR
  \PW{y}{2}\SEMI
  \PW[\mREL]{x}{1}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DW{x}{2}}{}
      \raevent{b}{\DR[\mACQ]{x}{2}}{right=of a}
      \event{c}{\DW{y}{1}}{right=of b}
      \event{d}{\DW{y}{2}}{right=2.5em of c}
      \raevent{e}{\DW[\mREL]{x}{1}}{right=of d}
      \rfint{a}{b}
      \sync{b}{c}
      \wk{c}{d}
      \sync{d}{e}
      \wk[out=-170,in=-10]{e}{a}
    \end{tikzinline}}
\end{gathered}
\end{gather*}
The execution is  allowed by \armeight, but disallowed by \PwTmca{1}, due to
the cycle.

\armeight{} allows the execution because the read of $x$ is internal to the
thread.  This aspect of \armeight{} semantics is difficult to model locally.
To capture this, we found it necessary to drop \ref{pom-rf-le} and relax
\ref{seq-le-delays}, %from
% \refdef{def:pwt:mca1},
adding local constraints on $\rrfx$ to $\sPAR{}{}$, $\sSEMI{}{}$ and
$\sIF{}{}{}$.
% Rather than ensuring that there is no
% \emph{global} blocker for a sequentially fulfilled read \eqref{pom-rf-le}, we
% require only that there is no \emph{thread-local} blocker
% \eqref{seq-le-delays-rf}.
% For \PwTmca{2}, internal reads don't necessarily contribute to order, and
% thus the above execution is allowed.
(For parallelism, we explicitly specify the domain of $\bEv$ and $\aEv$ in
\ref{seq-le-delays-rf}.)

\begin{definition}
  \label{def:pwt:mca2}
  The definition of \PwTmca{2} is derived from that of \PwTmca{1} by
  removing \ref{pom-rf-le} and \ref{seq-le-delays} and adding the following:

  \begin{enumerate}[topsep=0pt]
  \item[{\labeltext[\textsc{p}6a]{(\textsc{p}6a)}{par-le-rf1}}]
    if $\bEv\in\aEvs_1$, $\aEv\in\aEvs_2$ and $\bEv\xrfx\aEv$ then $\bEv\lt\aEv$,
  \item[{\labeltext[\textsc{p}6b]{(\textsc{p}6b)}{par-le-rf2}}]
    if $\bEv\in\aEvs_1$, $\aEv\in\aEvs_2$ and $\aEv\xrfx\bEv$ then $\aEv\lt\bEv$,
  \item[{\labeltext[\textsc{s}6a$'$]{(\textsc{s}6a$'$)}{seq-le-delays-rf}}]
    if $\bEv\in\aEvs_1$, $\aEv\in\aEvs_2$ and $\labeling_1(\bEv) \rdelays \labeling_2(\aEv)$ 
    then either $\bEv\xrfx\aEv$ or $\bEv\le\aEv$,
  % \item[{\labeltext[\textsc{s}6b]{(\textsc{s}6b)}{seq-le-rf-rf}}]
  %   if $\bEv\in\aEvs_1$, $\aEv\in\aEvs_2$ and $\labeling_1(\bEv) \rblocks \labeling_2(\aEv)$
  %   then $\cEv\xrfx\aEv$ implies $\bEv\le\cEv$.
    % \\
    % if $\labeling_1(\cEv) \rblocks \labeling_2(\aEv)$ and $\bEv\xrfx\aEv$
    % then $\cEv\le\bEv$.
  % \item[{\labeltext[\textsc{i}6a]{(\textsc{i}6a)}{if-le-rf}}]
  %   ${\rrfx}\subseteq {\rrfx_1}\cup {\rrfx_2}$
  \end{enumerate}
  % The definition of \PwTmca{2} is a \PwT{} (\refdef{def:pomset}) equipped with an injective
  % relation $\rrfx$ that satisfies requirements \ref{pom-rf-match} and
  % \ref{pom-rf-block} of \refdef{def:pwt:mca1}.

  % A \PwTmca{2} is \emph{complete} if it satisfies
  % \ref{top-kappa}, \ref{top-term}, and \ref{top-rf}---this is the same as for
  % \PwTmca{1}. 

  %\input{fig-mca2.tex}
\end{definition}
\ref{par-le-rf1} and \ref{par-le-rf2} ensure that $\bEv\xrfx\aEv$ implies
$\bEv\lt\aEv$ when the actions come from different threads.  However, we may
have $\bEv\xrfx\aEv$ and $\aEv\lt\bEv$ within a thread, as between
$\DWP{x}{2}$ to $\DRP[\mACQ]{x}{2}$ in \ref{internal-acq}, thus allowing this
execution.
% To accomplish this, \ref{seq-le-delays-rf} relaxes
% \ref{seq-le-delays} from \PwTmca{1}.
\ref {pom-rf-block} and \ref{seq-le-delays-rf} are sufficient to stop stale
reads within a thread.  For example, it prevents a read of $1$ in
\begin{math}
  \PW{x}{1}
  \SEMI
  \PW{x}{2}
  \SEMI
  \PR{x}{r}.
\end{math}


% 
% The use of $\rextendsdef{}{}$ in \ref{if-rf-project}
% ensures that no $\rrfx$ is introduced between events in
% $\aEvs_1\cap\aEvs_2$ when coalescing.

% In the second semantics, we weaken the relationship between $\rrfx$
% and $\le$ in \ref{pom-rf-le}.  
% This change both allows and requires us to weaken the definition of
% \emph{delays} to drop write-to-read order from $\eqreorderco$.


With the weakening of \ref{seq-le-delays}, we must be careful not to allow
spurious pairs to be added to the $\rrfx$ relation.  For example, %\ref{if-rf-project} ensures that
\begin{math}
  \frf{\semrr{\IF{b}\THEN\PR{x}{r}\PAR\PW{x}{1}\ELSE\PR{x}{r}\SEMI\PW{x}{1}\FI}}
\end{math}
should not include 
\begin{math}
  \smash{\hbox{\begin{tikzinlinesmall}[node distance=1.5em]
        \event{a}{\DR{x}{1}}{}
        \event{b}{\DW{x}{1}}{right=of a}
        \rfint[out=-165,in=-15]{b}{a}
        \wki[out=15,in=165]{a}{b}
      \end{tikzinlinesmall}}}
\end{math}, taking $\rrfx$ from the left and $\lt$ from the right.
The use of ``$\rextends{}{}$'' in \ref{if-le} and \ref{if-rf} ensures this.

% \PwTmca{2} does not enforce \ref{pom-rf-le}: $\bEv\xrfx\aEv$ may not imply
% $\bEv\le\aEv$ when $\bEv$ and $\aEv$ come from different sides of a
% sequential composition.  This means that
As a consequence of dropping \ref{pom-rf-le}, sequential $\rrfx$ must be validated during
pomset construction, rather than post-hoc.  In \textsection\ref{sec:c11}, we
show how to construct program order ($\rpox$) for complete pomsets using
phantom events ($\fmrg{}$).  Using this construction, the following lemma
gives a post-hoc verification technique for $\rrfx$.  Let $\fmrginv{}$ be the
inverse of $\fmrg{}$.
\begin{lemma}
  \label{lem:mca2}
  If $\aPS\in\frf{\semmca{2}{\aCmd}}$ is complete, then
  for every $\bEv\xrfx\aEv$ either
  \begin{itemize}
  \item external fulfillment:\;\,
    $\bEv\lt\aEv$ and if $\labeling(\cEv) \rblocks\labeling(\aEv)$ then either $\cEv\le\bEv$ or $\aEv\le\cEv$, or
  \item internal fulfillment:
    \begin{math}
      \begin{array}[t]{l}
        (\exists\bEv'\in\fmrginv{\bEv})
        (\exists\aEv'\in\fmrginv{\aEv})
        \\ 
        \bEv'\xpox\aEv' \textand (\not\exists\cEv)\;
        % \labelingForm(\cEv) is a tautology \textand
        \labeling(\cEv) \rblocks \labeling(\aEv) \textand
        \bEv'\xpox\cEv\xpox\aEv'.        
      \end{array}
    \end{math}
  \end{itemize}
\end{lemma}
These mimic the \emph{external consistency} requirements of \armeight{}
\cite{armed}.

% \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
  %   \setcounter{enumi}{\value{Brf}}
  % \item \label{pom-rf'} ${\rrfx} \subseteq \aEvs\times\aEvs$
  %   is an injective relation capturing \emph{reads-from}, such that
  %   % \end{enumerate}
  %   % A pomset is a \emph{candidate} if there is an injective relation
  %   % ${\rrfx} : \aEvs\times\aEvs$, capturing \emph{reads-from}, such that
  %   \begin{multicols}{2}    
  %     \begin{enumerate}
  %       % \begin{enumerate}[,label=(\textsc{i}\arabic*),ref=\textsc{i}\arabic*]
  %       % \item \label{rf-injective}
  %       %   if $\bEv\xrfx\aEv$ and $\cEv\xrfx\aEv$ then $\bEv=\cEv$, that is,
  %       %   ${\rrfx}$ is injective,
  %     \item[\eqref{pom-rf-match}]
  %       \eqref{pom-rf-block}\;
  %       as in \refdef{def:pwt:mca1},
  %       \setcounter{enumii}{2}
  %     \item \label{pom-rf-le'} 
  %       if $\bEv\xrfx\aEv$ then either $\bEv\le\aEv$ or $\aEv\le\bEv$.
  %     \end{enumerate}
  %   \end{multicols}
  % \end{enumerate}

% Derive $\rdelayspdef$ from $\rdelaysdef$ by replacing $\eqreorderco$ with
% \begin{math}
%   {\reorderlws}
%   =
%   \{(\DW{\aLoc}{}, \DW{\aLoc}{}),\;(\DR{\aLoc}{}, \DW{\aLoc}{})\}.
% \end{math}
% The acronym $\textsf{lws}$ is adopted from \armeight.  It stands for
% \emph{Local Write Successor}.

%The semantic rules are given in \reffig{fig:mca2}.
