\section{Limitations and Future Work}
\label{sec:outro}


This paper is the first to present a direct denotational semantics for
sequential composition that can be efficiently compiled to modern \CPU{}s.  We
defined two models: \PwTc{} solves the out-of-thin-air problem for \cXI, and
\PwTmca{} solves it for safe languages such as Java and Javascript.

Our work has several limitations, providing opportunities for future work:

\PwTc{} can be lowered efficiently to any architecture supported by \cXI{},
but inherits the top-level axioms of \rcXI{}, compromising compositionality.
\PwTmca{} is as a compositional as a model of concurrent imperative
programming can be, but is limited to \mca{} architectures for optimal
lowering.  It would be interesting to explore the middle ground to find a
fully compositional model that supports optimal lowering to all modern
architectures.

As mentioned in \textsection\ref{sec:related}, some safety guarantees may be
violated when read-introduction is followed by if-introduction, branching on
the read just introduced.  Nonetheless, read-introduction is ubiquitous in
some compilers \cite{DBLP:conf/pldi/LeeKSHDMRL17}.  It would be interesting
to know the cost of restricting this optimization.
%  
In a similar vein, \PwTmca{1} is a simpler model than \PwTmca{2}, but
requires fences on acquiring reads for \armeight{}.  It would be illuminating
to find out what the performance penalty is for these fences.

We have defined the soundness of compiler optimizations in the model, rather
than contextually: $\aCmd'$ is a sound refinement of $\aCmd$ if
$\sem{\aCmd'}\subseteq\sem{\aCmd}$.  This approach has several
advantages---for example, it is immediate that a sound optimization is sound
in any context.  It also has a disadvantage: some optimizations complicate
the semantics.  For example, \PwTmca{} does not validate access elimination,
such as store-forwarding and dead-write-removal---consider that complete
executions of
\begin{math}
  \sem{\PW{x}{1}\SEMI\PR{x}{r}}
\end{math}
must include a read action and that complete executions of
\begin{math}
  \sem{\PW{x}{1}\SEMI\PW{x}{2}}
\end{math}
must include two write actions.  As another example, \PwTmca{} does not
validate the reverse inclusions for
\reflem{lem:if}\ref{lem:ifelse:if:if}---consider that
\begin{math}
  \sem{\IF{r}
  \THEN \PW{x}{1}
  \ELSE \PW{x}{2}
  \FI}
\end{math}
has an augmented (\reflem{lem:augment}) execution with
\begin{math}
  (r{=}0\mid\DW{x}{2})
  \xwki
  (r{\neq}0\mid\DW{x}{1}),
\end{math}
whereas
\begin{math}
  \sem{
    \IF{r} \THEN \PW{x}{1}\FI
    \SEMI
    \IF{\BANG r} \THEN \PW{x}{2}\FI
  \FI}
\end{math}
has no such execution.  We expect that these optimizations can be validated,
at the cost of complicating the semantics.  For access elimination, it is
likely sufficient to allow events with different actions to merge.  For
\reflem{lem:if}\ref{lem:ifelse:if:if}, it is likely sufficient to encode
$\rdelay$ in the logic---the problem in the execution above is that $\rdelay$
introduces order even when the preconditions are disjoint.
%\todo{Comment on \PwTpo{} and \PwTc{}?}

We have not treated loops, although we expect that the usual approach of
showing continuity for all the semantic operations with respect to set
inclusion would go through. \citet{DBLP:conf/esop/PaviottiCPWOB20} use
step-indexing to account for loops; perhaps this approach could be adapted.

While we have mechanized some proofs, most of our proofs are informal.
In particular, we have only a pen-and-paper proof showing that \PwTmca{}
supports optimal lowering to \armeight{}.  The same is true for local data
race-freedom (\ldrfsc{})---additionally, our proof sketch for \ldrfsc{}
elides \RMW{}s, which have caused complications in other models
\cite{promising-ldrf}.





% In a similar vein, \PwT{} does not validate read-introduction, whereas
% speculative operational semantics do.  Recent work shows a tension between
% read-introduction and compositional reasoning for temporal safety properties
% (see \textsection\ref{sec:related}).  Nonetheless, read introduction is
% ubiquitous in some compilers.  It would be interesting to know if there is a
% performance penalty for banning read-introduction.

% An earlier version of this paper has been mechanized in Agda; it would be
% reassuring to update the mechanization to bring it in line with the current state.


% We have presented the first model of relaxed memory that treats sequential
% composition as a first-class citizen. The model builds directly on \jjr{}.

% For sequential composition, parallel composition and the conditional, we
% believe that the definition is \emph{natural}, even \emph{canonical}.
% For stores and loads, instead, the definition in \reffig{fig:no-addr} is a
% Frankenstein's monster of features.  This complexity is \emph{essential},
% however, not just an accident of our poor choices.  Relaxed memory models must
% please many audiences: compiler writers want one thing, hardware designers
% another, and programmers yet another still.  The result is inevitably full of
% compromise.

% Given that \emph{complexity} cannot be eliminated from relaxed memory models,
% the best one can do is attempt to understand its causes.  We have broken the
% problem into seven manageable pieces, discussed throughout
% \textsection\ref{sec:q}--\ref{sec:complications}.  \refdef{def:pomsets-arm}
% summarizes all the features necessary for efficient implementation on
% \armeight{}.  We discuss address calculation, read-modify-write operations
% and fences in the appendix.

% {Logic} is the thread that sews these features together.

% %A unique feature of our model is the centrality of logic: 

% % study each feature in isolation, as a small delta to the base definition
% % given in \textsection\ref{sec:model}.
% % In we studied eight such
% % features.


% % seem staggeringly complex, we argue that this complexity is unavoidable if
% % one wants all the features that it embodies.  By breaking the definition into
% % its constituent parts, we have shown how each of eight

Supplementary material for this paper is available at
\url{https://weakmemory.github.io/pwt}.

\subsection*{Acknowledgements}
This paper has been greatly improved by the comments of the anonymous reviewers.
%
James Riely was supported by the National Science Foundation under
grant No.~CCR-1617175.
%
Mark Batty and Simon Cooksey were supported by the EPSRC under grant
Nos.~EP/V000470/1 and~EP/R032971/1, and by VeTSS.
%
Anton Podkopaev was supported by JetBrains Research.

% % It is based upon work supported by the National Science Foundation under
% % Grant No. CCR-1617175. Any opinions, findings, and conclusions or
% % recommendations expressed in this material are those of the author and do
% % not necessarily reflect the views of the NSF.}

