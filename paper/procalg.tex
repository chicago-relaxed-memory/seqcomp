\section{Process Algebra}

We begin with a warm-up exercise, presenting the key ideas of the
model in the simplified setting of a process algebra.

Process algebras were developed as a simple model of message-passing
concurrency~\cite{CCS,CSP,ACP} and have been given many different
semantics, notably traces~\cite{???}, labelled transition
systems~\cite{???}, equational~\cite{???}, and event
structures~\cite{???}.  In this section, we recap the \emph{pomset}
semantics, and show how it can be used to model a simple process
language based on the asynchronous $\pi$-calculus~\cite{???} and
value-passing CCS~\cite{???}.

The key idea of this paper is a relaxed treatment of sequential
composition, where causality is not given by program order, but
instead is given by control and data dependencies.

\subsection{Pomsets}

\begin{definition}
  A \emph{pomset} with alphabet $\Alphabet$ is a tuple
  $(\Event, {\le}, \labeling)$ where
  \begin{enumerate}
  \item $\Event$ is a set of \emph{events}
  \item
    ${\le} \subseteq (\Event\times\Event)$ is the \emph{causality} partial order, and
  \item
    $\labeling: \Event \fun \Alphabet$ is a \emph{labeling}.
  \end{enumerate}
\end{definition}

\begin{figure*}
  If $\aPS_0\in\sSTOP$ then:
  \begin{enumerate}
    \item $\aEvs_0 = \emptyset$.
  \end{enumerate}
  If $\aPS_0 \in (\aPSS_1\wPAR\aPSS_2)$ then
  there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that:
  \begin{enumerate}
  \item $\aEvs_0 = (\aEvs_1\cup\aEvs_2)$,
  \item if $\aEv\in\aEvs_1$ then $\labeling_0(\aEv) = \labeling_1(\aEv)$, 
  \item if $\aEv\in\aEvs_2$ then $\labeling_0(\aEv) = \labeling_2(\aEv)$,
  \item if $\bEv\le_1\aEv$ then $\bEv\le_0\aEv$, and
  \item if $\bEv\le_2\aEv$ then $\bEv\le_0\aEv$.
    \newcounter{pomsetParCount}
    \setcounter{pomsetParCount}{\value{enumi}}
  \end{enumerate}
  If $\aPS_0 \in (\aPSS_1\sPAR\aPSS_2)$ then
  there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that:
  \begin{enumerate}
        \setcounter{enumi}{\value{pomsetParCount}}
  \item[1--\thepomsetParCount)] as above, and
  \item $\aEvs_1$ and $\aEvs_2$ are disjoint.
  \end{enumerate}
  If $\aPS_0 \in (\aAct\wPREFIX\aPSS)$ then there is $\aPS_2\in\aPSS$ such that:
  \begin{enumerate}
  \item $\aEvs_0=(\aEvs_1 \cup \aEvs_2)$,
  \item if $\aEv\in\aEvs_1$ then $\labelingAct_0(\aEv) = \aAct$,
  \item if $\aEv\in\aEvs_2$ then $\labelingAct_0(\aEv) = \labelingAct_2(\aEv)$,
  \item if $\bEv,\aEv\in\aEvs_1$ then $\bEv=\aEv$,
  \item if $\bEv\le_2\aEv$ then $\bEv\le_0\aEv$, and
    \newcounter{pomsetPrefixCount}
    \setcounter{pomsetPrefixCount}{\value{enumi}}
  \item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$, either $\bEv<_0\aEv$ or $a\reorder\labeling_2(\aEv)$.
  \end{enumerate}
\caption{Process algebra as sets of pomsets}
\label{tab:pomsets},
\end{figure*}

[No communication between threads, but this can be added as a condition on pomsets,
  for instance a simple model where every receive event has a matching send.]

[Introduce ``blocker'', and ``fulfillment'' on $\Alphabet$, and lift up to events.]

For example, for latches:
\begin{itemize}
\item $\set{\aChan}{}$ fulfills $\get{\aChan}{}$, and
\item there are no blockers.
\end{itemize}
for condition variables:
\begin{itemize}
\item $\notify{\aChan}{}$ fulfills $\notified{\aChan}{}$, and
\item $\wait{\aChan}{}$ blocks $\notified{\aChan}{}$.
\end{itemize}
for mutexes:
\begin{itemize}
\item $\init{\aChan}$ and $\release{\aChan}$ fulfil $\acquire{\aChan}{}$,
\item $\acquire{\aChan}$ fulfills $\release{\aChan}$, and
\item $\acquire{\aChan}$ and $\release{\aChan}$ block each other and themselves. 
\end{itemize}
  
\begin{definition}
  A pomset $\aPS$ is closed if
  for every $\aEv$ which can be fulfilled,
  there is a $\bEv\le\aEv$ which fulfills it,
  and for any $\cEv$ which can block $\aEv$, either $\cEv\le\bEv$ or $\aEv\le\cEv$. 
\end{definition}

[Do some process algebra examples.]

[Use refinement (that is subset order) as notion of compiler optimization.]

For some examples, we want to allow reorderings:
\[
  (\aAct \wPREFIX \bAct \wPREFIX \aPS)
\subseteq
  (\bAct \wPREFIX \aAct \wPREFIX \aPS)
\]
or mumbling:
\[
  (\aAct \wPREFIX \aAct \wPREFIX \aPS)
\subseteq
  (\aAct \wPREFIX \aPS)
\]
[Talk about Mazurkiewicz traces.]

[Introduce $\aAct\reorder\bAct$ for when reordering is valid,
  and  $\aAct\reorder\aAct$ for when mumbling is valid.]

[Give examples: latches support mumbling, mutexes support roach motel reorderings.]

\subsection{Pomsets with preconditions}

This is essentially the model of \cite{10.1145/3428262}.

\begin{definition}
  A \emph{pomset with preconditions} is
  a pomset together with $\labelingForm:\aEvs\fun\Formulae$.
\end{definition}

\begin{figure*}
  If $\aPS_0\in\sSTOP$ then:
  \begin{enumerate}
    \item $\aEvs_0 = \emptyset$.
  \end{enumerate}
  If $\aPS_0 \in (\aPSS_1\wPAR\aPSS_2)$ then
  there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that:
  \begin{enumerate}
     \setcounter{enumi}{\value{pomsetParCount}}
  \item[1--\thepomsetParCount)] as in Table~\ref{tab:pomsets},
  \item if $\aEv\in\aEvs_1$ then $\labelingForm_0(\aEv)$ implies $\labelingForm_1(\aEv)$, and
  \item if $\aEv\in\aEvs_2$ then $\labelingForm_0(\aEv)$ implies $\labelingForm_2(\aEv)$.
    \newcounter{pomsetPreParCount}
    \setcounter{pomsetPreParCount}{\value{enumi}}
  \end{enumerate}
  If $\aPS_0 \in (\aPSS_1\sPAR\aPSS_2)$ then
  there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that:
  \begin{enumerate}
  \setcounter{enumi}{\value{pomsetPreParCount}}
  \item[1--\thepomsetPreParCount)] as above, and
  \item $\aEvs_1$ and $\aEvs_2$ are disjoint.
  \end{enumerate}
  If $\aPS_0 \in (\aAct\wPREFIX\aPSS[\vec\aVal/\vec\aVar])$ then there is $\aPS_2\in\aPSS$ such that:
  \begin{enumerate}
     \setcounter{enumi}{\value{pomsetPrefixCount}}
  \item[1--\thepomsetPrefixCount)] as in Table~\ref{tab:pomsets},
  \item if $\aEv\in\aEvs_1$ then $\labelingForm_0(\aEv)$ implies $\preForm_\aAct$,
  \item if $\aEv\in\aEvs_2$ then $\labelingForm_0(\aEv)$ implies $\labelingForm_2(\aEv)[\vec\aVal/\vec\aVar]$,
  \item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ then either $\bEv<_0\aEv$ or 
    $\labelingForm_0(\aEv)$ implies $\reorderIndForm_\aAct$ and $\forall\vec\aVar\DOT\labelingForm_2(\aEv)$.
  \end{enumerate}
  If $\aPS_0 \in (\aForm\sGUARD\aPSS)$ then there is $\aPS_1\in\aPS$ such that:
  \begin{enumerate}
  \item $\aEvs_0 = \aEvs_1$,
  \item $\labelingAct_0(\aEv) = \labelingAct_1(\aEv)$,
  \item $\labelingForm_0(\aEv)$ implies $\aForm$ and  $\labelingForm_1(\aEv)$, and
  \item if $\bEv\le_1\aEv$ then $\bEv\le_0\aEv$.
    \newcounter{pomsetPreGuardCount}
    \setcounter{pomsetPreGuardCount}{\value{enumi}}
  \end{enumerate}
\caption{Process algebra as sets of pomsets with preconditions}
\end{figure*}

[Introduce data models, with formulae.]

Example of value-passing on unordered channels which allow
message duplication:
\begin{eqnarray*}
  \sSEND\aChan\aExp\wPREFIX\aPSS & = &
  \bigcup_\aVal (\aExp=\aVal) \sGUARD \send\aChan{\aVal} \wPREFIX \aPSS
\\
  \sRECV\aChan\aVar\wPREFIX\aPSS & = &
  \bigcup_\aVal \recv\aChan{\aVal} \wPREFIX \aPSS[\aVal/\aVar]
\end{eqnarray*}

Unfortunately we can't play the same trick with reordering based on
label, since the label doesn't track control or data dependencies. But
we can code up reorderings in the logic. Assume formulae
$\preForm_\aAct$ (the precondition for $\aAct$) and
$\reorderIndForm_\aAct$ (the precondition for events which can be reordered with $\aAct$).

For example, we introduce a new uninterpreted formula $\quietForm$
and have for relaxed $\aAct$:
\[
  \preForm_{\aAct} = \neg\quietForm
\qquad
  \reorderIndForm_{\aAct} = \neg\quietForm
\]
for release $\aAct$:
\[
  \preForm_{\aAct} = \quietForm
\qquad
  \reorderIndForm_{\aAct} = \neg\quietForm
\]
and for acquire $\aAct$:
\[
  \preForm_{\aAct} = \neg\quietForm
\qquad
  \reorderIndForm_{\aAct} = \FALSE
\]

[Stuff about conditionals and merging events.]

\subsection{A pomset with preconditions and predicate transformers model of Value-passing Asynchronus CCS}

[The problem with the previous section is that there's no story for sequential composition.]

\begin{definition}
  A \emph{predicate transformer} is a monotone function
  $\aTr:\Formulae\fun\Formulae$ such that
  $\aTr(\FALSE)$ is $\FALSE$,
  $\aTr(\aForm\land\bForm)$ is $\aTr(\aForm)\land\aTr(\bForm)$, and
  $\aTr(\aForm\lor\bForm)$ is $\aTr(\aForm)\lor\aTr(\bForm)$.
\end{definition}

\begin{definition}
  A pomset with one predicate tansformer is a possibly incomplete
  pomset with preconditions, together with a predicate transformer $\aTr$.
\end{definition}

\begin{definition}
  If $\aPS_0 \in (\aPSS_1\sSEMI\aPSS_2)$ then
  there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ where:
  \begin{enumerate}
  \item $\aEvs_0 = (\aEvs_1\cup\aEvs_2)$,
  \item $\aEvs_1$ and  $\aEvs_2$ are disjoint,
  \item if $\aEv\in\aEvs_1$ then $\labelingAct_0(\aEv) = \labelingAct_1(\aEv)$, 
  \item if $\aEv\in\aEvs_2$ then $\labelingAct_0(\aEv) = \labelingAct_2(\aEv)$,
  \item if $\aEv\in\aEvs_1$ then $\labelingForm_0(\aEv)$ implies $\labelingForm_1(\aEv)$, 
  \item if $\aEv\in\aEvs_2$ then $\labelingForm_0(\aEv)$ implies $\aTr_1(\labelingForm_2(\aEv))$,
  \item if $\bEv\le_1\aEv$ then $\bEv\le_0\aEv$,
  \item if $\bEv\le_2\aEv$ then $\bEv\le_0\aEv$, and
  \item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ then $\bEv\le_0\aEv$.
  \end{enumerate}
\end{definition}

\begin{definition}
  If $\aPS_0 \in (\aForm\sGUARD\aPSS_1)$ then:
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPreGuardCount}}
  \item[1--\thepomsetPreGuardCount)] As in Definition~\ref{defn:pomset-guard},
  \item $\aForm\land\aTr_0(\aForm)$ implies $\aTr_1(\aForm)$.
  \end{enumerate}
\end{definition}

\begin{definition}
  If $\aPS_0 \in \sSEND\aChan{\aExp}$ then:
  \begin{enumerate}
  \item if $\bEv\in\aEvs_0$ and $\aEv\in\aEvs_0$ then $\bEv=\aEv$,
  \item if $\aEv\in\aEvs_0$ then $\labelingAct_0(\aEv) = \send\aChan{\aVal}$,
  \item if $\aEv\in\aEvs_0$ then $\labelingForm_0(\aEv) = (M = v)$, and
  \item $\aTr_0(\aForm)$ implies $\aForm$.
  \end{enumerate}
\end{definition}

\begin{definition}
  If $\aPS_0 \in \sRECV\aChan{\aVar}$ then:
  \begin{enumerate}
  \item if $\bEv\in\aEvs_0$ and $\aEv\in\aEvs_0$ then $\bEv=\aEv$,
  \item if $\aEv\in\aEvs_0$ then $\labeling_0(\aEv) = \recv\aChan{\aVal}$,
  \item $\aTr_0(\aForm)$ implies $\phi[\aVal/\aVar]$, and
  \item if $\aEvs_0=\emptyset$ then $\aTr_0(\aForm)$ implies $\phi[\bVal/\aVar]$ for any $\bVal$.
  \end{enumerate}
\end{definition}

\subsection{A pomset with preconditions and predicate transformers model of Value-passing Relaxed CCS}

[Introduce relaxed channels, call other channels release/acquire channels, lift relaxed/ra up to actions and events.]

\begin{definition}
  A \emph{family of predicate transformers}
  indexed by subsets of $\aEvs$
  consists of predicate transformers
  $\aTr[\bEvs]$ for each set of events $\bEvs$,
  such that if $(\cEvs\cap\aEvs) \subseteq \bEvs$
  then $\aTr[\cEvs](\aForm)$ implies $\aTr[\bEvs](\aForm)$.
\end{definition}

\begin{definition}
  A pomset with predicate tansformers is a possibly incomplete
  pomset with preconditions, together with a family of predicate transformers $\aTr$
  indexed by subsets of $\aEvs$.
\end{definition}

\begin{definition}
  If $\aPS_0 \in (\aPSS_1\sSEMI\aPSS_2)$ then
  there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ where:
  \begin{enumerate}
  \item $\aEvs_0 = (\aEvs_1\cup\aEvs_2)$,
  \item $\aEvs_1$ and  $\aEvs_2$ are disjoint,
  \item if $\aEv\in\aEvs_1$ then $\labelingAct_0(\aEv) = \labelingAct_1(\aEv)$, 
  \item if $\aEv\in\aEvs_2$ then $\labelingAct_0(\aEv) = \labelingAct_2(\aEv)$,
  \item if $\aEv\in\aEvs_1$ then $\labelingForm_0(\aEv)$ implies $\labelingForm_1(\aEv)$, 
  \item if $\aEv\in\aEvs_2$ then $\labelingForm_0(\aEv)$ implies $\aTr[\downclose_0(e)]_1(\labelingForm_2(\aEv))$,
  \item if $\bEv\le_1\aEv$ then $\bEv\le_0\aEv$, and
  \item if $\bEv\le_2\aEv$ then $\bEv\le_0\aEv$.
  \end{enumerate}
\end{definition}

\begin{definition}
  If $\aPS_0 \in \sSEND\aChan{\aExp}$ then:
  \begin{enumerate}
  \item if $\bEv\in\aEvs_0$ and $\aEv\in\aEvs_0$ then $\bEv=\aEv$,
  \item if $\aEv\in\aEvs_0$ then $\labelingAct_0(\aEv) = \send\aChan{\aVal}$,
  \item if $\aEv\in\aEvs_0$ then $\labelingForm_0(\aEv) = (M = v)$, and
  \item $\aTr[\bEvs]_0(\aForm)$ implies $\aForm$.
  \end{enumerate}
\end{definition}

\begin{definition}
  If $\aPS_0 \in \sRECV\aChan{\aVar}$ then:
  \begin{enumerate}
  \item if $\bEv\in\aEvs_0$ and $\aEv\in\aEvs_0$ then $\bEv=\aEv$,
  \item if $\aEv\in\aEvs_0$ then $\labeling_0(\aEv) = \recv\aChan{\aVal}$,
  \item $\aTr[\bEvs]_0(\aForm)$ implies $\phi[\aVal/\aVar]$, and
  \item $\aTr[\emptyset]_0(\aForm)$ implies $\phi[\bVal/\aVar]$ for any $\bVal$.
  \end{enumerate}
\end{definition}
