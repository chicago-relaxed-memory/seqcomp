\section{Process Algebra}

We begin with a warm-up exercise, presenting the key ideas of the
model in the simplified setting of a process algebra.

Process algebras were developed as a simple model of message-passing
concurrency~\cite{CCS,CSP,ACP} and have been given many different
semantics, notably traces~\cite{???}, labelled transition
systems~\cite{???}, equational~\cite{???}, and event
structures~\cite{???}.  In this section, we recap the \emph{pomset}
semantics, and show how it can be used to model a simple process
language based on the asynchronous $\pi$-calculus~\cite{???} and
value-passing CCS~\cite{???}.

The key idea of this paper is a relaxed treatment of sequential
composition, where causality is not given by program order, but
instead is given by control and data dependencies.

\subsection{Pomsets}

\begin{definition}
  A \emph{pomset} with alphabet $\Alphabet$ is a tuple
  $(\Event, {\le}, \labeling)$ where
  \begin{enumerate}
  \item $\Event$ is a set of \emph{events}
  \item
    ${\le} \subseteq (\Event\times\Event)$ is the \emph{causality} partial order, and
  \item
    $\labeling: \Event \fun \Alphabet$ is a \emph{labeling}.
  \end{enumerate}
\end{definition}

\begin{figure*}
  If $\aPS_0\in\sSTOP$ then:
  \begin{enumerate}
    \item $\aEvs_0 = \emptyset$.
  \end{enumerate}
  If $\aPS_0 \in (\aPSS_1\sPAR\aPSS_2)$ then
  there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that:
  \begin{enumerate}
  \item $\aEvs_0 = (\aEvs_1\cup\aEvs_2)$,
  \item if $\aEv\in\aEvs_1$ then $\labeling_0(\aEv) = \labeling_1(\aEv)$, 
  \item if $\aEv\in\aEvs_2$ then $\labeling_0(\aEv) = \labeling_2(\aEv)$,
  \item if $\bEv\le_1\aEv$ then $\bEv\le_0\aEv$, and
  \item if $\bEv\le_2\aEv$ then $\bEv\le_0\aEv$.
    \newcounter{pomsetParCount}
    \setcounter{pomsetParCount}{\value{enumi}}
  \end{enumerate}
  If $\aPS_0 \in (\aAct\wPREFIX\aPSS)$ then there is $\aPS_2\in\aPSS$ such that: [reword using if...then]
  \begin{enumerate}
  \item $\aEvs_0=(\aEvs_1 \cup \aEvs_2)$,
  \item for any $\aEv\in\aEvs_1$, $\labelingAct_0(\aEv) = \aAct$,
  \item for any $\aEv\in\aEvs_2$, $\labelingAct_0(\aEv) = \labelingAct_2(\aEv)$,
  \item for any $\bEv,\aEv\in\aEvs_1$, $\bEv=\aEv$,
  \item for any $\bEv\le_2\aEv$, $\bEv\le_0\aEv$, and
  \item for any $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$, either $\bEv<_0\aEv$ or $a\reorder\labeling_2(\aEv)$.
    \newcounter{pomsetPrefixCount}
    \setcounter{pomsetPrefixCount}{\value{enumi}}
  \end{enumerate}
\caption{Process algebra as sets of pomsets}
\end{figure*}

[No communication between threads, but this can be added as a condition on pomsets,
  for instance a simple model where every receive event has a matching send.]

[Introduce ``blocker'', and ``fulfillment'' on $\Alphabet$, and lift up to events.]

For example, for latches:
\begin{itemize}
\item $\send{\aChan}{}$ fulfills $\recv{\aChan}{}$, and
\item there are no blockers.
\end{itemize}
for condition variables
\begin{itemize}
\item $\notify{\aChan}{}$ fulfills $\notified{\aChan}{}$, and
\item there are no blockers.
\end{itemize}
  
\begin{definition}
  A pomset $\aPS$ is closed if
  for every $\aEv$ which can be fulfilled,
  there is a $\bEv\le\aEv$ which fulfills it,
  and for any $\cEv$ which can block $\aEv$, either $\cEv\le\bEv$ or $\aEv\le\cEv$. 
\end{definition}

[Do some process algebra examples.]

[Use refinement (that is subset order) as notion of compiler optimization.]

The definition of prefixing may be too strong for some applications, for example
reordering of actions is never allowed:
\[
  (\recv\aChan{} \sPREFIX \recv\bChan{} \sPREFIX \aPSS)
\not\subseteq
  (\recv\bChan{} \sPREFIX \recv\aChan{} \sPREFIX \aPSS)
\]
We can weaken prefixing to allow these reorderings,
writing $\aAct\reorder\bAct$ when $\aAct$ and $\bAct$ can be reordered.

[Talk about Mazurkiewicz traces.]

\begin{definition}
  \label{defn:pomset-wprefix}
  If $\aPS_0 \in (\aAct\wPREFIX\aPSS_1)$ then there is $\aPS_1\in\aPS$ such that either:
  \begin{enumerate}
  \item $\aPSS_0=\aPSS_1$, and
  \item for any $\aEv\in\aEvs_1$, $\aAct\reorder\labelingAct_1(\aEv)$.
  \end{enumerate}
  or:
  \begin{enumerate}
  \item $\aEvs_0=\{\cEv\} \cup \aEvs_1$,
  \item $\labelingAct_0(\cEv) = \aAct$,
  \item for any $\aEv\in\aEvs_1$, $\labelingAct_0(\aEv) = \labelingAct_1(\aEv)$,
  \item for any $\aEv\in\aEvs_1$, either $\aAct\reorder\labelingAct_1(\aEv)$ or $\cEv<_0\aEv$, and
  \item for any $\bEv\le_1\aEv$, $\bEv\le_0\aEv$.
  \end{enumerate}
\end{definition}

As an example, devide channels into \emph{relaxed} and \emph{release/acquire}
channels, and allow the reorderings:
\[\begin{array}{cl}
  \send{\aChan}{} \reorder \recv{\bChan}{} \\
  \recv{\aChan}{} \reorder \recv{\bChan}{} & \mbox{when $\aChan$ is relaxed} \\
  \send{\aChan}{} \reorder \send{\bChan}{} & \mbox{when $\bChan$ is relaxed} \\
  \recv{\aChan}{} \reorder \send{\bChan}{} & \mbox{when both $\aChan$ and $\bChan$ are relaxed}
\end{array}\]
  
\subsection{Pomsets with preconditions}

This is essentially the model of \cite{10.1145/3428262}.

\begin{definition}
  A \emph{pomset with preconditions} is
  a pomset together with $\labelingForm:\aEvs\fun\Formulae$.
\end{definition}

[Introduce data models, with formulae.]

We can lift definitions~\ref{defn:pomset-par}--\ref{defn:pomset-prefix} to pomsets with preconditions in
the obvious way.

\begin{definition}
  \label{defn:pomset-pre-par}
  If $\aPS_0 \in (\aPSS_1\sPAR\aPSS_2)$ then
  there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ where:
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[1--\thepomsetParCount)] As in Definition~\ref{defn:pomset-par},
  \item if $\aEv\in\aEvs_1$ then $\labelingForm_0(\aEv)$ implies $\labelingForm_1(\aEv)$, and
  \item if $\aEv\in\aEvs_2$ then $\labelingForm_0(\aEv)$ implies $\labelingForm_2(\aEv)$.
  \end{enumerate}
\end{definition}

\begin{definition}
  \label{defn:pomset-pre-prefix}
  If $\aPS_0 \in \aAct\sPREFIX\aPSS_1$ then
  either $\aEvs=\emptyset$ or there is $\aPS_1\in\aPS$ such that:
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPrefixCount}}
  \item[1--\thepomsetPrefixCount)] As in Definition~\ref{defn:pomset-prefix}, and
  \item if $\aEv\in\aEvs_1$ then $\labelingForm_0(\aEv)$ implies $\labelingForm_1(\aEv)$.
  \end{enumerate}
\end{definition}

The set of pomsets $\aForm\sGUARD\aPSS_1$ represents a guarded execution of $\aPSS_1$ whenever $\aForm$ is satisfied.
\begin{definition}
  \label{defn:pomset-guard}
  If $\aPS_0 \in (\aForm\sGUARD\aPSS_1)$ then there is $\aPS_1\in\aPS$ such that:
  \begin{enumerate}
  \item $\aEvs_0 = \aEvs_1$,
  \item $\labelingAct_0(\aEv) = \labelingAct_1(\aEv)$,
  \item $\labelingForm_0(\aEv)$ implies $\aForm$,
  \item $\labelingForm_0(\aEv)$ implies $\labelingForm_1(\aEv)$, and
  \item if $\bEv\le_1\aEv$ then $\bEv\le_0\aEv$.
    \newcounter{pomsetGuardCount}
    \setcounter{pomsetGuardCount}{\value{enumi}}
  \end{enumerate}
\end{definition}

The set of pomsets $\aPSS_1[\aExp/\aVar]$ represents an execution from $\aPSS_1$ with a substitution
applied to every precondition.
\begin{definition}
  \label{defn:pomset-subst}
  If $\aPS_0 \in \aPSS_1[\aExp/\aVar]$ then there is $\aPS_1\in\aPS$ such that:
  \begin{enumerate}
  \item $\aEvs_0 = \aEvs_1$,
  \item $\labelingAct_0(\aEv) = \labelingAct_1(\aEv)$,
  \item $\labelingForm_0(\aEv)$ implies $\labelingForm_1(\aEv)[\aExp/\aVar]$, and
  \item if $\bEv\le_1\aEv$ then $\bEv\le_0\aEv$.
  \end{enumerate}
\end{definition}

Example of value-passing on unordered channels which allow
message duplication:
\begin{eqnarray*}
  \sSEND\aChan\aExp\sPREFIX\aPSS & = &
  \bigcup_\aVal (\aExp=\aVal) \sGUARD \send\aChan{\aVal} \sPREFIX \aPSS
\\
  \sRECV\aChan\aVar\sPREFIX\aPSS & = &
  \bigcup_\aVal \recv\aChan{\aVal} \sPREFIX \aPSS[\aVal/\aVar]
\end{eqnarray*}

Unfortunately we can't play the same trick with reordering based on
label, since the label doesn't track control or data dependencies. But
we can code up reorderings in the logic, Assume formulae
$\preForm_\aAct$ (the precondition for $\aAct$)
$\reorderDepForm_\aAct$ (applied to events which may be reordered with
an $\aAct$ even if there's control or data depemdencies) and
$\reorderIndForm_\aAct$ (applied to events which may be reordered with
an $\aAct$ unless there's control or data depemdencies).

For example, we introduce a new uninterpreted formula $\quietForm$
and have for relaxed $\aAct$:
\[
  \preForm_{\aAct} = \TRUE
\qquad
  \reorderIndForm_{\aAct} = \neg\quietForm
\qquad
  \reorderDepForm_{\aAct} = \FALSE
\]
for release $\aAct$:
\[
  \preForm_{\aAct} = \quietForm
\qquad
  \reorderIndForm_{\aAct} = \neg\quietForm
\qquad
  \reorderDepForm_{\aAct} = \FALSE
\]
and for acquire $\aAct$:
\[
  \preForm_{\aAct} = \TRUE
\qquad
  \reorderIndForm_{\aAct} = \FALSE
\qquad
  \reorderDepForm_{\aAct} = \FALSE
\]

\begin{definition}
  \label{defn:pomset-wprefix}
  If $\aPS_0 \in (\aAct\wPREFIX\aPSS[\vec\aVal/\vec\aVar])$ then there is $\aPS_2\in\aPSS$ such that:
  \begin{enumerate}
  \item $\aEvs_0=\aEvs_1 \cup \aEvs_2$,
  \item for any $\aEv\in\aEvs_1$, $\labelingAct_0(\aEv) = \aAct$,
  \item for any $\aEv\in\aEvs_2$, $\labelingAct_0(\aEv) = \labelingAct_2(\aEv)$,
  \item for any $\aEv\in\aEvs_1$, $\labelingForm_0(\aEv)$ implies $\preForm_\aAct$,
  \item for any $\aEv\in\aEvs_2$, $\labelingForm_0(\aEv)$ implies $\labelingForm_2(\aEv)[\vec\aVal/\vec\aVar]$,
  \item for any $\bEv,\aEv\in\aEvs_1$, $\bEv\le_0\aEv$.
  \item for any $\bEv\le_2\aEv$, $\bEv\le_0\aEv$.
  \item for any $\bEv\in\aEvs_1$ and $\bEv\in\aEvs_2$, either
    \begin{enumerate}
    \item $\bEv\le_0\aEv$,
    \item $\labelingForm_0(\aEv)$ implies $\reorderDepForm_\aAct$, or
    \item $\labelingForm_0(\aEv)$ implies $\reorderIndForm_\aAct\land\forall\vec\aVar\DOT\labelingForm_2(\aEv)$.
    \end{enumerate}
  \end{enumerate}
\end{definition}

This is enough to model a relaxed value-passing process language:

\begin{eqnarray*}
  \sSEND\aChan\aExp\wPREFIX\aPSS & = &
  \bigcup_\aVal (\aExp=\aVal) \sGUARD \send\aChan{\aVal} \wPREFIX \aPSS
\\
  \sRECV\aChan\aVar\wPREFIX\aPSS & = &
  \bigcup_\aVal \recv\aChan{\aVal} \wPREFIX \aPSS[\aVal/\aVar]
\end{eqnarray*}

[Stuff about conditionals and merging events.]

\subsection{A pomset with preconditions and predicate transformers model of Value-passing Asynchronus CCS}

[The problem with the previous section is that there's no story for sequential composition.]

\begin{definition}
  A \emph{predicate transformer} is a monotone function
  $\aTr:\Formulae\fun\Formulae$ such that
  $\aTr(\FALSE)$ is $\FALSE$,
  $\aTr(\aForm\land\bForm)$ is $\aTr(\aForm)\land\aTr(\bForm)$, and
  $\aTr(\aForm\lor\bForm)$ is $\aTr(\aForm)\lor\aTr(\bForm)$.
\end{definition}

\begin{definition}
  A pomset with one predicate tansformer is a possibly incomplete
  pomset with preconditions, together with a predicate transformer $\aTr$.
\end{definition}

\begin{definition}
  If $\aPS_0 \in (\aPSS_1\sSEMI\aPSS_2)$ then
  there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ where:
  \begin{enumerate}
  \item $\aEvs_0 = (\aEvs_1\cup\aEvs_2)$,
  \item $\aEvs_1$ and  $\aEvs_2$ are disjoint,
  \item if $\aEv\in\aEvs_1$ then $\labelingAct_0(\aEv) = \labelingAct_1(\aEv)$, 
  \item if $\aEv\in\aEvs_2$ then $\labelingAct_0(\aEv) = \labelingAct_2(\aEv)$,
  \item if $\aEv\in\aEvs_1$ then $\labelingForm_0(\aEv)$ implies $\labelingForm_1(\aEv)$, 
  \item if $\aEv\in\aEvs_2$ then $\labelingForm_0(\aEv)$ implies $\aTr_1(\labelingForm_2(\aEv))$,
  \item if $\bEv\le_1\aEv$ then $\bEv\le_0\aEv$,
  \item if $\bEv\le_2\aEv$ then $\bEv\le_0\aEv$, and
  \item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ then $\bEv\le_0\aEv$.
  \end{enumerate}
\end{definition}

\begin{definition}
  If $\aPS_0 \in (\aForm\sGUARD\aPSS_1)$ then:
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetGuardCount}}
  \item[1--\thepomsetGuardCount)] As in Definition~\ref{defn:pomset-guard},
  \item $\aForm\land\aTr_0(\aForm)$ implies $\aTr_1(\aForm)$.
  \end{enumerate}
\end{definition}

\begin{definition}
  If $\aPS_0 \in \sSEND\aChan{\aExp}$ then:
  \begin{enumerate}
  \item if $\bEv\in\aEvs_0$ and $\aEv\in\aEvs_0$ then $\bEv=\aEv$,
  \item if $\aEv\in\aEvs_0$ then $\labelingAct_0(\aEv) = \send\aChan{\aVal}$,
  \item if $\aEv\in\aEvs_0$ then $\labelingForm_0(\aEv) = (M = v)$, and
  \item $\aTr_0(\aForm)$ implies $\aForm$.
  \end{enumerate}
\end{definition}

\begin{definition}
  If $\aPS_0 \in \sRECV\aChan{\aVar}$ then:
  \begin{enumerate}
  \item if $\bEv\in\aEvs_0$ and $\aEv\in\aEvs_0$ then $\bEv=\aEv$,
  \item if $\aEv\in\aEvs_0$ then $\labeling_0(\aEv) = \recv\aChan{\aVal}$,
  \item $\aTr_0(\aForm)$ implies $\phi[\aVal/\aVar]$, and
  \item if $\aEvs_0=\emptyset$ then $\aTr_0(\aForm)$ implies $\phi[\bVal/\aVar]$ for any $\bVal$.
  \end{enumerate}
\end{definition}

\subsection{A pomset with preconditions and predicate transformers model of Value-passing Relaxed CCS}

[Introduce relaxed channels, call other channels release/acquire channels, lift relaxed/ra up to actions and events.]

\begin{definition}
  A \emph{family of predicate transformers}
  indexed by subsets of $\aEvs$
  consists of predicate transformers
  $\aTr[\bEvs]$ for each set of events $\bEvs$,
  such that if $(\cEvs\cap\aEvs) \subseteq \bEvs$
  then $\aTr[\cEvs](\aForm)$ implies $\aTr[\bEvs](\aForm)$.
\end{definition}

\begin{definition}
  A pomset with predicate tansformers is a possibly incomplete
  pomset with preconditions, together with a family of predicate transformers $\aTr$
  indexed by subsets of $\aEvs$.
\end{definition}

\begin{definition}
  If $\aPS_0 \in (\aPSS_1\sSEMI\aPSS_2)$ then
  there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ where:
  \begin{enumerate}
  \item $\aEvs_0 = (\aEvs_1\cup\aEvs_2)$,
  \item $\aEvs_1$ and  $\aEvs_2$ are disjoint,
  \item if $\aEv\in\aEvs_1$ then $\labelingAct_0(\aEv) = \labelingAct_1(\aEv)$, 
  \item if $\aEv\in\aEvs_2$ then $\labelingAct_0(\aEv) = \labelingAct_2(\aEv)$,
  \item if $\aEv\in\aEvs_1$ then $\labelingForm_0(\aEv)$ implies $\labelingForm_1(\aEv)$, 
  \item if $\aEv\in\aEvs_2$ then $\labelingForm_0(\aEv)$ implies $\aTr[\downclose_0(e)]_1(\labelingForm_2(\aEv))$,
  \item if $\bEv\le_1\aEv$ then $\bEv\le_0\aEv$, and
  \item if $\bEv\le_2\aEv$ then $\bEv\le_0\aEv$.
  \end{enumerate}
\end{definition}

\begin{definition}
  If $\aPS_0 \in \sSEND\aChan{\aExp}$ then:
  \begin{enumerate}
  \item if $\bEv\in\aEvs_0$ and $\aEv\in\aEvs_0$ then $\bEv=\aEv$,
  \item if $\aEv\in\aEvs_0$ then $\labelingAct_0(\aEv) = \send\aChan{\aVal}$,
  \item if $\aEv\in\aEvs_0$ then $\labelingForm_0(\aEv) = (M = v)$, and
  \item $\aTr[\bEvs]_0(\aForm)$ implies $\aForm$.
  \end{enumerate}
\end{definition}

\begin{definition}
  If $\aPS_0 \in \sRECV\aChan{\aVar}$ then:
  \begin{enumerate}
  \item if $\bEv\in\aEvs_0$ and $\aEv\in\aEvs_0$ then $\bEv=\aEv$,
  \item if $\aEv\in\aEvs_0$ then $\labeling_0(\aEv) = \recv\aChan{\aVal}$,
  \item $\aTr[\bEvs]_0(\aForm)$ implies $\phi[\aVal/\aVar]$, and
  \item $\aTr[\emptyset]_0(\aForm)$ implies $\phi[\bVal/\aVar]$ for any $\bVal$.
  \end{enumerate}
\end{definition}
