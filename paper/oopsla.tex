\section{Differences from the OOPSLA Model}

\subsection{Must Allow Inconsistent Preconditions}

Removing the requirements for
\emph{consistency} and \emph{causal strengthening}, and

[The definition does not give a sensible notion of completed execution
without consistency and causal strengthening.]

%Item \ref{pre-reorder} does not impose coherence.
  

\subsection{Reads Update Local State}
In the rule for read prefixing we have substituted $[r/x]$, rather than
$[x/r]$.  This means that reads clobber local state.  We assume registers are
only used once---otherwise, one needs to generate a fresh register for the
substitution.

With read-read dependencies, this difference can be seen.  For example, the
following execution is allowed with $[x/r]$, but not $[r/x]$.
\begin{gather*}
  \PW{x}{0}\SEMI
  \PR{x}{r}\SEMI
  \IF{r}\THEN \PR{x}{s}\FI\SEMI
  \PW{y}{s{+}1}
  \PAR
  \PW{x}{\PR{y}{}}
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DW{x}{0}}{}
      \event{a2}{\DW{x}{1}}{right=of a1}
      \event{a3}{\DR{x}{0}}{right=of a2}
      \event{a4}{\DW{y}{1}}{right=of a3}
      \event{b1}{\DR{y}{1}}{right=3em of a4}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \wk{a1}{a2}
      \po{a2}{a3}
      \po{b1}{b2}
      \rf{a4}{b1}
      \rf[out=165,in=15]{b2}{a2}
    \end{tikzinline}}
\end{gather*}
[Is there a difference w/o read-read dependencies?]

[Don't need extended expressions anymore, since never substituting with $x$
for anything.]

\section{Errors in the OOPSLA Model}

This paper addresses several errors in \citep{10.1145/3428262}, which we
henceforth refer to as \jjr{}.

\subsection{Parallel Composition}

In \jjr{\textsection2.4}, parallel composition is defined allowing coalescing
of events.  Here we have forbidden coalescing.  This difference appears to be
arbitrary.  In \jjr{}, however, there is a mistake in the handling of
termination actions.  The predicates should be joined using $\land$, not
$\lor$.

\subsection{Redundant Read Elimination}

In \jjr{\textsection2.6} the semantics of read is defined as follows:
\begin{align*}
  \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & \eqdef \textstyle\bigcup_\aVal\;
  (\DRmode\aLoc\aVal) \prefix \sem{\aCmd} [\aLoc/\aReg]
\end{align*}
The definition of prefixing$((\aForm \mid \aAct) \prefix \aPSS)$ has several clauses.
The most relevant are as follows, where $\bEv$ is the new event labeled with
$(\aForm \mid \aAct)$ and $\aEv$ is an event from $\aPSS$:
\begin{description}
\item[{\labeltextsc[P4c]{(P4c)}{4c}}]
  If $\bEv$ reads $\aVal$ from $\aLoc$ then either $\aEv=\bEv$ or
  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$.
\item[{\labeltextsc[P5a]{(P5a)}{5a}}]\labeltextsc[P5]{}{5}%
  If $\bEv$ reads and $\aEv$ writes then either $\labelingForm'(\aEv)$
  implies $\labelingForm(\aEv)$ or $\bEv\le'\aEv$.
% \item[{\labeltextsc[P5b]{(P5b)}{5b}}]
%   If $\bEv$ and $\aEv$ are in conflict then $\bEv\le'\aEv$.
\end{description}

We have discovered two issues with this definition.

The first issue concerns the substitution $[\aLoc/\aReg]$.  It should be
$[\aReg/\aLoc]$.  We noticed this error while developing the alternative
characterization presented here.  The error causes redundant read elimination
to fail in \jjr{}.  As a result, common subexpression elimination also fails.
The problem can be seen in \ref{TC2}.
\begin{gather*}
  \taglabel{TC2}
  r\GETS x\SEMI
  s\GETS x\SEMI
  \IF{r{=}s}\THEN y\GETS 1\FI
  \PAR
  x\GETS y
\end{gather*}
% In \jjr{\textsection3.1},
We claimed that \ref{TC2} allowed the following
execution:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DR{x}{1}}{right=of a1}
  \event{a3}{\DW{y}{1}}{right=of a2}
  % \po{a2}{a3}
  % \po[out=15,in=165]{a1}{a3}
  \event{b1}{\DR{y}{1}}{right=3em of a3}
  \event{b2}{\DW{x}{1}}{right=of b1}
  \rf{a3}{b1}
  \po{b1}{b2}
  \rf[out=169,in=11]{b2}{a2}
  \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
But this execution is not possible using the semantics of \jjr{}:
$\DWP{y}{1}$ has precondition $r{=}s$ in
\begin{math}
  \sem{\IF{r{=}s}\THEN y\GETS 1\FI}.
\end{math}
Given the lack of order in the execution, the precondition of $\DWP{y}{1}$
must entail $r{=}1\land r{=}x$ in 
\begin{math}
  \sem{s\GETS x\SEMI
  \IF{r{=}s}\THEN y\GETS 1\FI}.
\end{math}
\ref{4c} imposes $r{=}1$, and \ref{5a} imposes $r{=}x$.  Adding the second
read, the precondition of $\DWP{y}{1}$ must entail both $1{=}1\land 1{=}x$
and also $x{=}1\land x{=}x$.  This can be simplified to $x{=}1$.  This leaves
a requirement that must be satisfied by a preceding write.  Since the
preceding write is the initialization to $0$, the requirement cannot be
satisfied, and the execution is impossible.\footnote{In \jjr{} we ignore the
  middle terms, mistakenly simplifying this to $1{=}1\land x{=}x$.
  Correcting the error, the attempted execution is:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DR{x}{1}}{right=of a1}
  \event{a3}{\DW{y}{1}}{right=of a2}
  \po{a2}{a3}
  \po[out=-20,in=-160]{a1}{a3}
  \event{b1}{\DR{y}{1}}{right=3em of a3}
  \event{b2}{\DW{x}{1}}{right=of b1}
  \rf{a3}{b1}
  \po{b1}{b2}
  \rf[out=169,in=11]{b2}{a2}
  \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}}

The substitution $[\aLoc/\aReg]$ leaves the obligation on $\aLoc$ to be
fulfilled by the preceding write.  Thus, the read does not update the
\emph{value} of $\aLoc$ in subsequent predicates.  The substitution
$[\aReg/\aLoc]$, instead, does update the value of $\aLoc$, thus removing any
obligation on $\aLoc$ for preceding code.

In order to write this, we must update the definition of prefixing reads to
include the register.  Then \ref{4c} becomes:
\begin{description}
\item[\textsc{(p4c)}] If $\bEv$ reads $\aVal$ from $\aLoc$ then either
  $\aEv=\bEv$ or $\labelingForm'(\aEv)$ implies
  $\labelingForm(\aEv)[\aVal/\aReg]$.
\end{description}

We can then reason with \ref{TC2} as follows: $\DWP{y}{1}$ has precondition
$r{=}s$ in
\begin{math}
  \sem{\IF{r{=}s}\THEN y\GETS 1\FI}.
\end{math}
To avoid introducing order in the execution, the precondition of $\DWP{y}{1}$
must entail $r{=}1\land r{=}s$ in 
\begin{math}
  \sem{s\GETS x\SEMI
  \IF{r{=}s}\THEN y\GETS 1\FI}.
\end{math}
\ref{4c} imposes $r{=}1$, and \ref{5a} imposes $r{=}x$.  Adding the second
read, the precondition of $\DWP{y}{1}$ must entail both $1{=}1\land 1{=}x$
and also $x{=}1\land x{=}x$.  This can be simplified to $x{=}1$.  This leaves
a requirement that must be satisfied by a preceding write.


With read elimination, the rule for relaxed reads is as follows:
\begin{align*}
  \sem{\PR{\aLoc}{\aReg} \SEMI \aCmd} &\eqdef
  \sem{\aCmd}[\aLoc/\aReg]
  \cup
  \textstyle\bigcup_\aVal\;
  \DRP{\aLoc}{\aVal} \prefix_{\aReg} %\Rdis{\aLoc}{\aVal}
  \sem{\aCmd}[\aReg/\aLoc]
\end{align*}
It is interesting to note that the substitution is $[\aLoc/\aReg]$ on
eliminated reads, and $[\aReg/\aLoc]$ on non-eliminated reads.  Intuitively,
the subsequent value of $\aLoc$ is fixed by an explicit read, but not for an
eliminated read.  In the latter case, the value is fixed by some preceding
action.  The preceding action may itself be a read. This gives rise to some
fear that we might introduce thin-air reads, since we do not enforce
read-read coherence.  But this is not the case.  Consider the following example:
\begin{gather*}
  r\GETS x\SEMI
  s\GETS x\SEMI
  y\GETS s
  \PAR
  x\GETS y
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DR{x}{1}}{right=of a1}
  \event{a3}{\DW{y}{1}}{right=of a2}
  %\po{a2}{a3}
  \po[out=-20,in=-160]{a1}{a3}
  \event{b1}{\DR{y}{1}}{right=3em of a3}
  \event{b2}{\DW{x}{1}}{right=of b1}
  \rf{a3}{b1}
  \po{b1}{b2}
  \rf[out=169,in=11]{b2}{a2}
  \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{a1}{\DR{x}{1}}{}
  \internal{a2}{\DR{x}{1}}{right=of a1}
  \event{a3}{\DW{y}{1}}{right=of a2}
  %\po{a2}{a3}
  \po[out=-20,in=-160]{a1}{a3}
  \event{b1}{\DR{y}{1}}{right=3em of a3}
  \event{b2}{\DW{x}{1}}{right=of b1}
  \rf{a3}{b1}
  \po{b1}{b2}
  %\rf[out=169,in=11]{b2}{a2}
  \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
But this is not a problem, since fulfillment requires that $\DWP{x}{1}$
precede both reads of $x$.

\subsection{Internal Acquiring Reads}

The second issue concerns acquiring reads.  Shortly after publication,
\citet{anton} noticed a shortcoming of the implementation on \armeight{} in
\jjr{\textsection 7}.  The proof given there assumes that all internal reads
can be dropped.  However, this is not the case for acquiring reds.  For
example, \jjr{} disallows the following execution, which is allowed by
\armeight{} and \tso{}.
\begin{gather*}
  \PW{x}{2}\SEMI 
  \PR[\mRA]{x}{r}\SEMI
  \PR{y}{s} \PAR
  \PW{y}{2}\SEMI
  \PW[\mRA]{x}{1}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DW{x}{2}}{}
      \raevent{b}{\DR[\mRA]{x}{2}}{right=of a}
      \event{c}{\DR{y}{0}}{right=of b}
      \event{d}{\DW{y}{2}}{right=2.5em of c}
      \raevent{e}{\DW[\mRA]{x}{1}}{right=of d}
      \rf{a}{b}
      \sync{b}{c}
      \wk{c}{d}
      \sync{d}{e}
      \wk[out=-165,in=-15]{e}{a}
      % \rfi{a}{b}
      % \bob{b}{c}
      % \fre{c}{d}
      % \bob{d}{e}
      % \coe[out=-165,in=-15]{e}{a}
    \end{tikzinline}}
\end{gather*}
The solution we have adopted is to allow an acquiring read to be downgraded
to a relaxed read when it is preceded (sequentially) by a relaxed write that
could fulfill it.  Back-porting this solution to \jjr{} requires that we add
access predicates to the logic and allow

\subsection{Triangular Races}

The notion of data-race is incorrect in \jjr{}.
\begin{gather*}
  \PW{x}{1}\SEMI
  \PW[\mRA]{y}{1}\SEMI
  \PR[\mRA]{x}{r}
  \PAR
  \IF{\PR[\mRA]{y}{}}\THEN \PW[\mRA]{x}{2}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DW{x}{1}}{}
      \raevent{a2}{\DW[\mRA]{y}{1}}{right=of a1}
      \raevent{a3}{\DR[\mRA]{x}{1}}{right=of a2}
      \raevent{b1}{\DR[\mRA]{y}{1}}{right=3em of a3}
      \raevent{b2}{\DW[\mRA]{x}{2}}{right=of b1}
      \sync{a1}{a2}
      \rf[out=20,in=160]{a1}{a3}
      \rf[out=20,in=160]{a2}{b1}
      \sync{b1}{b2}
    \end{tikzinline}}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DW{x}{1}}{}
      \raevent{a2}{\DW[\mRA]{y}{1}}{right=of a1}
      \raevent{a3}{\DR[\mRA]{x}{2}}{right=of a2}
      \raevent{b1}{\DR[\mRA]{y}{1}}{right=3em of a3}
      \raevent{b2}{\DW[\mRA]{x}{2}}{right=of b1}
      \sync{a1}{a2}
      \rf[out=20,in=160]{a2}{b1}
      \rf[out=160,in=20]{b2}{a3}
      \sync{b1}{b2}
    \end{tikzinline}}
\end{gather*}
Bug is in \citep[Lemma A.4]{DBLP:conf/ppopp/DongolJR19}.  It assumes that
$\DRP[\mRA]{x}{1}$ and $\DWP[\mRA]{x}{2}$ are racing in the first execution
because they are not ordered by happens-before.  But this is false since
neither is plain.

In addition, the \armeight{} implementation result given here does not rely
on read elimination.  Instead we use a recent alternative characterization of
\armeight{} \citep{alglave-git-alternate,arm-reference-manual,armed-cats}.

