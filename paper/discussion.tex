\section{Discussion}

\subsection{Relation to Traditional Predicate Transformers}

\begin{proposition}
  If $\aPS\in\sem{\aCmd}$ is top-level and quiescent then 
  $\aTr{\aEvs}{\bForm}$ implies $\fwp{\aCmd}{\bForm}$.

  For any substitution $\aSub=[{v_1/r_1},\ldots, {v_n/r_n}]$ there is some
  $\aPS\in\sem{\aCmd}$ %that is top-level and quiescent
  such that all preconditions in $\aPS\aSub$ are tautologies then 
  $\fwp{\aCmd}{\bForm}\aSub$
\end{proposition}

For a language where all programs are
terminating, we have for any statement $\aCmd$:
\begin{align*}
  \hoare{\aForm}{\aCmd}{\bForm} 
  \;\;\Leftrightarrow\;\;
  \aForm \textimplies \fwp{\aCmd}{\bForm}
\end{align*}
Interpretation is that if $\aState\models\fwp{\aCmd}{\bForm}$ and
$(\aState,\aCmd)\Downarrow\bState$
then $\bState\models\bForm$.

Let $\aCmd_0$ be
\begin{math}
  \PW{\aLoc_1}{\aVal_1}\SEMI\cdots\SEMI \PW{\aLoc_n}{\aVal_n}, 
\end{math}
such that $\fwp{\aCmd_0}{\aForm}$ is a tautology, and $\aLoc_i=\aLoc_j$
implies $i=j$.

Let $\aSub_\aPS=[{\aVal_1/\aLoc_1},\ldots, {\aVal_n/\aLoc_n}]$ be the final
state of $\aPS$.


For example, let $\aCmd_1=\PR{x}{r}$ and $\aCmd_2=\PW{x}{r{+}1}$ and
$\aCmd=\aCmd_1\SEMI \aCmd_2$.
\begin{align*}
  \fwp{\aCmd_2}{x{>}1}&=(r{+}1{>}1) = (r{>}0)
  \\
  \fwp{\aCmd_1}{r{>}0}=\fwp{\aCmd_0}{x{>}1}&=(x{>}0)
\end{align*}
Let $\aPS_i\in\sem{\aCmd_i}$.
\begin{align*}
  \aTr[2]{\aEvs_2}{x{>}1}&=(r{+}1{>}1) = (r{>}0)
  \\
  \aTr[0]{\aEvs_0}{x{>}1}&=(0{=}\aReg \limplies r{>}0)
  \\
  \aTr[0]{\aEvs_0}{x{>}1}&=(1{=}\aReg \limplies r{>}0)
  \\
  \aTr[0]{\aEvs_0}{x{>}1}&=(2{=}\aReg \limplies r{>}0)
\end{align*}

\begin{proposition}
  If $\aPS\in\sem{\aCmd}$ is top-level and quiescent then 
  $\aTr{\aEvs}{\aForm}$ implies $\fwp{\aCmd}{\aForm}$.

  For any substitution $\aSub=[{\aVal_1/\aReg_1},\ldots, {\aVal_n/\aReg_n}]$ there is some
  $\aPS\in\sem{\aCmd}$ %that is top-level and quiescent
  such that all preconditions in $\aPS\aSub$ are tautologies then 
  $\fwp{\aCmd}{\aForm}\aSub$
\end{proposition}

\subsection{[r/x] v [x/r]}

[I have a note: TC1: Track local state ???]

\begin{gather*}
  \PR{x}{s}\SEMI
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a2}{\DR{x}{2}}{}
      \event{a3}{(x{=}s\lor2{=}s)\limplies (r\land s\;\mathsf{even})\mid\DW{y}{1}}{right=of a2}
      \event{a4}{(x{=}s\lor2{=}s)\limplies (r\land s)\mid\DW{z}{1}}{below=of a3}
    \end{tikzinline}}
\end{gather*}
Without substitution:
\begin{gather*}
  \PR{x}{r}\SEMI
  \PR{x}{s}\SEMI
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DR{x}{2}}{below=of a1}
      \event{a3}{1{=}r\limplies  (x{=}s\lor2{=}s)\limplies (r\land s\;\mathsf{even})\mid\DW{y}{1}}{right=of a1}
      \event{a4}{1{=}r\limplies  (x{=}s\lor2{=}s)\limplies (r\land s)\mid\DW{z}{1}}{below=of a3}
      \po{a1}{a3}
      \po[out=-20,in=177]{a1}{a4}
    \end{tikzinline}}
\end{gather*}
Prepending $\PW{x}{0}$
\begin{gather*}
  % \PW{x}{0}\SEMI
  % \PR{x}{r}\SEMI
  % \PR{x}{s}\SEMI
  % \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  % \IF{r\land s}\THEN \PW{z}{1}\FI
  % \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a0}{\DW{x}{0}}{}
      \event{a1}{\DR{x}{1}}{right=of a0}
      \event{a2}{\DR{x}{2}}{right=of a1}
      \event{a3}{\DW{y}{1}}{right=of a2}
      \event{a4}{\DW{z}{1}}{right=of a3}
      % \wk{a0}{a1}
      % \wk[out=-20,in=-160]{a0}{a2}
      \po[out=20,in=160]{a1}{a3}
      \po[out=20,in=160]{a1}{a4}
      \po[out=-20,in=-160]{a2}{a4}
    \end{tikzinline}}
\end{gather*}
With the substitution $[r/x]$:
\begin{gather*}
  \PR{x}{r}\SEMI
  \PR{x}{s}\SEMI
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DR{x}{2}}{below=of a1}
      \event{a3}{1{=}r\limplies  (r{=}s\lor2{=}s)\limplies (r\land s\;\mathsf{even})\mid\DW{y}{1}}{right=of a1}
      \event{a4}{1{=}r\limplies  (r{=}s\lor2{=}s)\limplies (r\land s)\mid\DW{z}{1}}{below=of a3}
      \po{a1}{a3}
      \po[out=-20,in=177]{a1}{a4}
    \end{tikzinline}}
\end{gather*}
Prepending $\PW{x}{0}$
\begin{gather*}
  % \PW{x}{0}\SEMI
  % \PR{x}{r}\SEMI
  % \PR{x}{s}\SEMI
  % \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  % \IF{r\land s}\THEN \PW{z}{1}\FI
  % \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a0}{\DW{x}{0}}{}
      \event{a1}{\DR{x}{1}}{right=of a0}
      \event{a2}{\DR{x}{2}}{right=of a1}
      \event{a3}{\DW{y}{1}}{right=of a2}
      \event{a4}{\DW{z}{1}}{right=of a3}
      % \wk{a0}{a1}
      % \wk[out=-20,in=-160]{a0}{a2}
      \po[out=20,in=160]{a1}{a3}
      \po[out=20,in=160]{a1}{a4}
      \po{a2}{a3}
    \end{tikzinline}}
\end{gather*}


\begin{comment}
  if in L6 we said [x/r], that says we know read the local version...  ignoring
  the value read...  Perhaps there is some intervening stuff that stops you
  from seeing the local state, such as release-acquire

  We could potentially get rid of [x/r] If you do two reads, your not allowed
  to be independent of the second based on the value that was read in the first
  read.

  x=0; r=x; if (r=1) { s=x; if (s=?) {y=1}}
  read 1 then 2.


  In order for the write to be independent of second read what does its
  precondition have to be.
  [r/x] then s==1
  no sub then s==0

  (s=? | Wy1)

  if (phi) z=1
  phi = s is even
  phi = s < 2

  With substitution you are saying you know that the ``local copy'' of x is the
  same as r.  Sitting in the local cache.  Read might have gone to main
  memory, but if it did it has updated the cache line so that the local copy is
  what I just read.

  If second read is a cache hit, then I know that I am seeing the same value.

  If we take substitution out then 
\end{comment}


\subsection{Fork-Join}

It is also possible to put coherence in the independency relation, in which
case, the semantics of $;$ includes the following.
\begin{enumerate}
  \setcounter{enumi}{\value{pomsetXSemiCount}}
\item
  \label{seq-reorder} if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ either $\bEv<\aEv$ or $a\reorder\labeling_2(\aEv)$.
\end{enumerate}
One must be careful, however, due to \emph{inconsistency}.
Consider that \texttt{x=0;x=1} should not have completed pomset with only $\DWP{x}{0}$.

\eqref{seq-reorder} does not do the right thing with fork either.  If you
want to enforce coherence this way then you need to use fork-join as the
sequential combinator, rather than fork.


[We drop $\reorder$ because incompatible with $\sFORK{}$.  If you want to use
$\reorder$, then you need to use fork-join as the sequential combinator,
rather than fork.]

\begin{definition}
  A \emph{pomset with preconditions and termination} is
  a pomset with preconditions together with a predicate $\TICK$.
\end{definition}

% Define $\sTHREAD{}$ to transform a pomset with predicate transformers into a
% pomset with preconditions and termination by dropping the predicate
% transformer and setting $\TICK$ to indicate whether the pomset was completed.

% Extend the definition of $\sNIL$ so that $\TICK$ is true.

% Extend the definition of $\sPAR$ to handle for $\TICK$ by adding the
% following.
% \begin{enumerate}
%   \setcounter{enumi}{\value{pomsetPreParCount}}
% \item \label{par-tick}
%   if $\TICK$ then $\TICK_1$ and $\TICK_2$.
% \end{enumerate}

% Similarly, $\sFORKJOIN{}$ extends $\sFORK{}$ by adding the following.
% % \noindent
% % If $\aPS \in \sFORKJOIN{\aPSS}$ then
% % $(\exists\aPS_1\in\aPSS)$
% \begin{enumerate}
%   \setcounter{enumi}{\value{pomsetXForkCount}}
% \item $\TICK_1$.
% \end{enumerate}

\begin{definition}$\phantom{\;}$\par
  % \noindent
  % If $\aPS\in\sNIL$ then $\aEvs = \emptyset$ and $\TICK$.

  \noindent
  If $\aPS \in (\aPSS_1\sPAR\aPSS_2)$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPreParCount}}
  \item[\ref{par-E}--\ref{par-kappa2})]
    as for $\sPAR$ in Definition~\ref{def:pomsets-pre},
  \item \label{par-tick}
    $\TICK$ implies $\TICK_1\land\TICK_2$.
  \end{enumerate}

  \noindent
  If $\aPS \in \sTHREAD{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetXThreadCount}}
  \item[\ref{thread-E}--\ref{thread-kappa})]
    as for $\sTHREAD{}$ in Definition~\ref{def:thread},
  \item if $\TICK$ then $\aTr{\aEvs}{\Q{}}$ implies $\Q{}$.
  \end{enumerate}    

  \noindent
  If $\aPS \in \sFORKJOIN{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetXForkCount}}
  \item[\ref{F1x}--\ref{F4x})]
    as for $\sFORK{}$ in Definition~\ref{def:fork},
  \item[{\labeltext[F5]{F5)}{F5}}]
    $\TICK_1$.
  \end{enumerate}    
\end{definition}

\begin{align*}
  \sem{\FORKJOIN{\aGrp}} &= \sFORKJOIN{}\sem{\aGrp}  
\end{align*}

We can then encode coherence as follows.
\begin{enumerate}
  \setcounter{enumi}{\value{pomsetXSemiCount}}
\item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ either $\bEv<\aEv$ or $a\reorder\labeling_2(\aEv)$.
\end{enumerate}


Access modes can be encoded in the independency relation, indexing labels by
$\amode$, but the extra flexibility of the logic is necessary for \armeight{}
(see \textsection\ref{sec:internal}).  Using independency, one would also
need another way to define completed pomsets.  Finally, this use of
independency is incompatible with fork (see \textsection\ref{sec:co}).


If we move coherence to independency (and use fork-join), we have the
following, assuming that each register occurs at most once.
\begin{align*}
  \QS{}{\mSC}&=\Q{\mSC}
  &\QS{}{\mRA}&=\Q{\mRA}
  &\QS{}{\mRLX}&=\Qx{\aLoc}
  \\
  \QL{}{\mSC}&=\Q{\mSC}
  &\QL{}{\mRA}&=\Qw{\aLoc}
  &\QL{}{\mRLX}&=\Qw{\aLoc}
  \\
  \DS{\aLoc}{\mSC}{\bForm}&=\bForm[\FALSE/\D]
  &\DS{\aLoc}{\mRA}{\bForm}&=\bForm[\FALSE/\D]
  &\DS{\aLoc}{\mRLX}{\bForm}&=\bForm[\TRUE/\Dx{\aLoc}] 
  \\
  \DL{\aLoc}{\mSC}&=\Dx{\aLoc}
  &\DL{\aLoc}{\mRA}&=\Dx{\aLoc}
  &\DL{\aLoc}{\mRLX}&=\TRUE
\end{align*}

% $\QS{}{\mRLX}=\TRUE$ and otherwise $\QS{}{\amode}=\Q{\amode}$.

% $\QL{}{\mSC}=\Q{\mSC}$ and otherwise $\QL{}{\amode}=\TRUE$.

% $\DS{\aLoc}{\mRLX}{\bForm}=\bForm[\TRUE/\Dx{\aLoc}]$ and otherwise
% $\DS{\aLoc}{\amode}{\bForm}=\bForm[\FALSE/\D]$. 

% $\DL{\aLoc}{\mRLX}=\TRUE$ and otherwise $\DL{\aLoc}{\amode}=\Dx{\aLoc}$.

% \begin{definition}$\phantom{\;}$\par
%   $\QS{}{\mRLX}=\TRUE$ and otherwise $\QS{}{\amode}=\Q{\amode}$.

%   $\QL{}{\mSC}=\Q{\mSC}$ and otherwise $\QL{}{\amode}=\TRUE$.

\noindent
If $\aPS \in \sSTORE[\amode]{\aLoc}{\aExp}$ then
\begin{enumerate}
\item[\ref{S1}--\ref{S2})] as before,
\item[\ref{S3})]
  $\labelingForm(\aEv)$ implies
  \begin{math}
    \aExp{=}\aVal
    \land \RW
    \land \QS{}{\amode}
  \end{math},
\item[\ref{S4})]
  $\aTr{\bEvs}{\bForm}$ implies 
  \begin{math}
    \aExp{=}\aVal
    \land \DS{\aLoc}{\amode}{\bForm[\aExp/{\aLoc}]}
  \end{math},
\item[\ref{S5})]
  $\aTr{\emptyset}{\bForm}$ implies 
  \begin{math}
    \lnot\Q{\mRA}
    \land \DS{\aLoc}{\amode}{\bForm[\aExp/{\aLoc}]}
  \end{math}
\end{enumerate}

\noindent
If $\aPS \in \sLOAD[\amode]{\aReg}{\aLoc}$ then
\begin{enumerate}
\item[\ref{L1}--\ref{L2})] as before,
\item[\ref{L3})] $\labelingForm(\aEv)$ implies
  \begin{math}
    \RO
    \land \QL{}{\amode}
  \end{math},
\item[\ref{L4})]
  $\aTr{\bEvs}{\bForm}$ implies
  \begin{math}
    (\aVal{=}\aReg)
    \limplies \bForm[\aReg/{\aLoc}]
  \end{math}
\item[\ref{L5})] 
  $\aTr{\emptyset}{\bForm}$ implies
  \begin{math}
    \DL{\aLoc}{\amode}
    \land \lnot\Q{\mRA}
    \land
    (\RW
    \limplies (\aVal{=}\aReg\lor\aLoc{=}\aReg) 
    \limplies \bForm[\aReg/{\aLoc}]
    ).
  \end{math}
\end{enumerate}  

\subsection{Must Allow Inconsistent Preconditions}

See examples in \textsection\ref{sec:if}.

Removing the requirements for
\emph{consistency} and \emph{causal strengthening}, and

[The definition does not give a sensible notion of completed execution
without consistency and causal strengthening.]

%Item \ref{pre-reorder} does not impose coherence.


\subsection{Skolemization}

\jjr{} is non-skolemized, using substitution instead, and collapsing $\aLoc$
and $\aReg$.
There, item \ref{loadpre-kappa2}  of $\sLOADPRE{}{}{}$ is written 
\begin{enumerate}
\item[] %[\ref{loadpre-kappa2})]
  if $\aEv\in\aEvs_2\setminus\aEvs_1$ then either \\
  $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)[\aLoc/\aReg][\aVal/\aLoc]$ and $(\exists\bEv\in\aEvs_1)\bEv{<}\aEv$, or \\
  $\labelingForm(\aEv)$ implies
  $\labelingForm_2(\aEv)[\aLoc/\aReg][\aVal/\aLoc] \land \labelingForm_2(\aEv)[\aLoc/\aReg]$.
\end{enumerate}


\jjr{} is non-skolemized---with $[x/r]$ rather than no substitution.
\begin{enumerate}
\item[\ref{L4})]
  $\aTr{\bEvs}{\bForm}$ implies $\bForm[\aLoc/\aReg][\aVal/\aLoc]$, 
\item[\ref{L5})]
  $\aTr{\emptyset}{\bForm}\;$ implies $\bForm[\aLoc/\aReg][\aVal/\aLoc]\land\bForm[\aLoc/\aReg]$,
\item[\ref{L6})]
  $\aTr{\emptyset}{\bForm}\;$ implies $\bForm[\aLoc/\aReg]$.
\end{enumerate}

[Skolemization ensures disjunction closure, which is necessary
for associativity. Show example.]

\subsection{Reads Update Local State}
In the rule for read prefixing we have substituted $[r/x]$, rather than
$[x/r]$.  This means that reads clobber local state.  We assume registers are
only used once---otherwise, one needs to generate a fresh register for the
substitution.

With read-read dependencies, this difference can be seen.  For example, the
following execution is allowed with $[x/r]$, but not $[r/x]$.
\begin{gather*}
  \PW{x}{0}\SEMI
  \PR{x}{r}\SEMI
  \IF{r}\THEN \PR{x}{s}\FI\SEMI
  \PW{y}{s{+}1}
  \PAR
  \PW{x}{\PR{y}{}}
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DW{x}{0}}{}
      \event{a2}{\DW{x}{1}}{right=of a1}
      \event{a3}{\DR{x}{0}}{right=of a2}
      \event{a4}{\DW{y}{1}}{right=of a3}
      \event{b1}{\DR{y}{1}}{right=3em of a4}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \wk{a1}{a2}
      \po{a2}{a3}
      \po{b1}{b2}
      \rf{a4}{b1}
      \rf[out=165,in=15]{b2}{a2}
    \end{tikzinline}}
\end{gather*}
[Is there a difference w/o read-read dependencies?]

[Don't need extended expressions anymore, since never substituting with $x$
for anything.]



\subsection{Parallel Composition}

In \jjr{\textsection2.4}, parallel composition is defined allowing coalescing
of events.  Here we have forbidden coalescing.  This difference appears to be
arbitrary.  In \jjr{}, however, there is a mistake in the handling of
termination actions.  The predicates should be joined using $\land$, not
$\lor$.

\subsection{Redundant Read Elimination}
\label{sec:redundant}

Requires indexing to resolve nondeterminism.

\begin{gather*}
  \taglabel{TC2}
  \PR{x}{r}\SEMI
  \PR{x}{s}\SEMI
  \IF{r{=}s}\THEN \PW{y}{1}\FI
  \PAR
  x\GETS y
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DR{x}{1}}{right=of a1}
      \event{a3}{\DW{y}{1}}{right=of a2}
      % \po{a2}{a3}
      % \po[out=-20,in=-160]{a1}{a3}
      \event{b1}{\DR{y}{1}}{right=3em of a3}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \rf{a3}{b1}
      \po{b1}{b2}
      \rf[out=169,in=11]{b2}{a2}
      \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
Precondition of $\DWP{y}{1}$ is $(r{=}s)$ in
\begin{math}
  \sem{\IF{r{=}s}\THEN y\GETS 1\FI}.
\end{math}
Predicate transformers for $\emptyset$ in $\sem{\PR{x}{r}}$ and $\sem{\PR{x}{s}}$ are
\begin{align*}
  \PREDP{(r{=}1 \lor r{=}x)\limplies\bForm[r/x]},
  \\
  \PREDP{(s{=}1 \lor s{=}x)\limplies\bForm[s/x]}.
\end{align*}
Combining the transformers, we have
\begin{displaymath}
  \PREDP{(r{=}1 \lor r{=}x)\limplies(s{=}1 \lor s{=}r)\limplies\bForm[s/x]}.
\end{displaymath}
Applying this to $(r{=}s)$, we have
\begin{displaymath}
  \PREDP{(r{=}1 \lor r{=}x)\limplies (s{=}1 \lor s{=}r)\limplies (r{=}s)},
\end{displaymath}
which is not a tautology.

Same problem occurs \jjr{}, where we have:
\begin{align*}
  \PREDP{\bForm[v/x,r] \land \bForm[x/r]},
  \\
  \PREDP{\bForm[v/x,s] \land \bForm[x/s]}.
\end{align*}
Combining the transformers, we have
\begin{displaymath}
  \PREDP{\bForm[v/x,r,s] \land \bForm [v/x,r][x/s] \land \bForm[x/r][v/x,s] \land \bForm[x/r,s]}.
\end{displaymath}
Applying this to $(r{=}s)$, we have
\begin{displaymath}
  \PREDP{v{=}v \land v{=}x \land x{=}v \land x{=}x},
\end{displaymath}
which is not a tautology.

The semantics here allows this by coalescing:
\begin{gather*}
  r\GETS x\SEMI
  s\GETS x\SEMI
  \IF{r{=}s}\THEN y\GETS 1\FI
  \PAR
  x\GETS y
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a3}{\DW{y}{1}}{right=of a1}
      \event{b1}{\DR{y}{1}}{right=3em of a3}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \rf{a3}{b1}
      \po{b1}{b2}
      \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}

\subsection{Redundant Read Elimination}

In \jjr{\textsection2.6} the semantics of read is defined as follows:
\begin{align*}
  \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & \eqdef \textstyle\bigcup_\aVal\;
  (\DRmode\aLoc\aVal) \prefix \sem{\aCmd} [\aLoc/\aReg]
\end{align*}
The definition of prefixing$((\aForm \mid \aAct) \prefix \aPSS)$ has several clauses.
The most relevant are as follows, where $\bEv$ is the new event labeled with
$(\aForm \mid \aAct)$ and $\aEv$ is an event from $\aPSS$:
\begin{description}
\item[{\labeltextsc[P4c]{(P4c)}{4c}}]
  If $\bEv$ reads $\aVal$ from $\aLoc$ then either $\aEv=\bEv$ or
  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$.
\item[{\labeltextsc[P5a]{(P5a)}{5a}}]\labeltextsc[P5]{}{5}%
  If $\bEv$ reads and $\aEv$ writes then either $\labelingForm'(\aEv)$
  implies $\labelingForm(\aEv)$ or $\bEv\le'\aEv$.
  % \item[{\labeltextsc[P5b]{(P5b)}{5b}}]
  %   If $\bEv$ and $\aEv$ are in conflict then $\bEv\le'\aEv$.
\end{description}

We have discovered two issues with this definition.

The first issue concerns the substitution $[\aLoc/\aReg]$.  It should be
$[\aReg/\aLoc]$.  We noticed this error while developing the alternative
characterization presented here.  The error causes redundant read elimination
to fail in \jjr{}.  As a result, common subexpression elimination also fails.
The problem can be seen in \ref{TC2}.
\begin{gather*}
  \taglabel{TC2}
  r\GETS x\SEMI
  s\GETS x\SEMI
  \IF{r{=}s}\THEN y\GETS 1\FI
  \PAR
  x\GETS y
\end{gather*}
% In \jjr{\textsection3.1},
We claimed that \ref{TC2} allowed the following
execution:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DR{x}{1}}{right=of a1}
      \event{a3}{\DW{y}{1}}{right=of a2}
      % \po{a2}{a3}
      % \po[out=15,in=165]{a1}{a3}
      \event{b1}{\DR{y}{1}}{right=3em of a3}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \rf{a3}{b1}
      \po{b1}{b2}
      \rf[out=169,in=11]{b2}{a2}
      \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
But this execution is not possible using the semantics of \jjr{}:
$\DWP{y}{1}$ has precondition $r{=}s$ in
\begin{math}
  \sem{\IF{r{=}s}\THEN y\GETS 1\FI}.
\end{math}
Given the lack of order in the execution, the precondition of $\DWP{y}{1}$
must entail $r{=}1\land r{=}x$ in 
\begin{math}
  \sem{s\GETS x\SEMI
    \IF{r{=}s}\THEN y\GETS 1\FI}.
\end{math}
\ref{4c} imposes $r{=}1$, and \ref{5a} imposes $r{=}x$.  Adding the second
read, the precondition of $\DWP{y}{1}$ must entail both $1{=}1\land 1{=}x$
and also $x{=}1\land x{=}x$.  This can be simplified to $x{=}1$.  This leaves
a requirement that must be satisfied by a preceding write.  Since the
preceding write is the initialization to $0$, the requirement cannot be
satisfied, and the execution is impossible.\footnote{In \jjr{} we ignore the
  middle terms, mistakenly simplifying this to $1{=}1\land x{=}x$.
  Correcting the error, the attempted execution is:
  \begin{gather*}
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a1}{\DR{x}{1}}{}
        \event{a2}{\DR{x}{1}}{right=of a1}
        \event{a3}{\DW{y}{1}}{right=of a2}
        \po{a2}{a3}
        \po[out=-20,in=-160]{a1}{a3}
        \event{b1}{\DR{y}{1}}{right=3em of a3}
        \event{b2}{\DW{x}{1}}{right=of b1}
        \rf{a3}{b1}
        \po{b1}{b2}
        \rf[out=169,in=11]{b2}{a2}
        \rf[out=169,in=11]{b2}{a1}
      \end{tikzinline}}
  \end{gather*}}

The substitution $[\aLoc/\aReg]$ leaves the obligation on $\aLoc$ to be
fulfilled by the preceding write.  Thus, the read does not update the
\emph{value} of $\aLoc$ in subsequent predicates.  The substitution
$[\aReg/\aLoc]$, instead, does update the value of $\aLoc$, thus removing any
obligation on $\aLoc$ for preceding code.

In order to write this, we must update the definition of prefixing reads to
include the register.  Then \ref{4c} becomes:
\begin{description}
\item[\textsc{(p4c)}] If $\bEv$ reads $\aVal$ from $\aLoc$ then either
  $\aEv=\bEv$ or $\labelingForm'(\aEv)$ implies
  $\labelingForm(\aEv)[\aVal/\aReg]$.
\end{description}

We can then reason with \ref{TC2} as follows: $\DWP{y}{1}$ has precondition
$r{=}s$ in
\begin{math}
  \sem{\IF{r{=}s}\THEN y\GETS 1\FI}.
\end{math}
To avoid introducing order in the execution, the precondition of $\DWP{y}{1}$
must entail $r{=}1\land r{=}s$ in 
\begin{math}
  \sem{s\GETS x\SEMI
    \IF{r{=}s}\THEN y\GETS 1\FI}.
\end{math}
\ref{4c} imposes $r{=}1$, and \ref{5a} imposes $r{=}x$.  Adding the second
read, the precondition of $\DWP{y}{1}$ must entail both $1{=}1\land 1{=}x$
and also $x{=}1\land x{=}x$.  This can be simplified to $x{=}1$.  This leaves
a requirement that must be satisfied by a preceding write.


With read elimination, the rule for relaxed reads is as follows:
\begin{align*}
  \sem{\PR{\aLoc}{\aReg} \SEMI \aCmd} &\eqdef
  \sem{\aCmd}[\aLoc/\aReg]
  \cup
  \textstyle\bigcup_\aVal\;
  \DRP{\aLoc}{\aVal} \prefix_{\aReg} %\Rdis{\aLoc}{\aVal}
  \sem{\aCmd}[\aReg/\aLoc]
\end{align*}
It is interesting to note that the substitution is $[\aLoc/\aReg]$ on
eliminated reads, and $[\aReg/\aLoc]$ on non-eliminated reads.  Intuitively,
the subsequent value of $\aLoc$ is fixed by an explicit read, but not for an
eliminated read.  In the latter case, the value is fixed by some preceding
action.  The preceding action may itself be a read. This gives rise to some
fear that we might introduce thin-air reads, since we do not enforce
read-read coherence.  But this is not the case.  Consider the following example:
\begin{gather*}
  r\GETS x\SEMI
  s\GETS x\SEMI
  y\GETS s
  \PAR
  x\GETS y
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DR{x}{1}}{right=of a1}
      \event{a3}{\DW{y}{1}}{right=of a2}
      % \po{a2}{a3}
      \po[out=-20,in=-160]{a1}{a3}
      \event{b1}{\DR{y}{1}}{right=3em of a3}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \rf{a3}{b1}
      \po{b1}{b2}
      \rf[out=169,in=11]{b2}{a2}
      \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DR{x}{1}}{}
      \internal{a2}{\DR{x}{1}}{right=of a1}
      \event{a3}{\DW{y}{1}}{right=of a2}
      % \po{a2}{a3}
      \po[out=-20,in=-160]{a1}{a3}
      \event{b1}{\DR{y}{1}}{right=3em of a3}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \rf{a3}{b1}
      \po{b1}{b2}
      % \rf[out=169,in=11]{b2}{a2}
      \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
But this is not a problem, since fulfillment requires that $\DWP{x}{1}$
precede both reads of $x$.

\subsection{Internal Acquiring Reads}

Our solution allows executions that are not allowed under \armeight{} since
we do not insist that the local relaxed write is actually read from.  This
may seem counterintuitive, but we don't see a local way to be more precise.


The second issue concerns acquiring reads.  Shortly after publication,
\citet{anton} noticed a shortcoming of the implementation on \armeight{} in
\jjr{\textsection 7}.  The proof given there assumes that all internal reads
can be dropped.  However, this is not the case for acquiring reds.  For
example, \jjr{} disallows the following execution, which is allowed by
\armeight{} and \tso{}.
\begin{gather*}
  \PW{x}{2}\SEMI 
  \PR[\mRA]{x}{r}\SEMI
  \PR{y}{s} \PAR
  \PW{y}{2}\SEMI
  \PW[\mRA]{x}{1}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DW{x}{2}}{}
      \raevent{b}{\DR[\mRA]{x}{2}}{right=of a}
      \event{c}{\DR{y}{0}}{right=of b}
      \event{d}{\DW{y}{2}}{right=2.5em of c}
      \raevent{e}{\DW[\mRA]{x}{1}}{right=of d}
      \rf{a}{b}
      \sync{b}{c}
      \wk{c}{d}
      \sync{d}{e}
      \wk[out=-165,in=-15]{e}{a}
      % \rfi{a}{b}
      % \bob{b}{c}
      % \fre{c}{d}
      % \bob{d}{e}
      % \coe[out=-165,in=-15]{e}{a}
    \end{tikzinline}}
\end{gather*}
The solution we have adopted is to allow an acquiring read to be downgraded
to a relaxed read when it is preceded (sequentially) by a relaxed write that
could fulfill it.  Back-porting this solution to \jjr{} requires that we add
access predicates to the logic and allow

\subsection{Triangular Races}

The notion of data-race is incorrect in \jjr{}.
\begin{gather*}
  \PW{x}{1}\SEMI
  \PW[\mRA]{y}{1}\SEMI
  \PR[\mRA]{x}{r}
  \PAR
  \IF{\PR[\mRA]{y}{}}\THEN \PW[\mRA]{x}{2}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DW{x}{1}}{}
      \raevent{a2}{\DW[\mRA]{y}{1}}{right=of a1}
      \raevent{a3}{\DR[\mRA]{x}{1}}{right=of a2}
      \raevent{b1}{\DR[\mRA]{y}{1}}{right=3em of a3}
      \raevent{b2}{\DW[\mRA]{x}{2}}{right=of b1}
      \sync{a1}{a2}
      \rf[out=20,in=160]{a1}{a3}
      \rf[out=20,in=160]{a2}{b1}
      \sync{b1}{b2}
    \end{tikzinline}}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DW{x}{1}}{}
      \raevent{a2}{\DW[\mRA]{y}{1}}{right=of a1}
      \raevent{a3}{\DR[\mRA]{x}{2}}{right=of a2}
      \raevent{b1}{\DR[\mRA]{y}{1}}{right=3em of a3}
      \raevent{b2}{\DW[\mRA]{x}{2}}{right=of b1}
      \sync{a1}{a2}
      \rf[out=20,in=160]{a2}{b1}
      \rf[out=160,in=20]{b2}{a3}
      \sync{b1}{b2}
    \end{tikzinline}}
\end{gather*}
Bug is in \citep[Lemma A.4]{DBLP:conf/ppopp/DongolJR19}.  It assumes that
$\DRP[\mRA]{x}{1}$ and $\DWP[\mRA]{x}{2}$ are racing in the first execution
because they are not ordered by happens-before.  But this is false since
neither is plain.

In addition, the \armeight{} implementation result given here does not rely
on read elimination.  Instead we use a recent alternative characterization of
\armeight{} \citep{alglave-git-alternate,arm-reference-manual,armed-cats}.

