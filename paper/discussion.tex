\subsection{Further Comparison with Sequential Predicate Transformers}

We compare traditional transformers to the dependent-case transformers of
\reffig{fig:seq}. %; thus we consider only totally ordered executions.
% Because
% we only consider the dependent case, we drop the superscript $\aEvs$ on
% $\aTr{\aEvs}{}$ throughout this section.  We also assume that each register
% appears at most once in a program, as we did throughout
% \textsection\ref{sec:model}--\ref{sec:arm}.

% Because of augment closure, we are not interested in isolating the
% \emph{weakest} precondition.  Thus we think of transformers as Hoare triples.
% In addition, 
All programs in our language are strongly normalizing, so we
need not distinguish strong and weak correctness.  In this setting, the Hoare
triple $\hoare{\aForm}{\aCmd}{\bForm}$ holds exactly when
$\aForm \limplies \fwp{\aCmd}{\bForm}$.

Hoare triples do not distinguish thread-local variables from shared
variables.  Thus, the assignment rule applies to all types of storage. The
rules can be written as on the left below:
\begin{align*}
\begin{aligned}
  \fwp{\PW{\aLoc}{\aExp}}{\bForm} &= \bForm[\aExp/\aLoc]
  \\
  \fwp{\LET{\aReg}{\aExp}}{\bForm} &= \bForm[\aExp/\aReg]
  \\
  \fwp{\PR{\aLoc}{\aReg}}{\bForm} &= \aLoc{=}\aReg\limplies\bForm
\end{aligned}
&&
\begin{aligned}
  \trd{\PW{\aLoc}{\aExp}}{\bForm} &= \bForm[\aExp/\aLoc]
  \\
  \trd{\LET{\aReg}{\aExp}}{\bForm} &= \bForm[\aExp/\aReg]
  \\
  \trd{\PR{\aLoc}{\aReg}}{\bForm} &= \aVal{=}\aReg\limplies\bForm &&
  \textwhere \labelingAct(\aEv)=\DR{\aLoc}{\aVal}
\end{aligned}
\end{align*}
Here we have chosen an alternative formulation for the read rule, which is
equivalent to the more traditional $\bForm[\aLoc/\aReg]$, as long as registers
are assigned at most once in a program.  Our predicate transformers for the
dependent case are shown on the right above.  Only the read rule differs from
the traditional one.

For programs where every register is bound and every read is fulfilled, our
dependent transformers are the same as the traditional ones.  Thus, when
comparing to weakest preconditions, let us only consider totally-ordered
executions of our semantics where every read could be fulfilled by prepending
some writes.  For example, we ignore pomsets of $\PW{x}{2}\SEMI\PR{x}{r}$
that read $1$ for $x$.

For example, let $\aCmd_i$ be defined:
% as follows.
\begin{align*}
  \aCmd_1&=\PR{x}{s}\SEMI\PW{x}{s{+}r}
  &  
  \aCmd_2&=\PW{x}{t}\SEMI\aCmd_1
  &  
  \aCmd_3&=\LET{t}{2}\SEMI\LET{r}{5}\SEMI\aCmd_2
\end{align*}
% \begin{itemize}
% \item
%   \begin{math}
%     \fwp{\LET{\aReg}{\aExp}}{\bForm} = \bForm[\aExp/\aReg]
%   \end{math}
% \item
%   \begin{math}
%     \fwp{\PR{\aLoc}{\aReg}\;\,}{\bForm} = %\bForm[x/r]
%     %     (\forall\bReg)
%     %     \aLoc{=}\bReg\limplies\bForm [\bReg/\aLoc]
%     \aLoc{=}\aReg\limplies\bForm
%   \end{math}
% \item
%   \begin{math}
%     \fwp{\PW{\aLoc}{\aExp}}{\bForm} = \bForm[\aExp/\aLoc]
%   \end{math}
% \end{itemize}
% General relation between Hoare triples and $\fwp{}{}$:
% \begin{itemize}
% \item $\hoare{\fwp{\aCmd}{\bForm}}{\aCmd}{\bForm}$,
% \item If $\hoare{\aForm}{\aCmd}{\bForm}$ and $\aCmd$ terminates when starting
%   in any state satisfying $\aForm$, then $\aForm \limplies \fwp{\aCmd}{\bForm}$.
% \end{itemize}
The following pomset appears in the semantics of $\aCmd_2$.  A pomset for
$\aCmd_3$ can be derived by substituting $[2/t,\allowbreak5/r]$.  A pomset
for $\aCmd_1$ can be derived by eliminating the initial write.
\begin{gather*}
  % \begin{gathered}[t]
  %   \PW{x}{3}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{c}{\DW{x}{3}}{}
  %     \xform{xd}{\bForm}{below=of c}
  %     \xo[xright]{c}{xd}
  %   \end{tikzinline}}
  % \end{gathered}
  % \qquad\quad
  % \begin{gathered}[t]
  %   \PR{x}{s}\SEMI\PW{x}{s{+}r}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{a}{\DR{x}{2}}{}
  %     \event{b}{2{=}s\limplies(s{+}r){=}7\bigmid\DW{x}{7}}{right=of a}%6.5em of a}
  %     \po{a}{b}
  %     \xform{xdd}{2{=}s \limplies \bForm[s{+}r/x]}{below right=.5em and -1em of a}
  %       %     \xform{xdd}{2{=}s \limplies \bForm[s{+}r/x]}{above=of a}
  %       %     \xform{xdi}{2{=}s \limplies \bForm[s{+}r/x]}{below=of a}
  %       %     \xform{xii}{(2{=}s\lor x{=}s)\limplies\bForm[s{+}r/x]}{above=of b}
  %       %     \xform{xid}{(2{=}s\lor x{=}s)\limplies\bForm[s{+}r/x]}{below=of b}
  %       %     \xo[xright]{a}{xdi}
  %       %     \xo[xright]{b}{xid}
  %     \xo[xright]{a}{xdd}
  %     \xo[xright]{b}{xdd}
  %   \end{tikzinline}}
  % \end{gathered}
  % \\[1ex]
  \begin{gathered}[t]
    % \LET{t}{2}\SEMI
    % \LET{r}{5}\SEMI
    \PW{x}{t}\SEMI
    \PR{x}{s}\SEMI\PW{x}{s{+}r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a}{\DR{x}{2}}{}
        \event{b}{2{=}s\limplies(s{+}r){=}7\bigmid\DW{x}{7}}{right=of a}
        \event{c}{t{=}2\bigmid\DW{x}{2}}{left=of a}
        \xform{xdd}{2{=}s \limplies \bForm[s{+}r/x]}{right=of b}%below right=.5em and -1em of a}
        %\xo{a}{xdd}
        \xo{b}{xdd}
        % \xo{c}{xdd}
        \po{a}{b}
        \rf{c}{a}
      \end{tikzinline}}
  \end{gathered}
\end{gather*}
The predicate transformers are:
% \begin{align*}
%   \fwp{\aCmd_1}{\bForm} &= x{=}s\limplies\bForm[s{+}r/x] 
%   \\
%   \fwp{\aCmd_2}{\bForm} &= t\,{=}s\limplies\bForm[s{+}r/x] 
%   \\
%   \fwp{\aCmd_3}{\bForm} &= 2{=}s\limplies\bForm[s{+}5/x] 
%   \\
%   \trd{\aCmd_1}{\bForm} = \trd{\aCmd_2}{\bForm} &= 2{=}s\limplies\bForm[s{+}r/x] 
%   \\
%   \trd{\aCmd_3}{\bForm} &= 2{=}s\limplies\bForm[s{+}5/x] 
% \end{align*}
\begin{scope}
  \small
  \begin{align*}
    \fwp{\aCmd_1}{\bForm} &= x{=}s\limplies\bForm[s{+}r/x] 
    &
    \trd{\aCmd_1}{\bForm} &= 2{=}s\limplies\bForm[s{+}r/x] 
    \\
    \fwp{\aCmd_2}{\bForm} &= t\,{=}s\limplies\bForm[s{+}r/x] 
    &
    \trd{\aCmd_2}{\bForm} &= 2{=}s\limplies\bForm[s{+}r/x] 
    \\
    \fwp{\aCmd_3}{\bForm} &= 2{=}s\limplies\bForm[s{+}5/x] 
    &
    \trd{\aCmd_3}{\bForm} &= 2{=}s\limplies\bForm[s{+}5/x] 
  \end{align*}
\end{scope}

% % Let $\rho:\Reg\fun\Val$ and $\chi:\Loc\fun\Val$ be substitutions.
% Let $\aState$ and $\rho$ range over substitutions $(\Reg\cup\Loc)\fun\Val$.
% Treating substitutions as states, the big-step operational semantics of
% programs can be defined as a relation $\bigstep{\aState}{\aCmd}{\bState}$.
% % Ie, $\aForm\aState$ implies $\bForm\bState$.
% \begin{align}
%   \label{wp1}
%   \bigstep{[5/r,2/x]}{\aCmd_1&}{[5/r,2/s,7/x]}
%   \\
%   \label{wp2}
%   \bigstep{[\NEG5/r,2/x]}{\aCmd_1&}{[\NEG5/r,2/s,\NEG3/x]}
% \end{align}

% Then the semantics of Hoare triples guarantees that if
% $\aForm\limplies\fwp{\aCmd}{\bForm}$, $\bigstep{\aState}{\aCmd}{\rho}$ and
% $\aForm\aState$ is a tautology then $\bForm\bState$ is a tautology.
% \begin{align*}
%   \fwp{\aCmd_1}{x{>}0} &= (x{+}r{>}0) 
% \end{align*}
% In \eqref{wp1}, the pre- and post-conditions are satisfied.
% In \eqref{wp2}, they are not.


% \begin{itemize}  
% \item Suppose $\bigstep{\aState}{\aCmd}{\rho}$ and $\aForm\limplies\fwp{\aCmd}{\bForm}$.\\
%   If $\aForm\aState$ is a tautology then $\bForm\bState$ is a tautology.\\
%   Ie, $\aForm\aState$ implies $\bForm\bState$.
% \item Suppose $\bigstep{\aState}{\aCmd}{\rho}$ and $\hoare{\aForm}{\aCmd}{\bForm}$.\\
%   If $\aForm\aState$ is a tautology then $\bForm\bState$ is a tautology.\\
%   Ie, $\aForm\aState$ implies $\bForm\bState$.
% \item Suppose $\bigstep{\aState}{\aCmd}{\rho}$ and $\aForm=\fwp{\aCmd}{\bForm}$.\\
%   $\aForm\aState$ is a tautology if and only if $\bForm\bState$ is a tautology.\\
%   Ie, $\aForm\aState$ iff $\bForm\bState$.
% % \item Weakest: If $\aForm'\aState$ is a tautology, then $\aForm$ implies $\aForm'$.
% \end{itemize}
% Weakest preconditions are \emph{sound} in that if $\aForm$ holds in the
% initial state $\aState$, then $\bForm$ holds in the final state $\bState$.
% Formally, 


\begin{comment}
  If $\aPS\in\sem{\aCmd}$ is top-level and quiescent then 
  $\aTr{\aEvs}{\bForm}$ implies $\fwp{\aCmd}{\bForm}$.

  For any substitution $\aSub=[{v_1/r_1},\ldots, {v_n/r_n}]$ there is some
  $\aPS\in\sem{\aCmd}$ %that is top-level and quiescent
  such that all preconditions in $\aPS\aSub$ are tautologies then 
  $\fwp{\aCmd}{\bForm}\aSub$
\end{comment}


% For a language where all programs are
% terminating, we have for any statement $\aCmd$:
% \begin{align*}
%   \hoare{\aForm}{\aCmd}{\bForm} 
%   \;\;\Leftrightarrow\;\;
%   \aForm \textimplies \fwp{\aCmd}{\bForm}
% \end{align*}
% Interpretation is that if $\aState\models\fwp{\aCmd}{\bForm}$ and
% $\bigstep{\aState}{\aCmd}{\rho}$
% then $\bState\models\bForm$.

% Let $\aCmd_0$ be
% \begin{math}
%   \PW{\aLoc_1}{\aVal_1}\SEMI\cdots\SEMI \PW{\aLoc_n}{\aVal_n}, 
% \end{math}
% such that $\fwp{\aCmd_0}{\aForm}$ is a tautology, and $\aLoc_i=\aLoc_j$
% implies $i=j$.

% Let $\aSub_\aPS=[{\aVal_1/\aLoc_1},\ldots, {\aVal_n/\aLoc_n}]$ be the final
% state of $\aPS$.

% Let $\aState$ and $\rho$ range over substitutions $\Loc\fun\Exp$.
% If we leave the registers free, we have:
% \begin{align}
%   \label{wp1x}
%   \bigstep{[2/x]}{\aCmd&}{[6/x]}
% \end{align}

% Using \refdef{def:pomsets-trans}:
% \begin{align*}
%   \begin{gathered}[t]
%     %     \PR{x}{s}\SEMI\PW{x}{s{+}r}
%     \PR{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%       \event{a}{\DR{x}{2}}{}
%       \xform{xi}{\bForm}{above=of a}
%       \xform{xd}{2{=}s \limplies \bForm}{below=of a}
%       \xo[xright]{a}{xd}
%     \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}[t]
%     \PW{x}{s{+}r}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%       \event{a}{(s{+}r){=}7\bigmid\DW{x}{7}}{}
%       \xform{xi}{\bForm}{above=of a}
%       \xform{xd}{\bForm}{below=of a}
%       \xo[xright]{a}{xd}
%     \end{tikzinline}}
%   \end{gathered}
% \end{align*}
% Composing
% \begin{align*}
%   \begin{gathered}[t]
%     \PR{x}{s}\SEMI\PW{x}{s{+}r}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%       \event{a}{\DR{x}{2}}{}
%       \event{b}{(s{+}r){=}7\bigmid\DW{x}{7}}{right=of a}
%       \xform{xdd}{2{=}s \limplies \bForm}{above=of a}
%       \xform{xdi}{2{=}s \limplies \bForm}{below=of a}
%       \xform{xii}{\bForm}{above=of b}
%       \xform{xid}{\bForm}{below=of b}
%       \xo[xright]{a}{xdi}
%       \xo[xright]{b}{xid}
%       \xo[xright]{a}{xdd}
%       \xo[xright]{b}{xdd}
%     \end{tikzinline}}
%   \end{gathered}
% \end{align*}

% Using \refdef{def:pomsets-lir}:
% \begin{align*}
%   \begin{gathered}[t]
%     %     \PR{x}{s}\SEMI\PW{x}{s{+}r}
%     \PR{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%       \event{a}{\DR{x}{2}}{}
%       \xform{xi}{(2{=}s\lor x{=}s)\limplies \bForm}{above=of a}
%       \xform{xd}{2{=}s \limplies \bForm}{below=of a}
%       \xo[xright]{a}{xd}
%     \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}[t]
%     \PW{x}{s{+}r}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%       \event{a}{(s{+}r){=}7\bigmid\DW{x}{7}}{}
%       \xform{xi}{\bForm[s{+}r/x]}{above=of a}
%       \xform{xd}{\bForm[s{+}r/x]}{below=of a}
%       \xo[xright]{a}{xd}
%     \end{tikzinline}}
%   \end{gathered}
% \end{align*}
% Composing

% For example, let $\aCmd_1=\PR{x}{r}$ and $\aCmd_2=\PW{x}{r{+}1}$ and
% $\aCmd=\aCmd_1\SEMI \aCmd_2$.
% \begin{align*}
%   \fwp{\aCmd_2}{x{>}1}&=(r{+}1{>}1) = (r{>}0)
%   \\
%   \fwp{\aCmd_1}{r{>}0}=\fwp{\aCmd_0}{x{>}1}&=(x{>}0)
% \end{align*}
% Let $\aPS_i\in\sem{\aCmd_i}$.
% \begin{align*}
%   \aTr[2]{\aEvs_2}{x{>}1}&=(r{+}1{>}1) = (r{>}0)
%   \\
%   \aTr[0]{\aEvs_0}{x{>}1}&=(0{=}\aReg \limplies r{>}0)
%   \\
%   \aTr[0]{\aEvs_0}{x{>}1}&=(1{=}\aReg \limplies r{>}0)
%   \\
%   \aTr[0]{\aEvs_0}{x{>}1}&=(2{=}\aReg \limplies r{>}0)
% \end{align*}

% \begin{proposition}
%   If $\aPS\in\sem{\aCmd}$ is top-level and quiescent then 
%   $\aTr{\aEvs}{\aForm}$ implies $\fwp{\aCmd}{\aForm}$.

%   For any substitution $\aSub=[{\aVal_1/\aReg_1},\ldots, {\aVal_n/\aReg_n}]$ there is some
%   $\aPS\in\sem{\aCmd}$ %that is top-level and quiescent
%   such that all preconditions in $\aPS\aSub$ are tautologies then 
%   $\fwp{\aCmd}{\aForm}\aSub$
% \end{proposition}


\begin{comment}
Dead Store Elimination (Still) Considered Harmful

DSE "removes stores that have no effect on the program result, either
because the stored value is overwritten or because it is never read again."

The example they give is of the second type: "because it is never read
again".  To validate this, we would need a more complex model of memory
using provenance for pointers...

Section 3.3.3 (Volatile Function Pointer) has a lovely example of
if-introduction: Compilers are not allowed to get rid of calls through
virtual functions, but they can use if-introduction and then get rid of the
static call that they introduce on one side of the if/else...

Possibly interesting references:

[28] N. Benton. Simple relational correctness proofs for static analyses and program transformations. In ACM SIGPLAN Notices, volume 39, pages 14–25, 2004.
[29] C. Deng and K. S. Namjoshi. Securing a compiler transformation. In Proceedings of the 23rd Static Analysis Symposium, SAS ’16, pages 170– 188, 2016.
[30] V. D’Silva, M. Payer, and D. Song. The correctness-security gap in compiler optimization. In Security and Privacy Workshops, SPW ’15, pages 73–87, 2015.
[31] X. Leroy. Formal certification of a compiler backend or: programming a compiler with a proof assistant. In ACM SIGPLAN Notices, volume 41, pages 42–54, 2006.
\end{comment}

% \subsection{Post-Hoc Verification of Fulfillment for \PwTmcaTITLE{2}}
% \label{sec:post-hoc}

\subsection{Register Consistency}
\label{sec:false}


% If a precondition is false, you can be pretty sure it's useless.  In this
% subsection, we develop a criterion for eliminating such useless pomsets.

% To achieve this, we would like to bolt a requirement into the definition of
% pomsets in order to weed out the useless ones.  Something like this:
% \begin{enumerate}
% \item[{\labeltext[\textsc{m}3a$'$]{(\textsc{m}3a$'$)}{pom-kappa-sat'}}]
%   $\labelingForm(\aEv)$ is satisfiable.
% \end{enumerate}
% For associativity, \eqref{pom-kappa-sat'} would in turn require

In addition to the three criteria of \refdef{def:trans}
\citet{DBLP:journals/cacm/Dijkstra75} requires
\begin{enumerate}
\item[{\labeltext[\textsc{x}4$'$]{(\textsc{x}4$'$)}{tr-false'}}]
  $\aTr{}{\FALSE}\riff\FALSE$.
\end{enumerate}
% \citet{DBLP:journals/cacm/Dijkstra75} requires exactly \ref{tr-false'}.
% Problem solved!  
Unfortunately, our transformer for read actions
\eqref{read-tau-dep} does not obey \ref{tr-false'}, since $\FALSE$ is not
equivalent to $v{=}r\limplies\FALSE$.

In this subsection, we refine this requirement to one that does hold.  The
main insight is to pull values for registers from the actions of pomset itself.
%
% \eqref{tr-false'} is too strong.
% We say $\aForm$ \emph{conjunctively depends on $\uReg{\aEv}$}
% if $\aForm\rnotimplies\aForm[\aVal/\uReg{\aEv}]$
% %or $\aForm[\aVal/\uReg{\aEv}]\rnotimplies\aForm$,
% for some $\aVal$.
% We say that $\aForm$ \emph{cannot contribute to a top-level tautology} if
% $\aForm\riff\bigvee_{\aEv\in\aEvs}\aForm_\aEv$ where (for every $\aEv$) either
% $\aForm_\aEv\riff\FALSE$ or $\aForm_\aEv$ conjunctively depends on $\uReg{\aEv}$.
%
% We require the following:
% \begin{enumerate}
% \item[{\labeltext[\textsc{x}4]{(\textsc{x}4)}{tr-false}}]
%   $\aTr{}{\FALSE}$ cannot contribute to a top-level tautology.
% \end{enumerate}
%
% When put in \DNF, $\aTr{}{\FALSE}$ look like this (taking independent case
% for both reads):
% \begin{gather*}
%   \IF{r}\THEN \PR{x}{s_d} \ELSE \PR{y}{s_e} \FI
%   \\
%   (r{\neq}0 \land s_d{\neq}v_d \land s_d{\neq}x)
%   \lor  
%   (r{=}0 \land s_e{\neq}v_e \land s_e{\neq}y)  
% \end{gather*}
%
Thus, we define $\regForm{\labeling}$ to capture the \emph{register state} of a pomset.
\begin{definition}  
  \label{def:labeling:consistent}
  Let 
  \begin{math}
    \regForm{\labeling}=
    \textstyle\bigwedge_{\{(\aEv,\aVal)\in(\aEvs\times\Val)\mid\labeling(\aEv)=\DRP{}{\aVal}\}}(\uReg{\aEv}\EQ\aVal)
    \textwhere \aEvs=\fdom(\labeling)
  \end{math}.
  
  We say that $\aForm$ is \emph{$\labeling$-consistent} if $\aForm\land\regForm{\labeling}$ is satisfiable.
  We say that it is \emph{$\labeling$-inconsistent} otherwise.
\end{definition}


%tau maps (things incompatible with chi) to (things incompatible with chi)
Using this, we define the constraint on predicate transformers that we want.
We also need to update the definition of predicate transformer families to
carry the labeling.
\begin{definition}
  \label{def:trans'}
  A \emph{$\labeling$-predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{enumerate}[,label=(\textsc{x}\arabic*),ref=\textsc{x}\arabic*]
  % \item \label{tr-implies'}
  %   \labeltextXX{2}{x}{tr-and'}
  %   \labeltextXX{3}{x}{tr-or'} as in \refdef{def:trans},
  \item[\eqref{tr-and}]
    \eqref{tr-or}\;
    \eqref{tr-implies}\; as in \refdef{def:trans},
  \item[{\labeltext[\textsc{x}4]{(\textsc{x}4)}{tr-false}}] 
    % \item[\eqref{tr-false}]
    if $\bForm$ is $\labeling$-inconsistent then $\aTr{}{\bForm}$ is $\labeling$-inconsistent.
  \end{enumerate}

  \label{def:family'}
  A \emph{family of $\labeling$-predicate transformers} over consists of a
  $\labeling$-predicate transformer $\aTr{\bEvs}{}$ for each
  $\bEvs\subseteq\AllEvents$, such that if $\cEvs \cap \aEvs \subseteq \bEvs$
  then $\aTr{\cEvs}{\bForm} \rimplies \aTr{\bEvs}{\bForm}$.

  
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
  \setcounter{enumi}{\value{Btau}}
  \item \label{pom-tau'}
    $\aTr{}{}:2^{\AllEvents}\fun\Formulae \fun\Formulae$ is a \emph{family of $\labeling$-predicate transformers}, 
  \end{enumerate}
\end{definition}

% Given these definitions, we can add the following requirement to the model,
% which enables us to prune pomsets that include $\labeling$-inconsistent
% preconditions and termination conditions.
% \begin{multicols}{2}
%   \begin{enumerate}
%     % \item[{\labeltext[\textsc{x}4]{(\textsc{x}4)}{tr-false}}] if $\bForm$ is
%     %   $\labeling$-inconsistent, then $\aTr{}{\bForm}$ is $\labeling$-inconsistent.
%   \item[{\labeltext[\textsc{m}3a]{(\textsc{m}3a)}{pom-kappa-sat}}]
%     $\labelingForm(\aEv)$ is $\labeling$-consistent,
%   \item[{\labeltext[\textsc{m}5b]{(\textsc{m}5b)}{pom-term-sat}}]
%     $\aTerm$ is $\labeling$-consistent.
%   \end{enumerate}
% \end{multicols}
% With this modification, dead-code elimination
% (\reflem{lem:if}\ref{lem:if:dead}) can be changed from an inclusion to an equation:
% \begin{displaymath}
%   \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
%   =
%   \aPSS_1
%   \;\text{if $\aForm$ is a tautology.}
% \end{displaymath}


It would seem reasonable to require that $\labelingForm(\aEv)$ be
$\labeling$-consistent.  However, this breaks associativity.  Compare the
following, where $\uReg{e}=r$:
\begin{align*}
  \begin{gathered}[t]
    \PR{y}{r}
    \SEMI
    \IF{r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventl{e}{a}{\DR{y}{1}}{}
        \event{b}{r{\neq}0\bigmid\DW{x}{1}}{right=of a}
        %\xform{xi}{\bForm[\uReg{e}/r]}{left=.5em of a}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{c}{r{=}0\bigmid\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
and
\begin{align*}
  \begin{gathered}[t]
    \PR{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventl{e}{a}{\DR{y}{1}}{}
        %\xform{xi}{\bForm[\uReg{e}/r]}{left=.5em of a}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{r}\THEN\PW{x}{1}\FI
    \SEMI
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{c}{\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}

It would also seem reasonable to require that $\aTerm$ be
$\labeling$-consistent in all pomsets.  However, doing so is incompatible
with our approach to untaken conditionals.  Consider that the empty pomset is
in the semantics of $\IF{\FALSE}\THEN\PW{x}{1}\FI$.  In order to construct
the final pomset with $\aTerm\riff\TRUE$, we must allow the
intermediate pomset with $\aTerm\riff\FALSE$.


% \todo{Drop \ref{pom-kappa-sat} and m5b---they are wrong.  Move this into a
%   discussion of the proof of compilation correctness.}


\subsection{The Need for Respect}
In \reffig{fig:seq}, we choose the weakest precondition.  Because of this,
associativity requires that \ref{seq-le} is $\PBR{{\lt}\rextends{\lt_1}{\lt_2}}$
rather than $\PBR{{\lt}\rsupset{\lt_1}{\lt_2}}$.  Consider
\begin{math}
  \PBR{
    \PR{x}{r}
    \SEMI
    \PW{y}{\aExp}
    \SEMI
    \SKIP
  }.
\end{math}
Associating to the left, we might have:
\begin{align*}
  \aPS_{12}=
  \hbox{\begin{tikzinline}[node distance=1em]
      \eventr{d}{d}{\DR{x}{}}{}
      \eventr{e}{e}{\aForm\bigmid \DW{y}{}}{right=of d}
    \end{tikzinline}}
  &&
  \aPS_{3}= \emptyset
  &&
  \aPS=
  \hbox{\begin{tikzinline}[node distance=1em]
      \eventr{d}{d}{\DR{x}{}}{}
      \eventr{e}{e}{\aForm\bigmid \DW{y}{}}{right=of d}
      \po{d}{e}
    \end{tikzinline}}
\end{align*}
When building $\aPS_{12}$, the dependent set of $e$ would be the empty set, and thus
$\aForm$ must have been constructed using the independent transformer
\ref{read-tau-ind}.  Attempting to repeat this, associating to the right:
\begin{align*}
  \aPS_{1}=
  \hbox{\begin{tikzinline}[node distance=1em]
      \eventr{d}{d}{\DR{x}{}}{}
    \end{tikzinline}}
  &&
  \aPS_{23}=
  \hbox{\begin{tikzinline}[node distance=1em]
      \eventr{e}{e}{\aForm'\bigmid \DW{y}{}}{}
    \end{tikzinline}}
  &&
  \aPS'=
  \hbox{\begin{tikzinline}[node distance=1em]
      \eventr{d}{d}{\DR{x}{}}{}
      \eventr{e}{e}{\aForm'\bigmid \DW{y}{}}{right=of d}
      \po{d}{e}
    \end{tikzinline}}
\end{align*}
In $\aPS'$, however, now the dependent set of $e$ is the singleton $\{d\}$; thus $\aForm'$ must be
constructed using the dependent transformer \ref{read-tau-dep}.
Since
\begin{math}
  \PBR{
    \PBR{\aVal{=}\aReg \lor \aLoc{=}\aReg}
    \limplies \bForm
  }
  \not\riff
  \PBR{
    \aVal{=}\aReg
    \limplies \bForm
  },
\end{math}
associativity fails.

If we allow stronger preconditions, as in
\cite{DBLP:journals/pacmpl/JagadeesanJR20}, then we could use inclusion
rather than $\rextendsdef{}{}$.  To arrive at this semantics, one would
replace every occurrence of $\riff$ in \reffig{fig:seq} with $\rimplies$.
Then $\PBR{{\lt}\rextends{\lt_1}{\lt_2}}$ can be replaced by
$\PBR{{\lt}\rsupset{\lt_1}{\lt_2}}$.

\subsection{Write Substitutions}

In the predicate transformer for $\PW{x}{\aExp}$, we substitute $\aExp$ for
$x$.  In an alternative semantics, one could substitute the value chosen for
the action.  This alternative semantics looses dependencies.  Consider:
\begin{gather*}
  \PR{x}{s}\SEMI \PW{z}{s}
  \\
  \hbox{\begin{tikzinline}[node distance=.8em and 1em]
      \event{a3}{\DR{x}{1}}{}
      \event{a4}{\PBR{1{=}s \lor x{=}s} \limplies s\EQ1\bigmid\DW{z}{1}}{right=of a3}
    \end{tikzinline}}
\end{gather*}
Prepending a write and then a read, our semantics gives the following:
\begin{align*}
  \begin{gathered}
    \PW{x}{r} \SEMI \PR{x}{s}\SEMI \PW{z}{s}
    \\
    \hbox{\begin{tikzinline}[node distance=.8em and 1em]
        \event{a2}{\DW{x}{1}}{}
        \event{a3}{\DR{x}{1}}{right=of a2}
        \event{a4}{\PBR{1{=}s \lor r{=}s} \limplies s\EQ1\bigmid\DW{z}{1}}{right=of a3}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PR{y}{r}\SEMI \PW{x}{r}\SEMI \PR{x}{s} \SEMI \PW{z}{s}
    \\
    \hbox{\begin{tikzinline}[node distance=.8em and 1em]
        \event{a1}{\DR{y}{1}}{}
        \event{a2}{\DW{x}{1}}{right=of a1}
        \event{a3}{\DR{x}{1}}{right=of a2}
        \event{a4}{\DW{z}{1}}{right=of a3}
        \po[out=15,in=165]{a1}{a4}
        \po{a1}{a2}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
With the alternative semantics, instead, we would have:
\begin{align*}
  \begin{gathered}
  \hbox{\begin{tikzinline}[node distance=.8em and 1em]
      \event{a2}{\DW{x}{1}}{}
      \event{a3}{\DR{x}{1}}{right=of a2}
      \event{a4}{\PBR{1{=}s \lor 1{=}s} \limplies s\EQ1\bigmid\DW{z}{1}}{right=of a3}
    \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PR{y}{r}\SEMI \PW{x}{r}\SEMI \PR{x}{s} \SEMI \PW{z}{s}
    \\
    \hbox{\begin{tikzinline}[node distance=.8em and 1em]
        \event{a1}{\DR{y}{1}}{}
        \event{a2}{\DW{x}{1}}{right=of a1}
        \event{a3}{\DR{x}{1}}{right=of a2}
        \event{a4}{\DW{z}{1}}{right=of a3}
        % \po[out=15,in=165]{a1}{a4}
        \po{a1}{a2}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
The dependency from $\DR{y}{1}$ to $\DW{z}{1}$ has been lost.


\subsection{Read Substitutions}
\label{sec:substitutions}

In $\sLOAD{}{}$, it is also possible to collapse $\aLoc$ and $\aReg$ via substitution:
\begin{enumerate}
\item[{\labeltext[\textsc{r}4a$'$]{(\textsc{r}4a$'$)}{read-tau-dep-sub}}]
  if $(\aEvs\cap\bEvs)\neq\emptyset$ then
  \begin{math}
    \aTr{\bEvs}{\bForm} \riff
    \aVal{=}\aReg
    \limplies \bForm[\aReg/\aLoc]
  \end{math},    
\item[{\labeltext[\textsc{r}4b$'$]{(\textsc{r}4b$'$)}{read-tau-ind-sub}}]
  if $\aEvs\neq\emptyset$ and $(\aEvs\cap\bEvs)=\emptyset$ then
  \begin{math}
    \aTr{\bEvs}{\bForm} \riff
    \PBR{\aVal{=}\aReg \lor \aLoc{=}\aReg} \limplies
    \bForm[\aReg/\aLoc],
  \end{math}
\item[{\labeltext[\textsc{r}4c$'$]{(\textsc{r}4c$'$)}{read-tau-empty-sub}}]
  if $\aEvs=\emptyset$ then
  \begin{math}
    \aTr{\bEvs}{\bForm} \riff
    % \PBR{\aVal{=}\aReg \lor \aLoc{=}\aReg} \limplies
    \bForm[\aReg/\aLoc],
  \end{math}
\end{enumerate}
Perhaps surprisingly, this semantics is incomparable with that of
\reffig{fig:seq}.  Consider the following:
\begin{gather*}
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a3}{r\land s\;\mathsf{even}\bigmid\DW{y}{1}}{}
      \event{a4}{r\land s\bigmid\DW{z}{1}}{right=of a3}
    \end{tikzinline}}
\end{gather*}
Prepending $\PRP{x}{s}$, we get the same result regardless of whether we
substitute $[s/x]$, since $x$ does not occur in either precondition.  Here
we show the independent case:
\begin{gather*}
  \PR{x}{s}\SEMI
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a2}{\DR{x}{2}}{}
      \event{a3}{(2{=}s\lor x{=}s)\limplies (r\land s\;\mathsf{even})\bigmid\DW{y}{1}}{right=of a2}
      \event{a4}{(2{=}s\lor x{=}s)\limplies (r\land s)\bigmid\DW{z}{1}}{right=of a3}
    \end{tikzinline}}
\end{gather*}
Since the preconditions mention $x$, prepending $\PRP{x}{r}$, we now get
different results depending on whether we perform the substitution.  Without
any substitution, we have:
\begin{gather*}
  \PR{x}{r}\SEMI
  \PR{x}{s}\SEMI
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\[-2ex]
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DR{x}{2}}{right=of a1}
      \event{a3}{1{=}r\limplies  (2{=}s\lor x{=}s)\limplies (r\land s\;\mathsf{even})\bigmid\DW{y}{1}}{right=of a2}
      \event{a4}{1{=}r\limplies  (2{=}s\lor x{=}s)\limplies (r\land s)\bigmid\DW{z}{1}}{right=of a3}
      \po[out=12,in=168]{a1}{a3}
      \po[out=10,in=170]{a1}{a4}
    \end{tikzinline}}
\end{gather*}
Prepending $\PWP{x}{0}$, which substitutes $[0/x]$, the precondition of
$\DWP{y}{1}$ becomes
$(1{=}r\limplies (2{=}s\lor0{=}s)\limplies (r\land s\;\mathsf{even}))$, which
is a tautology, whereas the precondition of $\DW{z}{1}$ becomes
$(1{=}r\limplies(2{=}s\lor0{=}s)\limplies (r\land s))$, which is not.  In
order to be top-level, $\DWP{z}{1}$ must be dependency ordered after
$\DRP{x}{2}$; in this case the precondition becomes
$(1{=}r\limplies2{=}s\limplies (r\land s))$, which is a tautology.
\begin{gather*}
  % \PW{x}{0}\SEMI
  % \PR{x}{r}\SEMI
  % \PR{x}{s}\SEMI
  % \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  % \IF{r\land s}\THEN \PW{z}{1}\FI
  % \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a0}{\DW{x}{0}}{}
      \event{a1}{\DR{x}{1}}{right=of a0}
      \event{a2}{\DR{x}{2}}{right=of a1}
      \event{a3}{\DW{y}{1}}{right=of a2}
      \event{a4}{\DW{z}{1}}{right=of a3}
      % \wk{a0}{a1}
      % \wk[out=-20,in=-160]{a0}{a2}
      \po[out=20,in=160]{a1}{a3}
      \po[out=20,in=160]{a1}{a4}
      \po[out=-20,in=-160]{a2}{a4}
    \end{tikzinline}}
\end{gather*}
The situation reverses with the substitution $[r/x]$:
\begin{gather*}
  \PR{x}{r}\SEMI
  \PR{x}{s}\SEMI
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\[-2ex]
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DR{x}{2}}{right=of a1}
      \event{a3}{1{=}r\limplies  (2{=}s\lor r{=}s)\limplies (r\land s\;\mathsf{even})\bigmid\DW{y}{1}}{right=of a2}
      \event{a4}{1{=}r\limplies  (2{=}s\lor r{=}s)\limplies (r\land s)\bigmid\DW{z}{1}}{right=of a3}
      \po[out=12,in=168]{a1}{a3}
      \po[out=10,in=170]{a1}{a4}
    \end{tikzinline}}
\end{gather*}
Prepending $\PWP{x}{0}$:
%\vspace{-.5\baselineskip}
\begin{gather*}
  % \PW{x}{0}\SEMI
  % \PR{x}{r}\SEMI
  % \PR{x}{s}\SEMI
  % \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  % \IF{r\land s}\THEN \PW{z}{1}\FI
  % \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a0}{\DW{x}{0}}{}
      \event{a1}{\DR{x}{1}}{right=of a0}
      \event{a2}{\DR{x}{2}}{right=of a1}
      \event{a3}{\DW{y}{1}}{right=of a2}
      \event{a4}{\DW{z}{1}}{right=of a3}
      % \wk{a0}{a1}
      % \wk[out=-20,in=-160]{a0}{a2}
      \po[out=20,in=160]{a1}{a3}
      \po[out=20,in=160]{a1}{a4}
      \po{a2}{a3}
    \end{tikzinline}}
\end{gather*}
The dependency has changed from $\DRP{x}{2}\xpo\DWP{z}{1}$ to
$\DRP{x}{2}\xpo\DWP{y}{1}$.  The resulting sets of pomsets are
incomparable.


Thinking in terms of hardware, the difference is whether reads update the
cache, thus clobbering preceding writes.  With $[r/x]$, reads clobber the
cache, whereas without the substitution, they do not.  Since most caches work
this way, the model with $[r/x]$ is likely preferred for modeling hardware.
However, this substitution only makes sense in a model with read-read
coherence and read-read dependencies, which is not the case for \armeight{}.  





% \begin{figure*}[t]
%   \showRAtrue
%   \begin{center}
%     \begin{minipage}{.91\textwidth}
%       \input{fig-no-q-or-addr.tex}
%     \end{minipage}
%   \end{center}
%   \caption{Simplified Quiescence Semantics w/o Address Calculation
%     (See %\refdef{def:QSx} for $\QS{}{\amode}$, $\QL{}{\amode}$, and
%     \refdef{def:dlx} for $\DLX{\aLoc}{\amode}{\bmode}$, $\DS{\aLoc}{\amode}$)
%   } 
%   \label{fig:no-q-or-addr}
% \end{figure*}    
% \begin{figure*}
%   \begin{center}
%     \begin{minipage}{.91\textwidth}
%       \input{fig-full.tex}
%       % \input{fig-full-where.tex}
%       % \input{fig-full-noco.tex}
%     \end{minipage}
%   \end{center}
%   \caption{Full Semantics with Address Calculation
%     (See \refdef{def:QS} for $\QS{\aLoc}{\amode}$, $\QL{\aLoc}{\amode}$
%     and \refdef{def:DS} for $\DL{\aLoc}{\amode}$, $\DS{\aLoc}{\amode}$)
%   }
%   \label{fig:full}
% \end{figure*}    

%\section{Discussion}
\subsection{Downset Closure}
\label{sec:downset}

% We would like the semantics to be closed with respect to \emph{augments} and
% \emph{downsets}.

% Augments include more order and stronger formulae; in examples, we typically
% consider pomsets that are augment-minimal.  One intuitive reading of augment
% closure is that adding order can only cause preconditions to weaken.
% \begin{definition}
%   \label{def:augment}
%   $\aPS_2$ is an \emph{augment} of $\aPS_1$ if
%   \begin{enumerate}
%   \item $\aEvs_2=\aEvs_1$,
%   \item $\labelingAct_2(\aEv)=\labelingAct_1(\aEv)$,
%   \item $\labelingForm_2(\aEv) \rimplies \labelingForm_1(\aEv)$,
%   \item $\aTr[2]{\bEvs}{\aEv} \rimplies \aTr[1]{\bEvs}{\aEv}$,
%   \item if $\bEv\le_2\aEv$ then $\bEv\le_1\aEv$.
%   \end{enumerate}
% \end{definition}

% \begin{proposition}
%   %   Suppose $\aPS_1\in\sem{\aCmd}$.
%   If $\aPS_1\in\sem{\aCmd}$ and $\aPS_2$  augments $\aPS_1$ then $\aPS_2\in\sem{\aCmd}$.
%   % \item If $\aPS_2$ is a downset of $\aPS_1$ then $\aPS_2\in\sem{\aCmd}$.
%   % \end{enumerate}
% \end{proposition}

We would like the semantics to be closed with respect to \emph{downsets}.
Downsets include a subset of initial events, similar to \emph{prefixes} for
strings.
\begin{definition}
  \label{def:downset}
  $\aPS_2$ is an \emph{downset} of $\aPS_1$ if
  \begin{multicols}{2}
    \begin{enumerate}
    \item $\aEvs_2\subseteq\aEvs_1$,
    \item $(\forall \aEv\in\aEvs_2)$ $\labelingAct_2(\aEv)=\labelingAct_1(\aEv)$,
    \item $(\forall \aEv\in\aEvs_2)$ $\labelingForm_2(\aEv)\riff\labelingForm_1(\aEv)$,
    \item $(\forall \aEv\in\aEvs_2)$ $\aTr[2]{\bEvs}{\aEv}\riff\aTr[1]{\bEvs}{\aEv}$,
    \item $\aTerm[2] \rimplies \aTerm[1]$,
      \stepcounter{enumi}
    \item[] 
      \begin{enumerate}[leftmargin=0pt]
      \item $(\forall \bEv\in\aEvs_2)$ $(\forall \aEv\in\aEvs_2)$ $\bEv\lt_2\aEv$ iff $\bEv\lt_1\aEv$,
      \item $(\forall \bEv\in\aEvs_1)$ $(\forall \aEv\in\aEvs_2)$ if
        $\bEv\lt_1\aEv$ then $\bEv\in\aEvs_2$,
      \end{enumerate}
    \item $(\forall \bEv\in\aEvs_2)$ $(\forall \aEv\in\aEvs_2)$ $\bEv\rrfx_2\aEv$ iff $\bEv\rrfx_1\aEv$.
    \end{enumerate}
  \end{multicols}
\end{definition}

Downset closure fails due to for two reasons.  The key property is that the
empty set transformer should behave the same as the independent transformer.

First, downset closure fails for read-read independency \textsection\ref{sec:read-read}.
  % For \xRRD{}, \refdef{def:pomsets-rr} states:
  % \begin{enumerate}
  % \item[\ref{L4})]
  %   $\aTr{\bEvs}{\bForm} \rimplies \aVal{=}\aReg\limplies\bForm$, 
  % \item[\ref{L5})]
  %   $\aTr{\cEvs}{\bForm} \rimplies (\aVal{=}\aReg\lor\RW)\limplies\bForm$,
  % \item[\ref{L6})] 
  %   $\aTr{\dEvs}{\bForm} \rimplies \bForm$, when $\aEvs=\emptyset$.
  % \end{enumerate}
  % This semantics is not downset closed due to the lack of read-read dependencies.
  % In both cases, for subsequent writes, \ref{L5} is the same as \ref{L6}.  For
  % subsequent reads, \ref{L5} is the same as \ref{L4}.
Consider
\begin{gather*}
  \begin{gathered}[t]
    \PR{x}{r}\SEMI\IF{\BANG r}\THEN\PR{y}{s}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a}{\DR{x}{0}}{}
        \event{b}{\DR{y}{0}}{right=of a}
      \end{tikzinline}}
  \end{gathered}    
\end{gather*}
The semantics of this program includes the singleton pomset $\DRP{x}{0}$,
but not the singleton pomset $\DRP{y}{0}$.
To get $\DRP{x}{0}$, we combine:
\begin{align*}
  \begin{gathered}[t]
    \PR{x}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a}{\DR{x}{0}}{}
      \end{tikzinline}}
  \end{gathered}    
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN\PR{y}{s}\FI
    \\
    \emptyset
  \end{gathered}    
\end{align*}
Attempting to get $\DRP{y}{0}$, we instead get:
\begin{align*}
  \begin{gathered}[t]
    \PR{x}{r}
    \\
    \emptyset
  \end{gathered}    
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN\PR{y}{s}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{b}{r\EQ0\bigmid\DR{y}{0}}{}
      \end{tikzinline}}
  \end{gathered}    
\end{align*}
Since $r$ appears only once in the program, this pomset cannot contribute
to a top-level pomset.


Second, the semantics is not downset closed because the independency reasoning of
\ref{read-tau-ind} is only applicable for pomsets where the ignored read is present!
Revisiting \jmm{} causality test case 1 from the end of \textsection\ref{sec:ex:control}:
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{0} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a0}{\DW{x}{0}}{}
        \xform{xi}{\bForm[0/x]}{below=of a0}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PR{x}{r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DR{x}{1}}{}
        \xform{xi}{(1{=}r\lor x{=}r)\limplies\bForm}{below=of a1}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{r{\geq}0}\THEN \PW{y}{1} \FI
    \SEMI
    \PW{z}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a2}{r{\geq}0\bigmid\DW{y}{1}}{}      
        \event{a3}{r{=}1\bigmid\DW{z}{1}}{right=of a2}      
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
% Composing:
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{0} 
    \SEMI\PR{x}{r} 
    \SEMI\IF{r{\geq}0}\THEN \PW{y}{1} \FI
    \SEMI
    \PW{z}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a0}{\DW{x}{0}}{}
        \event{a1}{\DR{x}{1}}{right=of a0}
        \event{a2}{(1{=}r\lor 0{=}r)\limplies r{\geq}0\bigmid\DW{y}{1}}{right=of a1}      
        \event{a3}{1{=}r\limplies r{=}1\bigmid\DW{z}{1}}{right=of a2}
        \po[out=15,in=165]{a1}{a3}
        \wki{a0}{a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
The precondition of $\DWP{y}{1}$ is a tautology.

Taking the empty set for the read, however,
the precondition of $\DWP{y}{1}$ is not a tautology:
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{0} 
    \SEMI\PR{x}{r} 
    \SEMI\IF{r{\geq}0}\THEN \PW{y}{1} \FI
    \SEMI
    \PW{z}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a0}{\DW{x}{0}}{}
        % \event{a1}{\DR{x}{1}}{right=of a0}
        \event{a2}{r{\geq}0\bigmid\DW{y}{1}}{right=6em of a0}      
        \event{a3}{r{=}1\bigmid\DW{z}{1}}{right=of a2}
        % \wk{a0}{a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
One way to deal with the second issue would be to allow general access
elimination to merge $\DWP{x}{0}$ and $\DRP{x}{0}$:
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{0} 
    \SEMI\PR{x}{r} 
    \SEMI\IF{r{\geq}0}\THEN \PW{y}{1} \FI
    \SEMI
    \PW{z}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a0}{\DW{x}{0}}{}
        %\event{a1}{\DR{x}{1}}{right=of a0}
        \event{a2}{(0{=}r\lor 0{=}r)\limplies r{\geq}0\bigmid\DW{y}{1}}{right=6em of a0}      
        \event{a3}{r{=}1\bigmid\DW{z}{1}}{right=of a2}
        %\po[out=-15,in=-165]{a1}{a3}
        %\wki{a0}{a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
We leave the elaboration of this idea to future work.

\begin{comment}
  if in L6 we said [x/r], that says we know read the local version...  ignoring
  the value read...  Perhaps there is some intervening stuff that stops you
  from seeing the local state, such as release-acquire

  We could potentially get rid of [x/r] If you do two reads, your not allowed
  to be independent of the second based on the value that was read in the first
  read.

  x=0; r=x; if (r=1) { s=x; if (s=?) {y=1}}
  read 1 then 2.


  In order for the write to be independent of second read what does its
  precondition have to be.
  [r/x] then s==1
  no sub then s==0

  (s=? | Wy1)

  if (phi) z=1
  phi = s is even
  phi = s < 2

  With substitution you are saying you know that the ``local copy'' of x is the
  same as r.  Sitting in the local cache.  Read might have gone to main
  memory, but if it did it has updated the cache line so that the local copy is
  what I just read.

  If second read is a cache hit, then I know that I am seeing the same value.

  If we take substitution out then 
\end{comment}

\subsection{Logical Encoding of Delay for \PwTmcaTITLE{}}
\label{sec:delay}

In this subsection, we develop a logical encoding of $\rdelay$, which can
replace \ref{seq-le-delays} in \PwTmca{1}.  It is not obvious how to repeat
this trick for \PwTmca{2}, due to thread-local reads-from
(\ref{seq-le-delays-rf} in \refdef{def:pwt:mca2}).

As motivation, recall that we stated 
\reflem{lem:if}\eqref{lem:ifelse:if:if} %--\eqref{lem:ifelse:if:if2}
using inclusions:
\begin{enumerate}
  \item[\eqref{lem:ifelse:if:if}]
    \begin{math}
      \sem{\xSEMI{
        \xIFTHEN{\lnot\aForm}{\aCmd_2}{}
      }{
        \xIFTHEN{\aForm}{\aCmd_1}{}
      }}
      \subseteq
      \sem{\xIFTHEN{\aForm}{\aCmd_1}{\aCmd_2}}
      \supseteq
      \sem{\xSEMI{
        \xIFTHEN{\aForm}{\aCmd_1}{}
      }{
        \xIFTHEN{\lnot\aForm}{\aCmd_2}{}
      }}.
    \end{math}
  
% \item[\eqref{lem:ifelse:if:if1}]
%   \begin{math} 
%     \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
%     \supseteq
%     \xSEMI{
%       \xIFTHEN{\aForm}{\aPSS_1}{}
%     }{
%       \xIFTHEN{\lnot\aForm}{\aPSS_2}{}
%     }.
%   \end{math}
  
% \item[\eqref{lem:ifelse:if:if2}]
%   \begin{math} 
%     \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
%     \supseteq
%     \xSEMI{
%       \xIFTHEN{\lnot\aForm}{\aPSS_2}{}
%     }{
%       \xIFTHEN{\aForm}{\aPSS_1}{}
%     }.
%   \end{math}
\end{enumerate}
\PwTmca{} does not satisfy the reverse inclusion.
The culprit is $\rdelay$, which introduces order regardless of whether
preconditions are disjoint.  As an example, 
\begin{math}
  \sem{\IF{r}
  \THEN \PW{x}{1}
  \ELSE \PW{x}{2}
  \FI}
\end{math}
has an execution with
\begin{math}
  (r{=}0\mid\DW{x}{2})
  \xwki
  (r{\neq}0\mid\DW{x}{1}),
\end{math}
(using augmentation), whereas
\begin{math}
  \sem{
    \IF{r} \THEN \PW{x}{1}\FI
    \SEMI
    \IF{\BANG r} \THEN \PW{x}{2}\FI
  \FI}
\end{math}
has no such execution.


In order to validate the reverse inclusions, we could require that
\ref{seq-le-delays} not impose order when
$\labelingForm_1(\bEv) \land \labelingForm_2(\aEv)$ is unsatisfiable.
Thus, following on \textsection\ref{sec:false}, we would also like this:
\begin{enumerate}
\item[{\labeltext[\textsc{s}6b$'$]{(\textsc{s}6b$'$)}{seq-le-delays'}}] if
  $\labeling_1(\bEv) \rdelays \labeling_2(\aEv)$ and
  $\labelingForm_1(\bEv) \land \labelingForm_2'(\aEv)$ is
  $\labeling$-consistent then $\bEv\le\aEv$.
\end{enumerate}

However, \eqref{seq-le-delays'} fails associativity.
Example where $\cForm_\labeling=(r{=}0)$
\begin{align*}
  \begin{gathered}    
    \PR{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{\DR{y}{0}}{}
      \end{tikzinline}}
  \end{gathered}  
  &&
  \begin{gathered}    
    \IF{r\OR s}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{b}{r{\neq}0\lor s{\neq}0\bigmid\DW{x}{1}}{}
      \end{tikzinline}}
  \end{gathered}    
  &&
  \begin{gathered}    
    \IF{\BANG s}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{c}{s{=}0\bigmid\DW{x}{2}}{}
      \end{tikzinline}}
  \end{gathered}    
\end{align*}
Associating right, order is required since
$((r{\neq}0 \lor s{\neq}0)\land s{=}0)$ is satisfiable (take $r{=}1$ and $s{=}0$):
\begin{align*}
  \begin{gathered}    
    \PR{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{\DR{y}{0}}{}
      \end{tikzinline}}
  \end{gathered}    
  &&
  \begin{gathered}    
    \IF{r\OR s}\THEN\PW{x}{1}\FI
    \SEMI
    \IF{\BANG s}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{b}{r{\neq}0\lor s{\neq}0\bigmid\DW{x}{1}}{}
        \event{c}{s{=}0\bigmid\DW{x}{2}}{right=of b}
        \wki{b}{c}
      \end{tikzinline}}
  \end{gathered}    
\end{align*}
\begin{align*}
  \begin{gathered}    
    \PR{y}{r}
    \SEMI
    \IF{r\OR s}\THEN\PW{x}{1}\FI
    \SEMI
    \IF{\BANG s}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{\DR{y}{0}}{}
        \event{b}{r{=}0\limplies (r{\neq}0\lor s{\neq}0)\bigmid\DW{x}{1}}{right=of a}
        \event{c}{s{=}0\bigmid\DW{x}{2}}{right=of b}
        \po{a}{b}
        \wki{b}{c}
      \end{tikzinline}}
  \end{gathered}    
\end{align*}
Associating left, order is not required between the writes since
$(s{\neq}0\land s{=}0)$ is unsatisfiable:
\begin{align*}
  \begin{gathered}    
    \PR{y}{r}
    \SEMI
    \IF{r\OR s}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{\DR{y}{0}}{}
        \event{b}{r{=}0\limplies (r{\neq}0\lor s{\neq}0)\bigmid\DW{x}{1}}{right=of a}
        \po{a}{b}
      \end{tikzinline}}
  \end{gathered}    
  &&
  \begin{gathered}    
    \IF{\BANG s}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{c}{s{=}0\bigmid\DW{x}{2}}{}
      \end{tikzinline}}
  \end{gathered}    
\end{align*}
\begin{align*}
  \begin{gathered}    
    \PR{y}{r}
    \SEMI
    \IF{r\OR s}\THEN\PW{x}{1}\FI
    \SEMI
    \IF{\BANG s}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{\DR{y}{0}}{}
        \event{b}{r{=}0\limplies (r{\neq}0\lor s{\neq}0)\bigmid\DW{x}{1}}{right=of a}
        \event{c}{s{=}0\bigmid\DW{x}{2}}{right=of b}
        \po{a}{b}
      \end{tikzinline}}
  \end{gathered}    
\end{align*}

This motivates the logic-based presentation of $\rdelay$.  We make the following
changes to the data model:
\begin{itemize}
\item actions need not include access modes---for readability, we color
  synchronizing events in example diagrams throughout this section,
\item there exists a symbol $\RW$, indicating a write action---this is needed
  to handle read-read independency (\textsection\ref{sec:read-read}),
\item there exist symbols $\Qsc$, $\Qr{\aLoc}$, and $\Qw{\aLoc}$---we refer
  to these collectively as \emph{quiescence symbols}.  Roughly, the old
  $\Q{x}$ correspond to $\Qw{x}$.
\end{itemize}
We define some shorthand, using the symbols $\mathsf{S}$ for \emph{stores}
(aka writes) and $\mathsf{L}$ for \emph{loads} (aka reads).
\begin{definition}
  \label{def:QS}
  Let $\Qr{*}=\textstyle\bigwedge_\bLoc \Qr{\bLoc}$, and similarly for
  $\Qw{*}$.
  Let $\Qall=\Qr{*}\land\Qw{*} \land\Qsc$.

  Let $[\aForm/\Qr{*}]$ substitute $\aForm$ for every $\Qr{\bLoc}$, and
  similarly for $\Qw{*}$.
  %
  %Let $[\aForm/\Q{}]$ substitute $\aForm$ for every quiescence symbol.
  Let $\Qsuball{\aForm} = [\aForm/\Qr{*}][\aForm/\Qw{*}][\aForm/\Qsc]$.
  
  Let formulae $\QF{}{\amode}$, $\QS{\aLoc}{\amode}$, and $\QL{\aLoc}{\amode}$ be defined:
  \begin{scope}
    \small
    \begin{align*}
      \QF{}{\fREL}&=\Qr{*}\land\Qw{*} 
      &\QS{\aLoc}{\mRLX}&=\Qr{\aLoc}\land\Qw{\aLoc}
      &\QL{\aLoc}{\mRLX}&=\Qw{\aLoc}
      \\
      \QF{}{\fACQ} &=\Qr{*}
      &\QS{\aLoc}{\mREL}&= \Qr{*}\land\Qw{*} 
      &\QL{\aLoc}{\mACQ}&=\Qw{\aLoc}
      \\
      \QF{}{\fSC} &= \Qall
      &\QS{\aLoc}{\mSC}&= \Qall
      &\QL{\aLoc}{\mSC}&=\Qw{\aLoc}\land\Qsc      
    \end{align*}
  \end{scope}
  % \end{definition}
  % \begin{definition}
  
  Let substitutions $[\aForm/\QF{}{\amode}]$, $[\aForm/\QS{\aLoc}{\amode}]$, and $[\aForm/\QL{\aLoc}{\amode}]$ be defined:
  \begin{scope}
    \small
    \begin{align*}
      [\aForm/\QF{}{\fREL}] &= [\aForm/\Qw{*}]
      &{} [\aForm/\QS{\aLoc}{\mRLX}] &= [\aForm/\Qw{\aLoc}]
      &{} [\aForm/\QL{\aLoc}{\mRLX}] &= [\aForm/\Qr{\aLoc}]
      \\
      [\aForm/\QF{}{\fACQ}] &= [\aForm/\Qr{*},\aForm/\Qw{*}]
      &{} [\aForm/\QS{\aLoc}{\mREL}] &= [\aForm/\Qw{\aLoc}]
      &{} [\aForm/\QL{\aLoc}{\mACQ}] &= [\aForm/\Qr{*},\aForm/\Qw{*}]
      \\
      [\aForm/\QF{}{\fSC}] &= \Qsuball{\aForm}%[\aForm/\Qr{*},\aForm/\Qw{*},\aForm/\Qsc]
      &{} [\aForm/\QS{\aLoc}{\mSC}] &= [\aForm/\Qw{\aLoc},\aForm/\Qsc]
      &{} [\aForm/\QL{\aLoc}{\mSC}] &= \Qsuball{\aForm}%[\aForm/\Qr{*},\aForm/\Qw{*},\aForm/\Qsc]
    \end{align*}
  \end{scope}
\end{definition}

With these notations in hand, we can modify the semantics of
\textsection\ref{sec:model} as follows.  (We leave the generalization to the
semantics of \textsection\ref{sec:additional} as future work.)
\begin{definition}
  \label{def:q}
  Update the following rules from \reffig{fig:seq}.  
  \input{fig-q.tex}
\end{definition}
% \begin{definition}
%   \label{def:q:ca:addr}
%   Update the following rules from \refdef{def:semcaaddr}.  
%   \input{fig-q-ca-addr.tex}
% \end{definition}
The preconditions and the independent transformers have changed.  With the
exception of write, the dependent transformers are unchanged.  For writes,
the interpretation of $\Qw{x}$ of subtly different from that of the old
$\Q{x}$---the transformer strengthens $\Qw{\aLoc}$ to
$(\Qw{\aLoc}\land\aExp{=}\aVal)$ rather than replacing it by $\aExp{=}\aVal$.
In order to ensure coherence, we have given up on initialization.



The precondition indicates which sequentially preceding events must be
ordered before.  For example, all preceding accesses must be ordered before a
releasing write, whereas only writes to the same location must be ordered
before a acquiring read---the latter is due to coherence.

Symmetrically, the transformer indicates which sequentially following must be
ordered after.  For example, all following accesses must be ordered after an
acquiring read, whereas only writes to the same location must be ordered
after a releasing write read---again, the latter is due to coherence.

% The quiescence substitutions update quiescence symbols in subsequent code.
% For subsequent independent code, $\ref{write-kappa-q}$ and $\ref{read-kappa-q}$ substitute false.
% In complete pomsets, we substitute true for .
% %
% For example, we substitute $\FALSE$ for $\QS{\aLoc}{\mREL}$ in the independent
% case for a releasing write; this ensures that subsequent writes to $\aLoc$
% follow the releasing write in top-level pomsets.  Similarly, we substitute
% $\FALSE$ for $\QL{\aLoc}{\mACQ}$ in the independent case for an acquiring
% write; this ensures that all subsequent accesses follow the acquiring read in
% top-level pomsets.

\reffig{fig:q:example} shows  the effect of quiescence for each access mode.
\begin{figure}
  \input{fig-q-example.tex}
  \caption{The Effect of Quiescence for Each Access Mode}
  \label{fig:q:example}
\end{figure}

\begin{example}
  The definition enforces publication.  Consider:
  \begin{align*}
    \begin{gathered}[t]
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinlinesmall}[node distance=.5em and 1.5em]
          \event{a}{1{=}v\land\Qr{x}\land\Qw{x}\bigmid\DW{x}{v}}{}
          \xform{xi}{\bForm[1/x][\FALSE/\Qw{x}]}{above=of a}
          \xform{xd}{\bForm[1/x][(1{=}v\land \Qw{x})/\Qw{x}]}{below=of a}
          \xos{a}{xd}
        \end{tikzinlinesmall}}
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW[\mREL]{y}{1}
      \\
      \hbox{\begin{tikzinlinesmall}[node distance=.5em and 1.5em]
          \raeventX{a}{1{=}v\land\Qr{*}\land\Qw{*}\bigmid\DW{y}{u}}{}
          \xform{xi}{\bForm[1/y][\FALSE/\Qw{y}]}{above=of a}
          \xform{xd}{\bForm[1/y][(1{=}u\land \Qw{y})/\Qw{y}]}{below=of a}
          \xos{a}{xd}
        \end{tikzinlinesmall}}
    \end{gathered}
  \end{align*}
  Since $\Qw{*}[\FALSE/\Qw{\aLoc}]$ is $\FALSE$, we must
  introduce order to get a satisfiable precondition for $\DWP{y}{u}$.
  % composing these without order simplifies to:
  % \begin{gather*}
  %   \PW{x}{1}\SEMI \PW[\mREL]{y}{1}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{\QS{\aLoc}{\mRLX}\bigmid\DW{x}{1}}{}
  %         \xform{x1d}{\bForm}{below right=of a1}
  %         \xform{x2i}{\bForm[\FALSE/\QS{\bLoc}{\mREL}]}{below=of a1}
  %         \xo{a1}{x1d}
  %         \raevent{a2}{\FALSE\bigmid\DW{\bLoc}{1}}{above right=of x1d}
  %         %\xform{x2d}{\bForm}{below left=of a2}
  %         \xform{x1i}{\bForm[\FALSE/\QS{\aLoc}{\mRLX}]}{below=of a2}
  %         \xform{xii}{\bForm[\FALSE/\QS{\bLoc}{\mREL}][\FALSE/\QS{\aLoc}{\mRLX}]}{below right=of a2}
  %         \xo{a2}{x1d}
  %         \xos[xleft]{a1}{x2i}
  %         \xos{a2}{x1i}
  %       \end{tikzinline}}
  % \end{gather*}
  % In order to get a satisfiable precondition for $\DWP{y}{1}$, we must
  % introduce order:
  % \begin{gather*}
  %   % \PW{x}{1}\SEMI \PW[\mREL]{y}{1}
  %   % \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{\QS{\aLoc}{\mRLX}\bigmid\DW{x}{1}}{}
  %         \xform{x1d}{\bForm}{below right=of a1}
  %         \xform{x2i}{\bForm[\FALSE/\QS{\bLoc}{\mREL}]}{below=of a1}
  %         \xo{a1}{x1d}
  %         \raevent{a2}{\QS{\bLoc}{\mREL}\bigmid\DW{\bLoc}{1}}{above right=of x1d}
  %         %\xform{x2d}{\bForm}{below left=of a2}
  %         \xform{x1i}{\bForm[\FALSE/\QS{\aLoc}{\mRLX}]}{below=of a2}
  %         \xform{xii}{\bForm[\FALSE/\QS{\bLoc}{\mREL}][\FALSE/\QS{\aLoc}{\mRLX}]}{below right=of a2}
  %         \xo{a2}{x1d}
  %         \xos[xleft]{a1}{x2i}
  %         \xos{a2}{x1i}
  %         \sync{a1}{a2}
  %       \end{tikzinline}}
  % \end{gather*}
\end{example}

\begin{example}
  \label{ex:subscription}
  The definition enforces subscription.  Consider:
  \begin{align*}
    \begin{gathered}[t]
      \PR[\mACQ]{y}{r}
      \\
      \hbox{\begin{tikzinlinesmall}[node distance=.5em and 1.5em]
          \raeventX{a}{\Qw{y}\bigmid\DR{y}{v}}{}
          \xform{xi}{\PBR{\Qw{y}\limplies\PBR{\aVal{=}\aReg \lor \aLoc{=}\aReg} \lor \RW} \limplies \bForm[\FALSE/\Qr{*}][\FALSE/\Qw{*}]}{above=of a}
          \xform{xd}{\PBR{\Qw{y}\limplies v{=}r}\limplies\bForm}{below=of a}
          \xos{a}{xd}
        \end{tikzinlinesmall}}
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PR{x}{r}
      \\
      \hbox{\begin{tikzinlinesmall}[node distance=.5em and 1.5em]
          \event{a}{\Qw{x}\bigmid\DR{x}{u}}{}
          \xform{xi}{\PBR{\Qw{x}\limplies\PBR{\aVal{=}\aReg \lor \aLoc{=}\aReg} \lor \RW} \limplies \bForm[\FALSE/\Qr{x}]}{above=of a}
          \xform{xd}{\PBR{\Qw{x}\limplies u{=}r}\limplies\bForm}{below=of a}
          \xos{a}{xd}
        \end{tikzinlinesmall}}
    \end{gathered}
  \end{align*}
  Since $\Qw{x}[\FALSE/\Qw{*}]$ is $\FALSE$, we must
  introduce order to get a satisfiable precondition for $\DRP{x}{u}$.
  % Since $\QL{\aLoc}{\mRLX}[\FALSE/\QL{\bLoc}{\mACQ}]$ is $\FALSE$,
  % composing these without order simplifies to:
  % \begin{gather*}
  %   \PR[\mACQ]{y}{r}\SEMI \PR{x}{s}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \raevent{a1}{\QL{\bLoc}{\mACQ}\bigmid\DR{y}{1}}{}
  %         \xform{x1d}{r{=}1\limplies\bForm[\FALSE/\QL{\aLoc}{\mRLX}]}{below=of a1}
  %         \xform{xdd}{r{=}1\limplies s{=}1\limplies\bForm}{right=of x1d}
  %         \xform{xii}{\bForm[\FALSE/\QL{\bLoc}{\mACQ}][\FALSE/\QL{\aLoc}{\mRLX}]}{above=of xdd}
  %         \xform{x2d}{s{=}1\limplies\bForm[\FALSE/\QL{\bLoc}{\mACQ}]}{right=of xdd}
  %         \event{a2}{\FALSE\bigmid\DR{x}{1}}{above=of x2d}
  %         \xos[xleft]{a1}{x1d}
  %         \xos{a2}{x2d}
  %         \xo{a1}{xdd}
  %         \xo{a2}{xdd}
  %       \end{tikzinline}}
  % \end{gather*}
  % In order to get a satisfiable precondition for $\DRP{x}{1}$, we must
  % introduce order:
  % \begin{gather*}
  %   % \PR[\mACQ]{y}{r}\SEMI \PR{x}{s}
  %   % \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \raevent{a1}{\QL{\bLoc}{\mACQ}\bigmid\DR{y}{1}}{}
  %         \xform{x1d}{r{=}1\limplies\bForm[\FALSE/\QL{\aLoc}{\mRLX}]}{below=of a1}
  %         \xform{xdd}{r{=}1\limplies s{=}1\limplies\bForm}{right=of x1d}
  %         \xform{xii}{\bForm[\FALSE/\QL{\bLoc}{\mACQ}][\FALSE/\QL{\aLoc}{\mRLX}]}{above=of xdd}
  %         \xform{x2d}{s{=}1\limplies\bForm[\FALSE/\QL{\bLoc}{\mACQ}]}{right=of xdd}
  %         \event{a2}{\QL{\aLoc}{\mRLX}\bigmid\DR{x}{1}}{above=of x2d}
  %         \xos[xleft]{a1}{x1d}
  %         \xos{a2}{x2d}
  %         \xo{a1}{xdd}
  %         \xo{a2}{xdd}
  %         \sync[out=15,in=165]{a1}{a2}
  %       \end{tikzinline}}
  % \end{gather*}
\end{example}

\begin{example}
Even in its logical form, \ref{seq-le-delays'} is incompatible with the
ability to strengthen preconditions using augment closure, which is allowed
in \cite{DBLP:journals/pacmpl/JagadeesanJR20}.  Consider the following.
\begin{align*}
  \begin{gathered}[t]
    \IF{r}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{r{\neq}0\bigmid\DW{x}{2}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a2}{            \DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a3}{            \DW{x}{2}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a4}{r{=}0   \bigmid\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
% \begin{align*}
%   \begin{gathered}[t]
%     \IF{r}\THEN\PW{x}{2}\FI
%     \SEMI
%     \PW{x}{1}
%     \SEMI
%     \PW{x}{2}
%     \SEMI
%     \IF{\BANG r}\THEN\PW{x}{1}\FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%         \event{a1}{r{\neq}0\bigmid\DW{x}{2}}{}
%         \event{a2}{            \DW{x}{1}}{right=of a1}
%         \event{a3}{            \DW{x}{2}}{right=of a2}
%         \event{a4}{r{=}0   \bigmid\DW{x}{1}}{right=of a3}
%       \end{tikzinline}}    
%   \end{gathered}
% \end{align*}
If $r{=}0$ then $x$ is $1,2,1$.  If $r{\neq}0$ then $x$ is $2,1,2$.
Augmenting the middle preconditions and then using sequential composition, we have:
\begin{align*}
  \begin{gathered}[t]
    \IF{r}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{r{\neq}0\bigmid\DW{x}{2}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{1}
    \SEMI
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a2}{r{\neq}0\bigmid\DW{x}{1}}{}
        \event{a3}{r{=}0   \bigmid\DW{x}{2}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a4}{r{=}0   \bigmid\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Note that \ref{seq-le-delays'} does not require any order between the two
writes of the middle pomset.
% \begin{align*}
%   \begin{gathered}[t]
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%         \event{a1}{r{\neq}0\bigmid\DW{x}{2}}{}
%         \event{a2}{r{=}0   \bigmid\DW{x}{1}}{right=of a1}
%         \event{a3}{r{\neq}0\bigmid\DW{x}{2}}{right=of a2}
%         \event{a4}{r{=}0   \bigmid\DW{x}{1}}{right=of a3}
%       \end{tikzinline}}    
%   \end{gathered}
% \end{align*}
Merging left and right, we have:
\begin{align*}
  \begin{gathered}[t]
    \IF{r}\THEN\PW{x}{2}\FI
    \SEMI
    \PW{x}{1}
    \SEMI
    \PW{x}{2}
    \SEMI
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{2}}{}
        \event{a4}{\DW{x}{1}}{right=of a1}
        \wki{a1}{a4}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
As shown by the following single-threaded code, allowing this outcome would violate \drfsc{}.
\begin{align*}
  \begin{gathered}[t]
    \PW{y}{1}
    \SEMI
    \PR{y}{r}
    \SEMI
    \IF{r}\THEN\PW{x}{2}\FI
    \SEMI
    \PW{x}{1}
    \SEMI
    \PW{x}{2}
    \SEMI
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{2}}{}
        \event{a4}{\DW{x}{1}}{right=of a1}
        \wki{a1}{a4}
        \event{b2}{\DR{y}{1}}{left=of a1}
        \event{b1}{\DW{y}{1}}{left=of b2}
        \rf{b1}{b2}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
This is one reason that we use \emph{weakest} preconditions, rather than
preconditions.

The same problem does not occur due to if-introduction, since complete
pomsets require that the termination condition is a tautology; therefore we
cannot arbitrarily strengthen preconditions without introducing a second
event to cover.
% , so you can't
% arbitrarily choose to partition $\emptyForm\neq\TRUE$:
\begin{align*}
  \begin{gathered}[t]
    \IF{r}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{r{\neq}0\bigmid\DW{x}{2}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{1}
    \SEMI
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a2}{r{\neq}0\bigmid\DW{x}{1}}{}
        \event{a2p}{r{=}0\bigmid\DW{x}{1}}{below=of a2}
        \event{a3}{r{=}0\bigmid\DW{x}{2}}{right=of a1}
        \event{a3p}{r{\neq}0\bigmid\DW{x}{2}}{below=of a3}
        \wki{a2}{a3p}
        \wki{a2p}{a3}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a4}{r{=}0\bigmid\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Merging left and right, we have
\begin{align*}
  \begin{gathered}[t]
    \IF{r}\THEN\PW{x}{2}\FI
    \SEMI
    \PW{x}{1}
    \SEMI
    \PW{x}{2}
    \SEMI
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1a3}{\DW{x}{2}}{}
        \event{a2p}{r{=}0\bigmid\DW{x}{1}}{right=of a1a3}
        \event{a3p}{r{\neq}0\bigmid\DW{x}{2}}{right=of a2p}
        \event{a2a4}{\DW{x}{1}}{right=of a3p}
        \wki[out=-165,in=-10]{a2a4}{a3p}
        \wki[out=-170,in=-15]{a2p}{a1a3}
        \wki{a3p}{a2a4}
        \wki{a1a3}{a2p} 
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
\end{example}


\subsection{Optimizations Not Considered}

We have not considered the following optimizations advocated by
\citet{Manson:2005:JMM:1047659.1040336}:
\begin{itemize}
\item synchronization on thread local objects can be ignored or removed
  altogether (the caveat to this is the fact that invocations of methods like
  wait and notify have to obey the correct semantics – for example, even if
  the lock is thread local, it must be acquired when perform- ing a wait),
\item volatile fields of thread local objects can be treated as normal
  fields,
\item redundant synchronization (e.g., when a synchronized method is called
  from another synchronized method on the same object) can be ignored or
  removed.
\end{itemize}
Nor have we attempted to capture the following:
\begin{itemize}
\item read introduction,
\item \emph{monotonicity}, which allows the access mode to strength, for
  example from $\mRLX$ to $\mACQ$ to $\mSC$,
\item access elimination, such as store forwarding, dead-write-removal,
  redundant write after read elimination \cite[\textsection4.1]{DBLP:conf/ecoop/SevcikA08}.
\end{itemize}
One approach to elimination would be to allow {merging} of actions with
different labels.  A list of safe merges can be found in \cite[\textsection
E]{DBLP:conf/cgo/ChakrabortyV17} and \cite[\textsection7.1]{Kang19}.  For
examples of unsafe merges and reorderings, see \cite[\textsection
D]{DBLP:conf/cgo/ChakrabortyV17}.  See also
\cite[\textsection6.2]{DBLP:journals/pacmpl/ChakrabortyV19}

% It would be nice if we could get at these with a strength reducing result:
% synchronization actions can be replaced by relaxed actions in some cases.
% Then the rules for relaxed read elimination and relaxed write elimination can
% be used to get rid of them.

Certain combinations of optimizations are quite delicate.  For example,
consider if-introduction and dead-write-removal.  With if-introduction, the
following equation should hold:
\begin{align*}
  \sem{
    \IF{r}\THEN\PW{x}{2}\FI
    \SEMI
    \PW{x}{1}
    \SEMI
    \PW{x}{2}
    \SEMI
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \SEMI
    \PW{x}{3}
  }&
  \\ =
  \sem{
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \SEMI
    \PW{x}{2}
    \SEMI
    \PW{x}{1}
    \SEMI
    \IF{r}\THEN\PW{x}{2}\FI
    \SEMI
    \PW{x}{3}
  }&
\end{align*}
Using dead write removal naively, these could be refined, respectively, to:
\begin{align*}
  \sem{
    \PW{x}{1}
    \SEMI
    \PW{x}{2}
    \SEMI
    \PW{x}{3}
  }&
  \\ \mathrel{\smash{\overset{?}{=}}}
  \sem{
    \PW{x}{2}
    \SEMI
    \PW{x}{1}
    \SEMI
    \PW{x}{3}
  }&
\end{align*}
Depending upon the details of the model, these may be observably different.

What has become of coherence?

% Counterexample for first two (at least, for our MCA1 semantics):
% \begin{verbatim}
%  y=1; x^AR=1; r=x^AR; z=1
% \end{verbatim}
% If you see $z=1$ you must see $y=1$

\subsection{The State of the Art Circa 2021}

\citet{DBLP:conf/java/Pugh99} noticed that the semantics of Java 1.0 disabled
common subexpression elimination.  This lead to a repaired model five years
later \cite{Manson:2005:JMM:1047659.1040336}.  Shortly thereafter,
\citet[\textsection7]{DBLP:conf/esop/CenciarelliKS07} noticed that the
repaired model disabled the reordering of independent statements.  Here is
the example:
\begin{gather*}
  \IF{x\land y}\THEN \PW{z}{1}\FI
  \PAR
  \IF{z}\THEN \PW{x}{1}\SEMI \PW{y}{1} \ELSE \PW{y}{1}\SEMI \PW{x}{1} \FI
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DR{y}{1}}{right=of a1}
      \event{a3}{\DW{z}{1}}{right=of a2}
      \po{a2}{a3}
      \po[out=15,in=165]{a1}{a3}      
      \event{b1}{\DR{z}{1}}{right=3em of a3}
      \event{b2}{\DW{y}{1}}{right=of b1}
      \event{b3}{\DW{x}{1}}{right=of b2}
      % \po{b1}{b2}
      % \po[out=15,in=165]{b1}{b3}
      \rf{a3}{b1}
      \rf[out=-165,in=-15]{b2}{a2}
      \rf[out=-165,in=-15]{b3}{a1}
    \end{tikzinline}}
\end{gather*}
Quoting \citet[\textsection7]{DBLP:conf/esop/CenciarelliKS07}:
\begin{quote}
  After reordering the independent statements in the else branch, a compiler
  may execute assignments $\PW{x}{1}$ and $\PW{y}{1}$ early, so that [the
  execution is allowed].  However, such a behaviour is not legal according to
  the current JMM, as it violates the condition that the happens-before
  orders during validation be consistent with the final happens-before on the
  committed actions. In fact, the latter will have the write to $x$ before the
  write to $y$, but during validation the write to $y$ happens before the write
  to $x$.
\end{quote}

Since then, several models have been proposed.  Many have been revised
repeatedly to repair bugs.  (For example, this paper fixes several errors of
\citet{DBLP:journals/pacmpl/JagadeesanJR20}.)

In this subsection, we provide series of quotations from a discussion on the
OpenJDK mailing lists, which provides an excellent summary of the state of
the art in 2021, when this paper was written.  (The quotes are ordered for
readability, with hyperlinks to the original discussion.)

\begin{quotation}
\href{https://mail.openjdk.java.net/pipermail/jdk-dev/2021-August/005904.html}{Raffaello Giulietti}:
``JEP 188: Java Memory Model Update'' \href{https://openjdk.java.net/jeps/188}{[1]}, the JMM wiki \href{https://wiki.openjdk.java.net/display/jmm/Main}{[2]} and the 
jmm-dev mailing list \href{https://mail.openjdk.java.net/pipermail/jmm-dev/}{[3]} seem quite inactive. (The latter point explains 
why I'm posting to this list instead.)

The introduction of \texttt{j.l.i.VarHandle} \href{https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/VarHandle.html}{[4]} brought more access modes to 
Java, but in a narrative and informal way. A paper by Bender \& Palsberg 
\href{https://dl.acm.org/doi/10.1145/3360568}{[5]}, addressing the formalization of the concurrent access modes, has 
been published in 2019 but I'm not sure if it caught the attention of 
the OpenJDK community.

So what is the current thinking for progressing the JMM spec?

\smallskip

\href{https://mail.openjdk.java.net/pipermail/jdk-dev/2021-August/005909.html}{Hans Boehm}:
I think it's safe to say that it has been slow going, not just for Java,
but for other languages as well.

In my view, the core problem, shared by pretty much all of them, is that we
don't have an established way to give well-defined semantics to potentially
racing unordered accesses, like ordinary variable accesses in Java, or
\texttt{memory\_order\_relaxed} accesses in C and C++. That's particularly essential
with the traditional Java language-based-security model, since we can't
just give up on racing accesses to ordinary variables.

I'm aware of a number of proposed solutions. But I don't think we currently
have enough confidence that they
\begin{enumerate}[label=(\alph*)]
\item\label{HBa} Are correct, and don't have issues similar to the older models,
\item Don't have unintended consequences, particularly for compilation, and
\item Are sufficiently comprehensible by programmers to actually be useful.
\end{enumerate}
\ref{HBa} is hard because the models have gotten complex enough that reviewers
are scarce. (A problem that I gather you're familiar with.) The authors are
commonly experts at formally analyzing the models, but it's hard to analyze
whether the model conflicts with some well-known, but perhaps not
well-written-down compilation technique.

Probably even more controversially, I think we've realized that existing
compiler technology can compile such racing code in ways that some of us are
not 100\% sure should really be allowed. Demonstrably unexecuted code can
affect the semantics in ways that strike me as scary. (See
\url{https://wg21.link/p1217} for a down-to-assembly C++ version; [if I
understand correctly], Lochbihler and others earlier came up with some
closely related observations for Java.)

It might be possible to do what we've involuntarily done for C++: Punt the
hard cases for now, and define what the model is for programs without
racing ordinary accesses.

%[p1217 is \cite{BoehmOOTA}.]

\smallskip

\href{https://mail.openjdk.java.net/pipermail/jmm-dev/2021-August/000447.html}{Andrew Haley}:
\begin{quote}
  (Quoting
  \href{https://mail.openjdk.java.net/pipermail/jdk-dev/2021-August/005909.html}{Hans
    Boehm}) Probably even more controversially, I think we've realized that
  existing compiler technology can compile such racing code in ways that some
  of us are not 100\% sure should really be allowed.
\end{quote}
This implies, does it not, that the problem is not formalization as
such, but that we don't really understand what the language is
supposed to mean? That's always been my problem with OOTA: I'm unsure
whether the problem is due to the inadequacy of formal models, in
which case the formalists can fix their own problem, or something we
all have to pay attention to.

\smallskip

\href{https://mail.openjdk.java.net/pipermail/jmm-dev/2021-August/000450.html}{Hans
  Boehm}: In some sense, I'm not sure either. The p1217 examples [formalized
below as \ref{RFUB} and \ref{RFUB-NC}] bother me in that they seem to violate
some global programming rules (``if \texttt{x} is only ever null or refers to
an object properly constructed by the same thread, then \texttt{x} should
never appear to refer to an incompletely constructed object'').  And there
seems to be disagreement about whether the currently allowed behavior is
``correct.''

On the other hand, in practice the weirdness doesn't seem to break things.
If you ask people advocating the current behavior, the answer will be
that it doesn't matter because nobody writes code that way. If you ask
people trying to analyzer or verify code, they'll probably be unhappy.
And I haven't been able to convince myself that you cannot get yourself
into these situations just by linking components together, each of which
does something perfectly reasonable.

And there are very common code
patterns (like the standard implementation of reentrant locks used
by all Java implementations) that break if you allow general OOTA
behavior. Which at least means that you can't currently formally verify such
code. The theorem you'd be trying to prove is false with respect to the
part of the language spec we know how to formalize.

It's a mess.


\smallskip

\href{https://mail.openjdk.java.net/pipermail/jmm-dev/2021-August/000447.html}{Andrew Haley}:
\begin{quote}
  (Quoting
  \href{https://mail.openjdk.java.net/pipermail/jdk-dev/2021-August/005909.html}{Hans
    Boehm}) Demonstrably unexecuted code can affect the semantics in ways
  that strike me as scary. (See wg21.link/p1217 for a down-to-assembly C++
  version; [if I understand correctly], Lochbihler and others earlier came up
  with some closely related observations for Java.)
\end{quote}
Looking again at p1217, it seems to me that enforcing load-store
ordering would have severe effects on compilers, at least without new
optimization techniques. We hoist loads before loops and sink stores
after them. When it all works out, there are no memory accesses in the
loop. A load-store barrier in a loop would have the effect of forcing
succeeding stores out to memory, and forcing preceding loads to reload
from memory. It's not hard to imagine that this would cause an
order-of-margnitude performance reduction in common cases.

I suppose one could argue that such optimizations would continue to be
valid, so only those stores which would have been emitted anyway would
be affected. But that's not how compilers work, as far as I know. In
our IR for C2, memory accesses are not pinned in any way, so the only
way to make unrelated accesses execute in any particular order is to
add a dependency between all loads and stores.

\smallskip

\href{https://mail.openjdk.java.net/pipermail/jmm-dev/2021-August/000450.html}{Hans Boehm}:
I think it would be a fairly pervasive change to optimizers. It has also
become clear in WG21, the C++ committee, that there is not enough
support for requiring this. In that case, Ou and Demsky have a paper
saying that the overhead is likely to be on the order of 1\% or less.
For Java if it were applied everywhere, it would probably be
appreciably higher.

On the other hand, it's a bit harder than that to come up with examples
where
the generated x86 code has to be worse. Moving loads earlier in the
code, or delaying stores, as you suggest, would still be fine. The only
issue is with delaying loads past stores, which seems less common,
though it can certainly be beneficial for reducing live ranges, probably
some
vectorization etc.

But it seems unlikely that such a restriction will be applied even to
C++ \texttt{memory\_order\_relaxed}, much less Java ordinary variables.

\smallskip

\href{https://mail.openjdk.java.net/pipermail/jmm-dev/2021-August/000449.html}{Doug
  Lea}:
My stance in the less formal account 
(\url{http://gee.cs.oswego.edu/dl/html/j9mm.html}) as well as Shuyang Liu et 
al's ongoing formalization (see links from 
\url{http://compilers.cs.ucla.edu/people/}) is that the most you want to say 
about racy Java programs is that they are typesafe. As in: you can't see 
a String when expecting an int. Even this looser constraint is 
challenging to specify, prove, and extend. But it is a path for Java 
that might not apply to languages like C that are not guaranteed 
typesafe anyway, and so enter Undefined Behavior territory (as opposed 
to possibly-unexpected but still typesafe behavior).

\smallskip

\href{https://mail.openjdk.java.net/pipermail/jmm-dev/2021-August/000451.html}{Han Boehm}:
But this now breaks some common idioms, right? In particular, I think a
bunch of
code assumes that racing assignments of equivalent primitive values or
immutable
objects to the same field are OK.

If, in 2004, our view of language-based security had been the same as it is
now,
then I completely agree that this would have been the right approach. But I
think
doing it now would require significant user code changes. Which might still
be the best way forward ...
\end{quotation}

