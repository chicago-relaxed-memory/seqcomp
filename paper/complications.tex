\section{Complications}

[I have a note: TC1: Track local state ???]

\subsection{Must Allow Inconsistent Preconditions}

\subsection{Release, Acquire, and Sequentially Consistent Access}

We use $\Q{\mRA}$ and $\Q{\mSC}$.

$\Q{\mSC}$ implies $\Q{\mRA}$.

\begin{definition}
  $\aPS$ is \emph{completed} if $\aTr[\aEvs](\Q{\mSC})$ implies $\Q{\mSC}$.
\end{definition}

Access modes can be encoded in the independency relation, indexing labels by
$\amode$, but the extra flexibility of the logic is necessary for \armeight{}
(see \textsection\ref{sec:internal}).  Using independency, one would also
need another way to define completed pomsets.  Finally, this use of
independency is incompatible with fork (see \textsection\ref{sec:co}).

\subsection{Coherence}
\label{sec:co}

$\Q{\mSC}$ implies $\Q{\mRA}$ implies $\Qx{\aLoc}$ implies $\Qw{\aLoc}$

\begin{itemize}
\item Coherence respects program order: $\Qx{\aLoc}$
\item Drop read-read coherence: $\Qw{\aLoc}$ (Required for CSE without
  alias analysis over read only code, not required by hardware)
\end{itemize}

It is also possible to put coherence in the independency relation, in which
case, the semantics of $;$ includes the following.
\begin{enumerate}
  \setcounter{enumi}{\value{pomsetXSemiCount}}
\item
  \label{seq-reorder} if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ either $\bEv<\SB0\aEv$ or $a\reorder\labeling_2(\aEv)$.
\end{enumerate}
One must be careful, however, due to \emph{inconsistency}.

Consider

\eqref{seq-reorder} does not do the right thing with fork either.  If you
want to enforce coherence this way then you need to use fork-join as the
sequential combinator, rather than fork.

\begin{figure*}
  \begin{center}
  \begin{minipage}{0.905\textwidth}
    \input{fig-full}
    % \input{fig-full-where}
  \end{minipage}
  \end{center}
  \caption{Full Semantics of Load and Store}
  \label{fig:full}
\end{figure*}    


\subsection{ARM Compilation: Internal Acquires}
\label{sec:internal}
Downgrading acquires/Anton example: $\Dx{\aLoc}$

%$\D$ implies $\Dx{\aLoc}$

We write $[\aForm/\D]$ for the substitution that performs
$[\aForm/\Dx{\aLoc}]$ for every $\aLoc$.

\subsection{ARM Compilation: Read-read dependencies}
$\RW$/$\RO$ (control dependencies into reads as in MP with
release on right and control dependency on left)

$\RW$ implies $\lnot\RO$ and 
$\RO$ implies $\lnot\RW$.


\subsection{Putting it together}


Combining the features defined thus far, we have the following, assuming that
each register occurs at most once.

\begin{definition}$\phantom{\;}$\par
  
  $\QS{\aLoc}{\mRLX}=\Qx{\aLoc}$ and otherwise $\QS{\aLoc}{\amode}=\Q{\amode}$.

  $\QL{\aLoc}{\mSC}=\Q{\mSC}$ and otherwise $\QL{\aLoc}{\amode}=\Qw{\aLoc}$.

  $\DS{\aLoc}{\mRLX}{\aForm}=\aForm[\TRUE/\Dx{\aLoc}]$ and otherwise
  $\DS{\aLoc}{\amode}{\aForm}=\aForm[\FALSE/\D]$. 

  $\DL{\aLoc}{\mRLX}=\TRUE$ and otherwise $\DL{\aLoc}{\amode}=\Dx{\aLoc}$.
  \smallskip
  
  \input{fig-noif}
\end{definition}

If we move coherence to independency (and use fork-join), we have the
following, assuming that each register occurs at most once.
\begin{definition}$\phantom{\;}$\par
  $\QS{}{\mRLX}=\TRUE$ and otherwise $\QS{}{\amode}=\Q{\amode}$.

  $\QL{}{\mSC}=\Q{\mSC}$ and otherwise $\QL{}{\amode}=\TRUE$.

  \smallskip

  \input{fig-noco-noif}
\end{definition}



\section{Further Complications}

\subsection{Redundant Read Elimination}

Requires indexing to resolve nondeterminism.

\begin{gather*}
  \taglabel{TC2}
  \PR{x}{r}\SEMI
  \PR{x}{s}\SEMI
  \IF{r{=}s}\THEN \PW{y}{1}\FI
  \PAR
  x\GETS y
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DR{x}{1}}{right=of a1}
  \event{a3}{\DW{y}{1}}{right=of a2}
  % \po{a2}{a3}
  % \po[out=-20,in=-160]{a1}{a3}
  \event{b1}{\DR{y}{1}}{right=3em of a3}
  \event{b2}{\DW{x}{1}}{right=of b1}
  \rf{a3}{b1}
  \po{b1}{b2}
  \rf[out=169,in=11]{b2}{a2}
  \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
Precondition of $\DWP{y}{1}$ is $(r{=}s)$ in
\begin{math}
  \sem{\IF{r{=}s}\THEN y\GETS 1\FI}.
\end{math}
Predicate transformers for $\emptyset$ in $\sem{\PR{x}{r}}$ and $\sem{\PR{x}{s}}$ are
\begin{align*}
  \PREDP{(r{=}1 \lor r{=}x)\limplies\aForm[r/x]},
  \\
  \PREDP{(s{=}1 \lor s{=}x)\limplies\aForm[s/x]}.
\end{align*}
Combining the transformers, we have
\begin{displaymath}
  \PREDP{(r{=}1 \lor r{=}x)\limplies(s{=}1 \lor s{=}r)\limplies\aForm[s/x]}.
\end{displaymath}
Applying this to $(r{=}s)$, we have
\begin{displaymath}
  \PREDP{(r{=}1 \lor r{=}x)\limplies (s{=}1 \lor s{=}r)\limplies (r{=}s)},
\end{displaymath}
which is not a tautology.

Same problem occurs oopsla, where we have:
\begin{align*}
  \PREDP{\aForm[v/x,r] \land \aForm[x/r]},
  \\
  \PREDP{\aForm[v/x,s] \land \aForm[x/s]}.
\end{align*}
Combining the transformers, we have
\begin{displaymath}
  \PREDP{\aForm[v/x,r,s] \land \aForm [v/x,r][x/s] \land \aForm[x/r][v/x,s] \land \aForm[x/r,s]}.
\end{displaymath}
Applying this to $(r{=}s)$, we have
\begin{displaymath}
  \PREDP{v{=}v \land v{=}x \land x{=}v \land x{=}x},
\end{displaymath}
which is not a tautology.

The semantics here allows this by coalescing:
\begin{gather*}
  r\GETS x\SEMI
  s\GETS x\SEMI
  \IF{r{=}s}\THEN y\GETS 1\FI
  \PAR
  x\GETS y
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a3}{\DW{y}{1}}{right=of a1}
      \event{b1}{\DR{y}{1}}{right=3em of a3}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \rf{a3}{b1}
      \po{b1}{b2}
      \rf[out=169,in=11]{b2}{a1}
    \end{tikzinline}}
\end{gather*}

\subsection{If Closure}
Requires indexing to resolve nondeterminism.

IF closure/case analysis: $\psi_e$

\subsection{Address Calculation}

Do this after if closure, because problem with punning badly.

\begin{definition}
  \noindent
  If $\aPS\SB0 \in \sSTORE{\cExp}{\aExp}$ then
  $(\exists\aVal,\,\cVal\in\Val)$
  \begin{enumerate}
  \item if $\bEv,\aEv\in\aEvs\SB0$ then $\bEv=\aEv$.
  \item $\labelingAct\SB0(\aEv) = \DWP{\REF\cVal}{\aVal}$,
  \item $\labelingForm\SB0(\aEv)$ implies $(\cExp{=}\cVal \land \aExp{=}\aVal)$,
  \item $\aTr[\emptyset]\SB0(\aForm)$ implies $(\cExp{=}\cVal) \limplies \aForm[\aExp/\REF{\cVal}]$,
  \item $\aTr[\bEvs]\SB0(\aForm)$ implies $(\cExp{=}\cVal) \limplies (\aExp{=}\aVal) \land \aForm[\aExp/\REF{\cVal}]$, 
  \end{enumerate}

  \noindent
  If $\aPS\SB0 \in \sLOAD{\cExp}{\aReg}$ then
  $(\exists\aVal,\,\cVal\in\Val)$
  \begin{enumerate}
  \item if $\bEv,\aEv\in\aEvs\SB0$ then $\bEv=\aEv$.
  \item $\labelingAct\SB0(\aEv) = \DRP{\REF{\cVal}}{\aVal}$,
  \item $\labelingForm\SB0(\aEv)$ implies $(\cExp{=}\cVal)$,
  \item $\aTr[\emptyset]\SB0(\aForm)$ implies
    $(\cExp{=}\cVal) \limplies (\aReg{=}\aVal\lor\aReg{=}\REF{\cVal})\limplies\aForm[\aReg/\REF{\cVal}]$,
  \item $\aTr[\bEvs]\SB0(\aForm)$ implies
    $(\cExp{=}\cVal) \limplies (\aReg{=}\aVal)\limplies\aForm[\aReg/\REF{\cVal}]$, 
  \end{enumerate}  
\end{definition}

\subsection{Putting it together}

The full semantics of load and store is given in Figure \ref{fig:full}.
Recall that $\uRegs{\bEvs}=\{\uReg{\bEv}\mid\bEv\in\bEvs\}$.

% \subsection{Agda}
% \begin{figure*}
%   \includegraphics[width=\textwidth]{agda.png}
% \end{figure*}
