\section{Sequential Semantics}
\label{sec:model}

After some preliminaries (\textsection\ref{sec:prelim}--\ref{sec:actions}),
we define the basic model and establish some basic properties
(\textsection\ref{sec:pomsets} and \reffig{fig:seq}).  We then explain the
model using examples (\textsection\ref{sec:ex:pomset}--\ref{sec:ex:last}).
We encourage readers to skim the definitions and then skip to
\textsection\ref{sec:ex:pomset}, coming back as needed.

In this section, we concentrate on the sequential semantics, ignoring the
requirement that concurrent reads be \emph{fulfilled} by matching writes. We
extend the model to a full concurrent semantics in \textsection\ref{sec:mca}
and \textsection\ref{sec:c11} by defining a \emph{reads-from} relation ($\rrfx$) subject
to various constraints.

%% Batty suggest example where dependencies are added and also go away, perhaps
%% by store forwarding. Something like:
%% \texttt{(r=x; y=1); (s=y; z=s+r)}

% In this section, we present the mathematical preliminaries for the
% model (which can be skipped on first reading). We then present the
% model incrementally, starting with a model built using
% \emph{partially ordered multisets}
% (\emph{pomsets})~\cite{GISCHER1988199,Plotkin:1997:TSP:266557.266600},
% and then adding preconditions and finally predicate transformers.

% In later sections, we will discuss extensions to the logic, and to the
% semantics of load, store and thread initialization, in order to model
% relaxed memory more faithfully. We stress that these features do
% \emph{not} change any of the structures of the language: conditionals,
% parallel composition, and sequential composition are as defined in this section.

\subsection{Preliminaries}
\label{sec:prelim}
The syntax is built from
\begin{itemize}
\item a set of \emph{values}
  $\Val$, ranged over by $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$.
\end{itemize}

\emph{Memory references} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory references, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.
% 
We require that
\begin{itemize}
\item values and registers are disjoint, 
\item values are finite\footnote{We require finiteness for the semantics of address
    calculation (\textsection\ref{sec:addr}), which quantifies over all
    values.  Using types, one could limit the finiteness assumption to the
    subset of values used for address calculation.} and include at least the constants $0$ and $1$,  
\item expressions include at least registers and values, 
\item expressions do \emph{not} include references: $\aExp[\bExp/\aLoc]=\aExp$.
\end{itemize}

We model the following language.
\begin{gather*}
  \begin{aligned}
    \amode,\bmode \BNFDEF& \mRLX
    \BNFSEP \mREL
    \BNFSEP \mACQ
    \BNFSEP \mSC
    % \amode \BNFDEF& \mRLX
    % \BNFSEP \mRA 
    % \BNFSEP \mSC
    % &\mkern100mu
    % \fmode \BNFDEF& \fACQ 
    % \BNFSEP \fREL
    % \BNFSEP \fSC
  \end{aligned}
  \\
  \aCmd
  \BNFDEF \LET{\aReg}{\aExp}
  \BNFSEP \PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}
  \BNFSEP \PW[\amode]{\REF{\cExp}}[\ascope]{\aExp}
  \BNFSEP \PF[\ascope]{\fmode}
  \BNFSEP \SKIP
  \BNFSEP \aCmd_1 \SEMI \aCmd_2
  \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
  \BNFSEP \aCmd_1 \RPAR[\bThrd] \aCmd_2
  % \\[-.5ex]
  % \BNFSEP& \PCAS[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
  % \BNFSEP \PFADD[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  % \BNFSEP \PEXCHG[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
\end{gather*}

% \emph{Memory modes}, $\amode$, are {relaxed} ($\mRLX$), {release-acquire}
% ($\mRA$), and {sequentially consistent} ($\mSC$).  Relaxed mode is the
% default; we regularly elide it from examples.  $\mRA$/$\mSC$ accesses are
% collectively known as \emph{synchronized accesses}.  

% \emph{Fence modes}, $\bmode$, are {acquire} ($\fACQ$), {release} ($\fREL$), 
% and {acquire-release} ($\fSC$).  

\emph{Access modes}, $\amode$, are {relaxed} ($\mRLX$),
{release} ($\mREL$), {acquire} ($\mACQ$), and
{sequentially consistent} ($\mSC$).
%
Let expressions ($\LET{\aReg}{\aExp}$) only affect thread-local state and
thus do not have a mode.
%
Reads ($\PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
%$\mWK$,
$\mRLX$,
%$\mREL$,
$\mACQ$,
%$\mRA$, 
$\mSC$. 
Writes ($\PW[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
%$\mWK$,
$\mRLX$,
$\mREL$,
%$\mACQ$,
%$\mRA$, 
$\mSC$. 
Fences ($\PF[\ascope]{\fmode}$) support
%$\mWK$,
%$\mRLX$,
$\mREL$,
$\mACQ$,
%$\mRA$,
$\mSC$.
In examples, the default mode for reads and writes is $\mRLX$---we
systematically drop the annotation. 

\emph{Commands}, aka \emph{statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs. Following
\citet{DBLP:conf/icfp/FerreiraHJ96}, $\RPAR$ denotes parallel composition,
preserving thread state on the right after a join.  In examples and
sublanguages without join, we use the symmetric $\PAR$ operator.

We use common syntactic sugar, such as \emph{extended expressions}, $\aEExp$,
which include memory locations.  For example, if $\aEExp$ includes a single
occurrence of $\aLoc$, then $\bLoc\GETS\aEExp\SEMI \aCmd$ is shorthand for
$\aReg\GETS\aLoc\SEMI\bLoc\GETS\aEExp[\aReg/\aLoc]\SEMI \aCmd$.  Each
occurrence of $\aLoc$ in an extended expression corresponds to an separate
read.  We also write $\IF{\aExp} \THEN \aCmd \FI$ as shorthand for
$\IF{\aExp} \THEN \aCmd\ELSE \SKIP\FI$.



Throughout \textsection\ref{sec:intro}--\ref{sec:tool} we 
require that
\begin{itemize}
\item each register is assigned at most once in a program.
  % \end{itemize}
  % In \textsection\ref{sec:complications} and following, we
  % require instead that
  % \begin{itemize}
  % \end{itemize}
\end{itemize}
In \textsection\ref{sec:additional}, we drop this restriction, requiring
instead that
\begin{itemize}
\item there are registers that do not
  appear in programs. % (see \textsection\ref{sec:semreg}).
  % $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$, that do not
  % appear in programs: $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$.
\end{itemize}
% In contexts that make no use of $\uRegs{\AllEvents}$, we make the first
% assumption.

The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, %$\dEv$,
  and subsets ranged over by $\aEvs$, $\bEvs$, $\cEvs$,  
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$,
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, $\bAct$,
\item a family of \emph{quiescence symbols} $\Q{\aLoc}$, indexed by location.
\end{itemize}
% $\dEvs$.

We require that
\begin{itemize}
\item formulae include $\TRUE$, $\FALSE$, $\Q{\aLoc}$, and the equalities $(\aExp{=}\bExp)$ and $(\aLoc{=}\aExp)$,
\item formulae are closed under $\lnot$, $\land$, $\lor$, $\limplies$, and
  substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$, $[\aForm/\Q{\aLoc}]$,
\item there is a relation $\rimpliesdef$ between
  formulae, capturing entailment, %\subseteq(\Formulae\times\Formulae)$ %
\item $\rimpliesdef$ has the expected semantics for $=$, $\lnot$,
  $\land$, $\lor$, $\limplies$ and substitutions $[\aExp/\aReg]$,
  $[\aExp/\aLoc]$, $[\aForm/\Q{\aLoc}]$,
\item there is a subset of $\Act$, distinguishing
  $\sreaddef$ actions,
% \item there are two subsets of $\Act$, distinguishing
%   $\sreaddef$ and $\sreleasedef$ actions,
\item there are four binary relations over $\Act\times\Act$:
  %$\rdelaysdef$, $\rmatchesdef$, $\rblocksdef$, $\roverlapsdef$, and.
  $\rdelaysdef$ and ${\rmatchesdef}\subseteq{\rblocksdef}\subseteq{\roverlapsdef}$.
\end{itemize}
%We require that $\rmatches\subseteq\rblocks\subseteq\roverlaps$.

Logical formulae include equations over registers and memory references, such as
$(\aReg{=}\bReg{+}1)$ and $(\aLoc{=}1)$.
% For use in \textsection\ref{sec:tc1}, we also include equations over memory references, such as $(\aLoc{=}1)$.
% I would like to drop this, an be careful about program vs logical syntax
We use expressions as formulae, coercing $\aExp$ to $\aExp{\neq}0$.
% Equations have precedence over logical operators; thus
% $\aReg{=}\aVal\limplies\bReg{>}\bVal$ is read
% $(\aReg{=}\aVal)\limplies(\bReg{>}\bVal)$.  As usual, implication associates to the
% right; thus $\aForm\limplies\bForm\limplies\cForm$ is read
% $\aForm\limplies(\bForm\limplies\cForm)$.
% As usual, implication associates to the right; thus
% $\aReg{=}\aVal\limplies\bReg{>}\bVal\limplies\bForm$ is read
% $(\aReg{=}\aVal)\limplies((\bReg{>}\bVal)\limplies\bForm)$.

% Formulae are subject to substitutions; % of the form $[\aExp/\aReg]$ and
% % $[\aExp/\aLoc]$;
% actions are not.

% \begin{definition}
%   \label{def:independent}
%   We say $\aForm$ is \emph{independent of $\aLoc$} if, for every
%   $\aVal$, $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$; it is
%   \emph{dependent} otherwise.
%   We say $\aForm$ is \emph{location independent} if it is independent of
%   every location.
%   We say
%   $\aForm$ \emph{implies} $\bForm$ if $\aForm\vDash\bForm$.
%   We say that
We write $\aForm\riff\bForm$ when $\aForm\rimplies\bForm$ and $\bForm\rimplies\aForm$.
We say
$\aForm$ is a \emph{tautology} if $\TRUE \rimplies \aForm$.
% We say that
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm \rimplies \FALSE$, and
\emph{satisfiable} otherwise.
% \end{definition}




\subsection{Actions in This Paper}
\label{sec:actions}
In this paper, we let actions be reads and writes and fences:
\begin{displaymath}
  \aAct,\bAct \BNFDEF \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DF[\ascope]{\fmode}[\aThrd]
\end{displaymath}
% % writes $\DWP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% reads $\DRP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% and fences $\DFP[\ascope]{\fmode}[\aThrd]$.

We use shorthand when referring to actions.  In definitions, we drop elements
of actions that are existentially quantified.  In examples, we drop elements
of actions, using defaults.
% We write $\DXP[\amode]{}[\ascope]{}[\aThrd]$ to
% stand for $\DWP[\amode]{}[\ascope]{}[\aThrd]$ or
% $\DRP[\amode]{}[\ascope]{}[\aThrd]$.
% 
Let $\lemode$ be the smallest order over access and fence modes such that
%$\mRLX\lemode\mRA\lemode\mSC$ and $\fREL\lemode\fSC$ and $\fACQ\lemode\fSC$.
$\mRLX\lemode\mREL\lemode\mSC$ and $\mRLX\lemode\mACQ\lemode\mSC$.
We write $\DWP[\gemode\mREL]{}{}$ to stand for either $\DWP[\mREL]{}{}$ or
$\DWP[\mSC]{}{}$, and similarly for the other actions and modes.

% We also define shorthand for sets of
% actions using an order on access and fence modes:  
% \begin{align*}
%   \begin{tikzcenter}
%     \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
%     \node (ra)  at (1, 0) {$\mathstrut\mRA$};
%     \node (sc)  at (2, 0) {$\mathstrut\mSC$};
%     \draw[->](rlx)to(ra);
%     \draw[->](ra)to(sc);
%   \end{tikzcenter}
%   &&
%   \begin{tikzcenter}
%     \node (fsc) at (3, 0) {$\mathstrut\fSC$};
%     \node (rel) at (2, -0.2) {$\mathstrut\fREL$};
%     \node (acq) at (2,  0.2) {$\mathstrut\fACQ$};
%     \draw[->](rel)to(fsc);
%     \draw[->](acq)to(fsc);
%   \end{tikzcenter}
% \end{align*}
% We write $\amode\lemode\bmode$ for this order.
% Let $\amode\lubmode\bmode$ denote the least upper bound of $\amode$ and $\bmode$.

% or $\DFP[\ascope]{\amode}[\aThrd]$.
% We write $\DWP[\gemode\mREL]{}{}$ to stand for either
% $\DWP[\mREL]{}{}$ or $\DWP[\mSC]{}{}$, and similarly for other actions and
% modes.

\begin{definition}
  \label{def:actions}
  Actions $\DRP{}{}$ are $\sreaddef$ actions.
  % Actions $\DWP[\gemode\mREL]{}{}$ and $\DFP{\gemode\fREL}$ are
  % $\sreleasedef$ actions.

  We say $\aAct \rmatchesdef \bAct$ if $\aAct=\DWP{\aLoc}{\aVal}$ and $\bAct=\DRP{\aLoc}{\aVal}$.
  % We say $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.
  % Action $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.

  We say $\aAct \rblocksdef \bAct$ if $\aAct=\DWP{\aLoc}{}$ and $\bAct=\DRP{\aLoc}{}$, regardless of value.
  % We say $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.
  % Action $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.

  We say $\aAct \roverlapsdef \bAct$ if they access the same location, regardless of whether they read or write.
  
  % Let two actions \emph{overlap} if they access the same location.
  % We say $\aAct \roverlapsdef \bAct$ if they access the same location.
  Let ${\eqreorderco}$ capture write-write, read-write coherence:
  \begin{math}
    {\eqreorderco}
    =
    \{(\DW{\aLoc}{}\Cb \DW{\aLoc}{})\Cc(\DR{\aLoc}{}\Cb \DW{\aLoc}{})\Cc(\DW{\aLoc}{}\Cb \DR{\aLoc}{})\}
  \end{math}.

  Let ${\reorderra}$ capture conflict due to
  synchronization:\footnote{This formalization includes
  \emph{release sequences}
  \begin{math}
        ( \DW[\gemode\mREL]{\aLoc}{}\Cb\DW{\aLoc}{} ).
  \end{math} Symmetry would suggest that we include
  \begin{math}
    (\DR{\aLoc}{}, \DR[\gemode\mACQ]{\aLoc}{}),
  \end{math}
  but this is not sound for \armeight{}.}   
  \begin{math}
    {\reorderra}
    =\{
    ( \aAct                     \Cb\DW[\gemode\mREL]{}{}      )\Cc
    ( \aAct                     \Cb\DF{\gemode\fREL}          )\Cc
    ( \DR{}{}                   \Cb\DF{\gemode\fACQ}          )\Cc 
    %( \DR{\aLoc}{}              \Cb\DR[\gemode\mACQ]{\aLoc}{} )\Cc
    ( \DR[\gemode\mACQ]{}{}     \Cb\bAct                      )\Cc 
    ( \DF{\gemode\fACQ}         \Cb\bAct                      )\Cc
    ( \DF{\gemode\fREL}         \Cb\DW{}{}                    )\Cc
    ( \DW[\gemode\mREL]{\aLoc}{}\Cb\DW{\aLoc}{}               )\}
  \end{math}.

  Let ${\eqreordersc}$ capture conflict due to $\mSC$ access:
  \begin{math}
    {\eqreordersc}
    =
    % \{(\DX[\mSC]{}{}\Cb\DX[\mSC]{}{})\}
    \{(\DW[\mSC]{}{}\Cb \DW[\mSC]{}{})\Cc(\DR[\mSC]{}{}\Cb \DW[\mSC]{}{}) \Cc(\DW[\mSC]{}{}\Cb \DR[\mSC]{}{})\Cc(\DR[\mSC]{}{}\Cb \DR[\mSC]{}{})\}
  \end{math}.

  We say $\aAct \rdelaysdef \bAct$ if $\aAct\eqreorderco\bAct$ or $\aAct\reorderra\bAct$ or $\aAct\eqreordersc\bAct$.
\end{definition}

\subsection{\PwTTITLE: Pomsets with Predicate Transformers}
\label{sec:pomsets}

\emph{Predicate transformers} are functions on formulae that preserve logical
structure, providing a natural model of sequential composition.  The
definition follows
\citet{DBLP:journals/cacm/Dijkstra75}.\footnote{In \label{footnote:false}
  addition to the three criteria of \refdef{def:trans},
  \citet{DBLP:journals/cacm/Dijkstra75} requires
  \labeltext[\textsc{x}4$'$]{(\textsc{x}4$'$)}{tr-false'}
  $\aTr{}{\FALSE}\riff\FALSE$.  The dependent transformer for read actions
  \eqref{read-tau-dep} fails \ref{tr-false'}, since $\FALSE$ is not
  equivalent to $v{=}r\limplies\FALSE$.  We can define an analog of
  \ref{tr-false'} for our model using the register naming conventions of
  \textsection\ref{sec:additional}.  Define $\regForm{\labeling}$ to capture
  the \emph{register state} of a pomset:
  \begin{math}
    \regForm{\labeling}=
    \textstyle\bigwedge_{\{(\aEv,\aVal)\in(\aEvs\times\Val)\mid\labeling(\aEv)=\DRP{}{\aVal}\}}(\uReg{\aEv}\EQ\aVal)
    \textwhere \aEvs=\fdom(\labeling).
  \end{math}    
  We say that $\aForm$ is \emph{$\labeling$-inconsistent} if $\aForm\land\regForm{\labeling}$ is unsatisfiable.
  We can then require \labeltext[\textsc{x}4]{(\textsc{x}4)}{tr-false}
  if $\bForm$ is $\labeling$-inconsistent then $\aTr{}{\bForm}$ is
  $\labeling$-inconsistent.  \ref{tr-false} is not needed for the results of
  this paper, therefore we have elided it from the main development.}

\begin{definition}
  \label{def:trans}
  A \emph{predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{multicols}{2}
    \begin{enumerate}[,label=(\textsc{x}\arabic*),ref=\textsc{x}\arabic*]
    \item \label{tr-and}
      $\aTr{}{\bForm_1\land\bForm_2}\riff\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$,    
    \item \label{tr-or}
      $\aTr{}{\bForm_1\lor\bForm_2}\riff\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$,
    \item \label{tr-implies}
      if $\aForm \rimplies \bForm$, then $\aTr{}{\aForm} \rimplies
      \aTr{}{\bForm}$.
    % \item \label{tr-false}
    %   $\aTr{}{\FALSE}$ is $\FALSE$,    
    \end{enumerate}
  \end{multicols}
\end{definition}
\noindent
We consistently use $\bForm$ as the parameter of predicate transformers.
Note that substitutions ($\bForm[\aExp/\aReg]$ and $\bForm[\aExp/\aLoc]$) and
implications on the right ($\aForm\limplies\bForm$) are predicate
transformers.

As discussed in \S\ref{sec:intro}, predicate transformers suffice for
sequentially consistent models, but not relaxed models, where dependency
calculation is crucial.  For dependency calculation, we use a \emph{family}
of predicate transformers, indexed by sets of events. In sequential
composition, we will use $\aTr{\Cdown{\aEv}}{}$ as the predicate transformer
applied to event $\aEv$ where $\bEv\in(\Cdown{\aEv})$ if $\bEv<\aEv$.  % We
% call $\Cdown{\aEv}$ the \emph{dependent set} of $\aEv$, and
% $\aEvs\setminus\Cdown{\aEv}$ the \emph{independent set}.

\begin{definition}
  \label{def:family}
  A \emph{family of predicate transformers} over $\aEvs$ consists of a
  predicate transformer $\aTr{\bEvs}{}$ for each $\bEvs\subseteq\AllEvents$,
  such that if $\cEvs \cap \aEvs \subseteq \bEvs$ then $\aTr{\cEvs}{\bForm}
  \rimplies \aTr{\bEvs}{\bForm}$.
  %We write $\aTrAbbrv{\aEvs}{\bForm}$ as an abbreviation of $\aTr{\aEvs}{\bForm}$.
\end{definition}
In a family of predicate transformers, the transformer of a smaller set must
entail the transformer of a larger set.  Thus bigger sets are \emph{better}
and $\aTrAbbrv{\aEvs}{\bForm}$---the transformer of the biggest set---is the
\emph{best}.  (The definition is insensitive to events outside $\aEvs$---it
is for this reason that we have taken $\bEvs\subseteq\AllEvents$ rather than
$\bEvs\subseteq\aEvs$.)

In sequential composition, adding more order can only increase the size of
${\Cdown{\aEv}}{}$.  Following \refdef{def:family}, the larger
${\Cdown{\aEv}}{}$ is, the better, at least in terms of satisfying
preconditions.  Thus more order means weaker preconditions.

\begin{definition}
  \label{def:pomset}
  \input{fig-def.tex}
\end{definition}
Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.
We give the semantics of programs $\sembase{}$ in \reffig{fig:seq}.
% Let $\Pom$ be the set of all pomsets.
%
The model has $6$ components, which can be daunting at first glance.  To aid
the reader, we use consistent numbering throughout. For example, item $6$
always refers to the order relation.

The core of the model is a pomset, which includes a set of events
\eqref{pom-E}, a labeling \eqref{pom-lambda}, and an order \eqref{pom-le}.
As usual, we write $\bEv\le\aEv$ to mean $\bEv\lt\aEv$ or $\bEv=\aEv$.
%
On top of this basic structure, \ref{pom-kappa}--\ref{pom-term} add a layer
of logic.  For each pomset, \ref{pom-term} provides a termination condition.
For each event in a pomset, \ref{pom-kappa} provides a precondition.  For
each set of events in a pomset, \ref{pom-tau} provides a predicate
transformer.  Sequential dependency is calculated by $\labelingForm'_2$ in
the semantics of sequential composition.

\todo{I struggled with the concept of a ``termination condition''. Can you add
  a sentence or two of intuition here?}

\todo{Fig 1. Please explain why (R4b) is defined in this way. In addition, why
  can the set E of events be empty for read and write operations?}

Before discussing the details of the model, we note that the semantics
satisfies the expected monoid laws, as well as some laws concerning the
conditional. We have verified \reflem{lem:monoid} and
\reflem{lem:if}\ref{lem:if:seq} in Coq\footnote{Specifically, we have proven
  these results for the semantics of \reffig{fig:seq} with the refinements of
  \textsection\ref{sec:read-read}, \textsection\ref{sec:semreg}, and
  \textsection\ref{sec:semca}}.  Similar laws apply to parallel composition;
although note that $\sem{\aCmd\RPAR\SKIP}\neq\sem{\aCmd}$, since this
asymmetric operator throws away thread state from the left.

\begin{lemma}
  \label{lem:monoid}
  
  \begin{enumerate*}[label=(\alph*),ref=\alph*]
  \item \label{monoid:unit}
    \begin{math}
      \sem{\aCmd}
      % =
      % \xPARP{\aCmd}{\SKIP}
      =
      \sem{\xSEMIP{\aCmd}{\SKIP}}
      =
      \sem{\xSEMIP{\SKIP}{\aCmd}}.
    \end{math}

  % \\\item \label{monoid:par}
  %   \begin{math}
  %     \xPAR{\xPARP{\aCmd_1}{\aCmd_2}}{\aCmd_3}
  %     =
  %     \xPAR{\aCmd_1}{\xPARP{\aCmd_2}{\aCmd_3}}.
  %   \end{math}

  \item \label{monoid:seq}
    \begin{math}
      \sem{\xSEMI{\xSEMIP{\aCmd_1}{\aCmd_2}}{\aCmd_3}}
      =
      \sem{\xSEMI{\aCmd_1}{\xSEMIP{\aCmd_2}{\aCmd_3}}}.
    \end{math}

  \end{enumerate*}      
\end{lemma}
The proof of \eqref{monoid:unit} requires \ref{pom-term-tau} for
the termination condition in $\xSEMIP{\aCmd}{\SKIP}$.
\eqref{monoid:seq} requires both
conjunction closure (\ref{tr-and}, for the termination condition) and disjunction
closure (\ref{tr-or}, for the predicate transformers themselves).
\eqref{monoid:seq} also requires that \ref{seq-le} enforce projection as
well as inclusion (see the definition of $\rextendsdef{}{}$).

\begin{lemma}
  \label{lem:if}

  \begin{enumerate*}[label=(\alph*),ref=\alph*]
    \setcounter{enumi}{2}
  \item \label{lem:if:dead}
    \begin{math}
      \sem{\xIFTHEN{\aForm}{\aCmd_1}{\aCmd_2}}
      \supseteq
      \sem{\aCmd_1}
    \end{math}
    if $\aForm$ is a tautology.

    % \\\item \label{lem:if:if}
    % \begin{math}
    %   \sem{\xIFTHEN{\aForm}{
    %     \xIFTHEN{\bForm}{\aCmd}{}
    %   }{}}
    %   =
    %   \sem{\xIFTHEN{\aForm\land\bForm}{\aCmd}{}}.
    % \end{math}

  \\\item \label{lem:if:elim}
    \begin{math}
      \sem{\xIFTHEN{\aForm}{\aCmd}{\aCmd}}
      \supseteq
      \sem{\aCmd}.
    \end{math}

  \\\item \label{lem:if:seq}
    \begin{math}
      \sem{\xIFTHEN{\aForm}{
        \xSEMI{\aCmd_1}{\aCmd_3}
      }{
        \xSEMI{\aCmd_2}{\aCmd_3}
      }}
      \supseteq
      \sem{\xSEMI{
        \xIFTHEN{\aForm}{\aCmd_1}{\aCmd_2}
      }{
        \aCmd_3
      }}.
    \end{math}

  \\\item \label{lem:seq:if}
    \begin{math}
      \sem{\xIFTHEN{\aForm}{
        \xSEMI{\aCmd_1}{\aCmd_2}
      }{
        \xSEMI{\aCmd_1}{\aCmd_3}
      }}
      \supseteq
      \sem{\xSEMI{
        \aCmd_1
      }{
        \xIFTHEN{\aForm}{\aCmd_2}{\aCmd_3}
      }}.
    \end{math}

  \\\item  \label{lem:ifelse:if:if}
    \begin{math}
      \sem{\xSEMI{
        \xIFTHEN{\lnot\aForm}{\aCmd_2}{}
      }{
        \xIFTHEN{\aForm}{\aCmd_1}{}
      }}
      \subseteq
      \sem{\xIFTHEN{\aForm}{\aCmd_1}{\aCmd_2}}
      \supseteq
      \sem{\xSEMI{
        \xIFTHEN{\aForm}{\aCmd_1}{}
      }{
        \xIFTHEN{\lnot\aForm}{\aCmd_2}{}
      }}.
    \end{math}
    
  % \\\item  \label{lem:ifelse:if:if1}
  %   \begin{math}
  %     \sem{\xIFTHEN{\aForm}{\aCmd_1}{\aCmd_2}}
  %     \supseteq
  %     \sem{\xSEMI{
  %       \xIFTHEN{\aForm}{\aCmd_1}{}
  %     }{
  %       \xIFTHEN{\lnot\aForm}{\aCmd_2}{}
  %     }}.
  %   \end{math}
    
  % \\\item  \label{lem:ifelse:if:if2}
  %   \begin{math}
  %     \sem{\xIFTHEN{\aForm}{\aCmd_1}{\aCmd_2}}
  %     \supseteq
  %     \sem{\xSEMI{
  %       \xIFTHEN{\lnot\aForm}{\aCmd_2}{}
  %     }{
  %       \xIFTHEN{\aForm}{\aCmd_1}{}
  %     }}.
  %   \end{math}
  \end{enumerate*}      
\end{lemma}
In \textsection\ref{sec:semca}, we refine the semantics to validate the
reverse inclusions for (\ref{lem:if:elim}--\ref{lem:seq:if}).  Although the
semantics of \reffig{fig:seq} validates the reverse inclusions for
\eqref{lem:ifelse:if:if}, these do not hold for \PwTmca{} (see \textsection\ref{sec:outro}).
%\todo{Mention \PwTpo{}/\PwTc{}?}
% (\textsection\ref{sec:mca})
% (\textsection\ref{sec:c11})?

The semantics is also closed with respect to augmentation.  $\aPS_2$ is an
\emph{augment} of $\aPS_1$ if all fields are equal except, perhaps, the
order, where we require ${\lt_2}\supseteq{\lt_1}$.  In examples, we typically
consider pomsets that are augment-minimal.  One intuitive reading of augment
closure is that adding order can only cause preconditions to weaken.  % The
% proof is straightforward, by induction on the definition of $\sembase{}$.
% \begin{definition}
%   \label{def:augment}
%   $\aPS_2$ is an \emph{augment} of $\aPS_1$ if all fields are equal except,
%   perhaps, the order, where we require ${\lt_2}\supseteq{\lt_1}$.
%   % \begin{multicols}{4}
%   %   \begin{enumerate}
%   %   \item $\aEvs_2=\aEvs_1$,
%   %   \item $\labelingAct_2(\aEv)=\labelingAct_1(\aEv)$,
%   %   \item $\labelingForm_2(\aEv) \riff \labelingForm_1(\aEv)$,
%   %   \item $\aTr[2]{\bEvs}{\bForm}\riff \aTr[1]{\bEvs}{\bForm}$,
%   %   \item $\aTerm[2] \riff \aTerm[1]$,
%   %   \item ${\le_2}\supseteq{\le_1}$,
%   %   \item ${\rrfx_2}={\rrfx_1}$.
%   %   \end{enumerate}
%   % \end{multicols}
% \end{definition}
\begin{lemma}
  % Suppose $\aPS_1\in\sembase{\aCmd}$.
  If $\aPS_1\in\sembase{\aCmd}$ and $\aPS_2$  augments $\aPS_1$ then $\aPS_2\in\sembase{\aCmd}$.
  % \item If $\aPS_2$ is a downset of $\aPS_1$ then $\aPS_2\in\sembase{\aCmd}$.
  % \end{lemma}

  % \vspace{-.5\baselineskip}
  % \begin{proof}
  %   Induction on the definition of $\sembase{}$.
  % \end{proof}
\end{lemma}


\todo{A compiler does not have to use the proposed semantics
directly, i.e., for calculating dependencies.  Instead, the semantics is
meant to be a wrapper that validates some reasonable set of compiler
optimizations. A compiler may make more conservative assumptions about
dependencies than the semantics. This is explicitly allowed by Lemma 4.8
(augment closure).}




% \begin{definition}
%   Suppose $\aRel_1:\aEvs_1\times\aEvs_1$ and $\aRel_2:\aEvs_2\times\aEvs_2$.
%   We say $\aRel \rextendsdef{\aRel_1}{\aRel_2}$ if
%   $\aRel\supseteq (\aRel_1\cup \aRel_2)$ and
%   $\aRel\cap(\aEvs_1\times \aEvs_1) = \aRel_1$ and
%   $\aRel\cap(\aEvs_2\times \aEvs_2) = \aRel_2$.
% \end{definition}

% We include empty sets as prep for adding while loops.


% In diagrams, we use different colors for arrows.  We distinguish
% $\rrfx$ edges that are included in order from those that are not.
% \begin{itemize}
% \item \makebox{$\aEv\xrf\bEv$} arises from $\rrfx$, where $\aEv\le\bEv$,
% \item \makebox{$\aEv\xrfint\bEv$} arises from $\rrfx$, where $\lnot(\aEv\le\bEv)$.
% \end{itemize}
% To help the reader understand why order is included, we also different colors
% for arrows induced by order.  We adopt the following conventions:
% \begin{itemize}  
%   % \item relaxed accesses are blue, with a single border,
%   % \item synchronized accesses are red, with a double border,
%   % \item \makebox{$\aEv\xrf\bEv$} arises from fulfillment, where $\aEv$ \emph{matches} $\bEv$,
%   % \item \makebox{$\aEv\xwk\bEv$} arises either from fulfillment, where $\aEv$
%   %   \emph{blocks} $\bEv$, or from prefixing, where $\aEv$ was prefixed before
%   %   $\bEv$ and their actions \emph{conflict},
% \item \makebox{$\aEv\xwk\bEv$} arises from \emph{fulfillment},
% \item \makebox{$\aEv\xpo\bEv$} arises from control/data/address \emph{dependency},
% \item \makebox{$\aEv\xsync\bEv$} arises from \emph{synchronized access}.
% \end{itemize}

\input{fig-seq.tex}
\subsection{Pomsets and Complete Pomsets}
\label{sec:ex:pomset}
\label{sec:ex:term}


\todo{We include empty pomsets in the semantics of reads/writes/fences to
  allow them to appear on the false side of a conditional, for example, since
  complete pomsets require that all preconditions are tautologies.  (Already
  added at end of 2.2, but probably good to repeat.)}


Ignoring the logic, the definitions are straightforward.  Reads and writes
map to pomsets with at most one event.  $\SKIP$ maps to the empty pomset.
Note only that $\sembase{\PW{x}{1}}$ can write any value $\aVal$; the fact
that $\aVal$ must be $1$ is captured in the logic.

The structural rules combine pomsets: $\sPAR{}{}$ performs disjoint union,
inheriting labeling and order from the two sides.  $\sSEMI{}{}$ and $\sIF{}$
perform a union.  We say
that $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ \emph{coalesce} if $\bEv=\aEv$.
As a trivial consequence of using union rather than disjoint union,
\ref{seq-E} validates \emph{mumbling} \cite{DBLP:journals/iandc/Brookes96} by
coalescing events.  For example
\begin{math}
  \sembase{\PW{x}{1} \SEMI \PW{x}{1}}
\end{math}
includes the singleton pomset
\begin{tikzinlinesmall}[node distance=.5em and 1.5em]
  \event{a1}{\DW{x}{1}}{}
\end{tikzinlinesmall}.  From this it is easy to see that
\begin{math}
  \sembase{\PW{x}{1}\SEMI\PW{x}{1}}
  \supseteq
  \sembase{\PW{x}{1}}
\end{math}
is a valid refinement.  It is equally obvious that
\begin{math}
  \sem{\PW{\aLoc}{1}} 
  \not\supseteq
  \sem{\PW{\aLoc}{1} \SEMI \PW{\aLoc}{1}}
\end{math}
is not a valid refinement, since the latter includes a two-element pomset,
but the former does not. ({These are distinguished by the context:
  \begin{math}
    \hole{} \PAR
    \PR{x}{r} \SEMI
    \PW{x}{2} \SEMI
    \PR{x}{s}\SEMI
    \IF{\aReg {=} \bReg} \THEN \PW{\cLoc}{1} \FI.
  \end{math}})

In complete pomsets, \ref{top-term} requires that $\aTerm$ is a tautology,
capturing termination.  In $\sSTORE{}{}$, \ref{write-term} ensures that all
writes are included in complete pomsets---note that
$\kappaE{\emptyset} = \FALSE$.  This also ensures
$\sembase{\PW{x}{1}}\not\supseteq\sembase{\IF{\aForm}\THEN\PW{x}{1}\FI}$
(unless $\aForm$ is a tautology), since
$\sembase{\IF{\aForm}\THEN\PW{x}{1}\FI}$ includes the empty set with
$\aTerm\riff\lnot\aForm$, but $\sembase{\PW{x}{1}}$ can only
include the empty set with $\aTerm\riff\FALSE$.

In addition, \ref{write-term} ensures that complete pomsets do not
include bogus writes.  Suppose $\aPS\in\sembase{\PW{x}{1}}$.  As we noted
above, $\aPS$ can include $(1{=}\aVal\mid\DW{x}{\aVal})$, for any value
$\aVal$.  In complete pomsets, however, \ref{write-term} requires
that $\aTerm$ implies $1{=}\aVal$.  We might wish to require that all preconditions be satisfiable.  However,
unsatisfiable writes can become satisfiable via merging:
% Nonetheless, it is important that
% \ref{write-term-nonempty} specifies $\aTerm\riff\aExp{=}\aVal$ rather than
% $\aTerm\riff\TRUE$, since 
\begin{align*}
  \begin{gathered}
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a}{\DW{x}{1}}{}      
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{b}{2{=}3\bigmid\DW{x}{3}}{}      
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \IF{\aExp}\THEN\PW{x}{3}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{c}{\aExp\bigmid\DW{x}{3}}{}      
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
By merging, the semantics allows the following:
\begin{align*}
  \begin{gathered}
    \PW{x}{1}
    \SEMI
    \PW{x}{2}
    \SEMI
    \IF{\aExp}\THEN\PW{x}{3}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a}{\DW{x}{1}}{}      
        \event{c}{\aExp\bigmid\DW{x}{3}}{right=of a}
        %\wki{a}{c}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
This pomset is incomplete, however, since $\aTerm\riff2{=}3$.

In $\sLOAD{}{}$, $\aTerm$ depends on the mode. \ref{read-term-empty} ensures
that all acquiring reads are included in complete pomsets.  Instead
\ref{read-term-nonempty} states that relaxed reads are optional: $\aTerm$ is
alway true for relaxed reads.  From this, it is easy to see that
\begin{math}
  \sembase{\PR{x}{r}}
  \supseteq
  \sembase{\SKIP}
\end{math}
is a valid refinement (where the default mode is $\mRLX$).

Ignoring predicate transformers, the $\sSEMI{}{}$ rule
\ref{seq-term} takes $\aTerm$ to be $\aTerm_1\land\aTerm_2$.  This is as
expected: the program terminates if both subprograms terminate.

In $\sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$, the termination condition
\eqref{if-term} is $(\aForm\land\aTerm[1])\lor(\neg\aForm\land\aTerm[2])$:
the program terminates as long as the taken branch terminates.
Thus
\begin{math}
  \sembase{\IF{\TRUE} \THEN\PW{x}{1} \ELSE\PW{y}{1} \FI}
\end{math}
contains a complete pomset with exactly one event: $\DWP{x}{1}$.  To
construct this pomset, we take the singleton from the left and the empty set
from the right.  This is a general principle: for code that contributes no
events at top-level, use the empty set.

\subsection{Preconditions, Predicate Transformers, and Data Dependencies}
\label{sec:ex:data}


Preconditions are used to calculate dependencies.  They also determine which
events can appear in a pomset.  In a complete pomset, \ref{top-kappa}
requires that every precondition $\labelingForm(\aEv)$ is a tautology.  Using
\ref{write-kappa},
\begin{math}
  \sembase{\PW{x}{2}}
\end{math}
cannot include a complete pomset with event $\DWP{x}{3}$, since $2{=}3$ is not a
tautology.

We defer discussion of $\Q{\aLoc}$ to \textsection\ref{sec:q}. Here we assume
we take $\Q{\aLoc}=\TRUE$, for all $\aLoc$.
% that occur in \ref{write-tau} and \ref{read-tau} serve similar purpose.  We defer discussion of these until
% \textsection\ref{sec:q}.
% We first explain preconditions and predicate transformers using data
% dependencies.  We ignore $\sIF{}$ and $\Q{\aLoc}$, deferring discussion of
% these to \textsection\ref{sec:ex:control} and \textsection\ref{sec:q}.

% Predicate transformers affect preconditions in the definition of
% $\labelingForm'_2$, which is used in \ref{seq-kappa2} and \ref{seq-kappa12}
% to calculate dependencies.  In this subsection we ignore predicate
% transformers, taking $\labelingForm'_2=\labelingForm_2$.

% In top-level pomsets, \ref{top-kappa} requires that every precondition
% $\labelingForm(\aEv)$ is a tautology.

Note that $\sembase{\aCmd_1 \RPAR \aCmd_2}$ is asymmetric, taking the
predicate transformer for $\aCmd_2$ in \ref{par-tau}.

Preconditions are discharged during sequential composition by applying
predicate transformers $\aTr[1]{}{}$ from the left to preconditions
$\labelingForm_2(\aEv)$ on the right.  The specific rule is
\ref{seq-kappa},
% \ref{seq-kappa2} and \ref{seq-kappa12},
which uses the transformed predicate
$\labelingForm'_2(\aEv)=\aTr[1]{\Cdown{\aEv}}{\labelingForm_2(\aEv})$, where
$\Cdown{\aEv}=\{ \cEv \mid \cEv \lt \aEv \}$ is the set of events that
precede $\aEv$ in causal order.  We call $\Cdown{\aEv}$ the \emph{dependent
  set} for $\aEv$.  Then $\aEvs\setminus(\Cdown{\aEv})$ is the
\emph{independent set}. % for $\aEv$.

% Sequential composition uses the usual rule for composition of predicate
% transformers (but preserving the indexing set). For the pomset, we take the
% union of their events, preserving actions, but crucially in
% cases~\ref{seq-kappa2} and~\ref{seq-kappa12} we apply a predicate transformer
% $\aTr[1]{\cEvs}{}$ from the left-hand side to a precondition
% $\labelingForm_2(\aEv)$ from the right-hand side to build the precondition
% $\labelingForm'_2(\aEv)$.  The indexing set $\cEvs$ for the predicate
% transformer is $\{ \cEv\mid \cEv<\aEv \}$, so can depend on the causal order.


Before looking at the details, it is useful to have a high-level view of how
nontrivial preconditions and predicate transformers are introduced.  (We
discuss address dependencies in \textsection\ref{sec:addr}.)
\begin{multicols}{2}
  Preconditions are introduced in: 
  \begin{itemize}
  %\item[\eqref{seq-kappa}] for release actions,
  \item[\eqref{if-kappa}] for control dependencies, 
  \item[\eqref{write-kappa}] for data dependencies on writes.
  \item[] 
  \end{itemize}
  \columnbreak

  Predicate transformers are introduced in:
  \begin{itemize}
  \item[\eqref{read-tau-dep}] for reads in the dependent set,
  \item[\eqref{read-tau-ind}] for reads in the independent set,
  \item[\eqref{write-tau}] for writes.
  \end{itemize}
  % \item These are glued together in \ref{seq-kappa}.
  %   \begin{itemize}
  %   \item \ref{seq-kappa2}  handles non-coalescing events,
  %   \item \ref{seq-kappa12} handles coalescing events.
  %   \end{itemize}
\end{multicols}


The rules track dependencies.  We discuss data dependencies \eqref{write-kappa}
here and control dependencies \eqref{if-kappa} in
\textsection\ref{sec:ex:control}.  Unless otherwise noted, we assume pomsets
are \emph{complete} and \emph{augment-minimal}.  % We do not discuss
% \ref{seq-kappa} further.  It simply ensures that all writes are
% present before a release, even for incomplete pomsets (see
% \textsection\ref{sec:ex:term}).

A simple example of a data dependency is a pomset
$\aPS\in\sem{\PR{x}{r}\SEMI \PW{y}{r}}$.  If $\aPS$ is complete, it must have
two events. Then $\sSEMI{}{}$ requires that there are %$\aVal,\bVal\in\Val$ and
$\aPS_1\in \sem{\PR{x}{r}}$ and $\aPS_2\in \sem{\PW{y}{r}}$ of the form:
\begin{align*}
  \tag{$\dagger\dagger$}\label{eq2}
  \begin{gathered}
    \PR{x}{r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aVal{=}r\limplies\bForm}{}
        \eventr{\bEv}{a1}{\DR{x}{\aVal}}{left=of xd}
        \xform{xi}{(\aVal{=}r\lor x{=}r)\limplies\bForm}{left=.5em of a1}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\bForm[r/y]}{}
        \eventr{\aEv}{a2}{r{=}\bVal\bigmid\DW{y}{\bVal}}{left=of xd}      
        \xform{xi}{\bForm[r/y]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
First we consider the case that $\aVal=\bVal$.  For example, if $\aVal=\bVal=1$, we have:
\begin{align*}
  \begin{gathered}
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{1{=}r\limplies\bForm}{}
        \eventr{\bEv}{a1}{\DR{x}{1}}{left=of xd}
        \xform{xi}{(1{=}r\lor x{=}r)\limplies\bForm}{left=.5em of a1}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\bForm[r/y]}{}
        \eventr{\aEv}{a2}{r{=}1\bigmid\DW{y}{1}}{left=of xd}      
        \xform{xi}{\bForm[r/y]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
For the read, the dependent transformer $\smash{\aTr[1]{\{\bEv\}}{}}$ is
$1{=}r\limplies\bForm$; the independent transformer $\aTr[1]{\emptyset}{}$ is
$(1{=}r\lor x{=}r)\limplies\bForm$.  These are determined by
\ref{read-tau-dep} and \ref{read-tau-ind}, respectively.  For the write, both
% the dependent transformer
$\smash{\aTr[2]{\{\aEv\}}{}}$ and
% the independent transformer
$\aTr[2]{\emptyset}{}$ are $\bForm[r/y]$, as are determined by
\ref{write-tau}.
%
Combining these into a single pomset, we have:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{1{=}r\limplies\bForm[r/y]}{}
        \eventr{\bEv}{a1}{\DR{x}{1}}{left=of xd}
        \xform{xi}{(1{=}r\lor x{=}r)\limplies\bForm[r/y]}{left=.5em of a1}
        \eventr{\aEv}{a2}{\aForm\bigmid\DW{y}{1}}{right=of xd}      
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
By \ref{seq-tau}, predicate transformers are determined by composition; thus
$\aTr{\bEvs}{\bForm}$ is $\aTr[1]{\bEvs}{\aTr[2]{\bEvs}{\bForm}}$.  Since the
transformer does not depend on whether the write is included, we do not draw
dependencies for the write in the diagram.

Note that both \ref{read-tau-dep} and \ref{read-tau-ind} degenerate to
\ref{read-tau-empty} when $\labelingForm(\aEv)=\FALSE$.

Turning to the precondition $\aForm$ on the write, recall that in order for
$\aEv$ to participate in a top-level pomset, the precondition $\aForm$ must
be a tautology at top-level.  There are two possibilities.
\begin{itemize}
\item If $\bEv\lt\aEv$ then we apply the dependent transformer and
  $\aForm\riff(1{=}r\limplies r{=}1)$, a tautology.
\item If $\bEv\not\lt\aEv$ then we apply the independent transformer and
  $\aForm\riff((1{=}r\lor x{=}r)\limplies r{=}1)$.  Under the assumption that $r$
  is bound (see \cref{footnote:false}), this is logically equivalent to $(x{=}1)$.
  % (We make this more
  % precise in \textsection\ref{sec:false}.)
\end{itemize}
Eliding transformers, the two outcomes are:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{x{=}1\bigmid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
The independent case on the right can only participate in a top-level pomset
if the precondition $(x{=}1)$ is discharged.  To do so, we must prepend a
pomset $\aPS_0$ that writes $1$ to $x$:
\begin{align*}
  \begin{gathered}
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\bForm[1/x]}{}
        \eventr{\cEv}{a2}{1{=}1\bigmid\DW{x}{1}}{left=of xd}      
        \xform{xi}{\bForm[1/x]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{1}\SEMI \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\cEv}{a0}{1{=}1\bigmid\DW{x}{1}}{}
        \eventr{\bEv}{a1}{\DR{x}{1}}{right=of a0}
        \eventr{\aEv}{a2}{1{=}1\bigmid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Here we apply the predicate transformer $\aTr[0]{\emptyset}{}$ to $(x{=}1)$,
resulting in the tautology $(1{=}1)$.


Now suppose that $\aVal\neq\bVal$ in \eqref{eq2}.  Again there are two
possibilities. Taking $\aVal{=}0$ and $\bVal{=}1$:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{0}}{}
        \eventr{\aEv}{a2}{0{=}r\limplies r{=}1\bigmid\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{0}}{}
        \eventr{\aEv}{a2}{(0{=}r\lor x{=}r)\limplies r{=}1\bigmid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Assuming that $r$ is bound, both preconditions on $\aEv$ are unsatisfiable.

If a write is independent of a read, then clearly no order is imposed between
them.  For example, the precondition of $\aEv$ is a tautology in:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{0{=}r\limplies\bForm[r/y]}{}
        \eventr{\bEv}{a1}{\DR{x}{0}}{left=of xd}
        \xform{xi}{(0{=}r\lor x{=}r)\limplies\bForm[r/y]}{left=.5em of a1}
        \eventr {\aEv}{a2}{(0{=}r\lor x{=}r)\limplies 1{=}1\bigmid\DW{y}{1}}{right=of xd}      
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
% \begin{gather*}
%   \PR{x}{r}\SEMI \PW{y}{1}
%   \\
%   \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
%       \event{rx0}{\DR{x}{0}}{}
%       \event{wy1}{1{=}1 \bigmid \DW{y}{1}}{right=of rx0}
%     \end{tikzinline}}
% \end{gather*}


\subsection{Control Dependencies}
\label{sec:ex:control}

In $\sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$, the predicate transformer
\eqref{if-tau} is
$(\aForm\land\aTr[1]{\bEvs}{\bForm})\lor(\neg\aForm\land\aTr[2]{\bEvs}{\bForm})$,
%$\aTerm \rimplies (\aForm\land\aTerm[1])\lor(\neg\aForm\land\aTerm[2])$,
which is the disjunctive equivalent of \citeauthor{DBLP:journals/cacm/Dijkstra75}'s
conjunctive formulation: $(\aForm\limplies\aTr[1]{\bEvs}{\bForm})\land(\neg\aForm\limplies\aTr[2]{\bEvs}{\bForm})$.
% $\aTerm \rimplies (\aForm\limplies\aTerm[1])\land(\neg\aForm\limplies\aTerm[2])$.
%  \citet{DBLP:journals/cacm/Dijkstra75} used conjunctive normal form.
%  Recall that
%  \href{https://www.wolframalpha.com/input/?i=\%28a+and+b\%29+or+\%28not+a+and+c\%29}{$(\aForm\land\cForm_1)\lor(\neg\aForm\land\cForm_2)$}
%  is logically equivalent to
%  \href{https://www.wolframalpha.com/input/?i=\%28a+implies+b\%29+and+\%28\%28not+a\%29+implies+c\%29}{$(\aForm\limplies\cForm_1)\land(\neg\aForm\limplies\cForm_2)$}. 

This semantics validates dead code elimination:
if $\aExp{\neq}0$ is a tautology then
\begin{math}
  \sem{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} \supseteq
  \sem{\aCmd_1}.
\end{math}
The reverse inclusion does not hold.

For events from $\aEvs_1$, \ref{if-kappa} requires
$\aForm\land\labelingForm_1(\aEv)$. For events from $\aEvs_2$,
\ref{if-kappa} requires $\lnot\aForm\land\labelingForm_2(\aEv)$.  For
coalescing events in $\aEvs_1\cap\aEvs_2$, \ref{if-kappa} requires
$(\aForm\land\labelingForm_1(\aEv)) \lor
(\lnot\aForm\land\labelingForm_2(\aEv))$.  This semantics allows common code
to be lifted out of a conditional, validating the transformation
\begin{math}
  \sem{\IF{\aExp}\THEN\aCmd\ELSE\aCmd\FI} \supseteq
  \sem{\aCmd}.
\end{math}



By allowing events to coalesce, \ref{if-kappa} ensures that control
dependencies are calculated semantically, rather than syntactically.  For example, consider
$\aPS\in\sem{\IF {r{=}1} \THEN \PW{y}{r} \ELSE \PW{y}{1}\FI}$, which is build
from $\aPS_1\in\sem{\PW{y}{r}}$ and $\aPS_2\in\sem{\PW{y}{1}}$ such as:
\begin{align*}
  \begin{gathered}
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventr{e}{wy1}{r{=}1 \bigmid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PW{y}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventr{e}{wy1}{1{=}1 \bigmid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r{=}1} \THEN \PW{y}{r} \ELSE \PW{y}{1}\FI
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventr{e}{wy1}{(r{=}1 \limplies r{=}1) \land (r{\ne}1 \limplies 1{=}1) \bigmid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}  
\end{align*}
Here, the precondition in the combined pomset is a tautology, independent of
$r$.

Control dependencies are eliminated in the same way as data dependencies.
For example:
\begin{align*}
  \begin{gathered}
    \PR{x}{r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aVal{=}r\limplies\bForm}{}
        \eventr{\bEv}{a1}{\DR{x}{\aVal}}{left=of xd}
        \xform{xi}{(\aVal{=}r\lor x{=}r)\limplies\bForm}{left=.5em of a1}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r{=}1}\THEN\PW{y}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aTr[2]{\{\aEv\}}{\bForm}}{}
        \eventr{\aEv}{a2}{r{=}1\bigmid\DW{y}{\bVal}}{left=of xd}      
        \xform{xi}{\aTr[2]{\emptyset}{\bForm}}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
where
\begin{math}
  \aTr[2]{\emptyset}{\bForm}
  \riff
  \aTr[2]{\{\aEv\}}{\bForm}
  \riff
  (r{=}1\land\bForm[1/y])
  \lor
  (r{\neq}1\land\bForm).
\end{math}
As for \eqref{eq2}, there
%Reasoning as we did for \eqref{eq2} in \textsection\ref{sec:ex:data}, there
are two possibilities:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \IF{r{=}1}\THEN\PW{y}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{1{=}r\limplies r{=}1\bigmid\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PR{x}{r}\SEMI \IF{r{=}1}\THEN\PW{y}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{(1{=}r\lor x{=}r)\limplies r{=}1\bigmid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}


\todo{Add example showing empty set on untaken branch.}

\subsection{A Refinement: No Dependencies into Reads}
\label{sec:read-read}

To avoid stalling the CPU pipeline unnecessarily, hardware does not
enforce control dependencies between reads.  To support if-introduction
(\textsection\ref{sec:semca}), software models must not distinguish control
dependencies from other dependencies.  Thus, we are forced to drop all
dependencies into reads.  To achieve this, we modify the definition of
$\labelingForm'_2$ in \reffig{fig:seq}.
% \begin{definition}
%   \label{def:semrr}
%   Let $\semrr{}$ be defined as in \reffig{fig:seq}, replacing the definition
%   of $\labelingForm'_2$ with:
\begin{displaymath}
  \labelingForm'_2(\aEv)=
  \begin{cases}
    \aTrAbbrv[1]{\aEvs_1}{\labelingForm_2(\aEv)} & \text{if}\; \labeling(\aEv) \;\text{is a}\sread
    \\
    \aTr[1]{\Cdown{\aEv}}{\labelingForm_2(\aEv)} & \text{otherwise, where}\; \Cdown{\aEv}=\{ \cEv \mid \cEv \lt \aEv \}
  \end{cases}
  % $\Cdown{\aEv}=\{ \cEv \mid \cEv \lt \aEv \}$ if $\labeling(\aEv)$ is a write, and $\Cdown{\aEv}=\aEvs_1$, otherwise
  % \Cdown{\aEv}=
  % \begin{cases}
  %   \{ \cEv \mid \cEv \lt \aEv \} & \textif \labeling(\aEv) \;\text{is a write}
  %   \\
  %   \aEvs_1 & \textotherwise
  % \end{cases}
\end{displaymath}
  % \end{definition}
Thus reads always use the ``best'' transformer, $\aTrAbbrv[1]{\aEvs_1}{}$.  In order for
non-reads to get a good transformer, they need to add order.
Throughout the remainder of the paper, we use this definition.

% (The lack of
% dependencies into reads is one of the factors complicating downset closure;
% see \textsection\ref{sec:downset} for a discussion.)

\subsection{Subtleties: Local Invariant Reasoning and Local State}
\label{sec:lir}
\label{sec:q}

%Two aspects of \reffig{fig:seq} are fairly obscure: First,
\ref{read-tau-ind} introduces locations into formula, in order to track the
local state of memory.  This is necessary to support local invariant
reasoning as in \jmm{} Causality Test Case 1 \eqref{TC1} \cite{PughWebsite}:
\begin{gather*}
  \taglabel{TC1}
  \begin{gathered}
    \PW{x}{0} \SEMI
    (\PR{x}{r}\SEMI\IF{r{\geq}0}\THEN \PW{y}{1} \FI
    \PAR
    \PW{x}{y})
    \\[-1ex]
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wx0}{\DW{x}{0}}{}
        \event{rx1}{\DR{x}{1}}{right=3em of wx0}
        \event{wy1}{\aForm\bigmid\DW{y}{1}}{right=of rx1}
        \event{ry1}{\DR{y}{1}}{right=3em of wy1}
        \event{wx1}{\DW{x}{1}}{right=of ry1}
        \po{ry1}{wx1}
        \rf[out=-168,in=-12]{wx1}{rx1}
        \rf{wy1}{ry1}
        %\wk[out=10,in=170]{wx0}{wx1}
        %\wki{wx0}{rx1}
      \end{tikzinline}}
    % \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
    %   \event{wy1}{0\geq0\bigmid\DW{y}{1}}{}
    %   \event{rx1}{\DR{x}{1}}{left=of wy1}
    %   \event{wx0}{\DW{x}{0}}{below left=-.2em and 2em of rx1}
    %   \event{ry1}{\DR{y}{1}}{below=of rx1}
    %   \event{wx1}{\DW{x}{1}}{right=of ry1}
    %   \po{ry1}{wx1}
    %   \rf[out=140,in=-20]{wx1}{rx1}
    %   \rf{wy1}{ry1}
    %   \wk[out=10,in=155]{wx0}{wx1}
    %   \wk{wx0}{rx1}
    % \end{tikzinline}}
  \end{gathered}
\end{gather*}
In order to allow this execution, the precondition $\aForm$ must be a tautology.
Using \ref{read-tau-ind} and \ref{write-tau}, the precondition is
\begin{math}
  \PBR{(1{=}r \lor x{=}r) \limplies r{\geq}0}[0/x]
\end{math}
which is 
\begin{math}
  \PBR{(1{=}r \lor 0{=}r) \limplies r{\geq}0}
\end{math}
which is indeed a tautology.  Intuitively, \ref{read-tau-ind} says that, to
be independent of the read action, subsequent preconditions must be
tautological under both $[v/r]$ and $[x/r]$.  Here $v$ is the value read, and
$x$ tracks the ``local state'' of the variable.  This idea is borrowed from
\citeauthor{DBLP:journals/pacmpl/JagadeesanJR20} %, which includes further examples.
%(See \textsection\ref{sec:ex:assoc} for a discussion of Skolemization.)
Local invariant reasoning requires that we track the state of variables in
the logic, not just registers.  This is one reason we use predicate
transformers rather than simple postconditions.

\todo{Put tc12$'$ first.  Fix the narrative.}
$\Q{x}$ ensures that the local state of $x$ is up-to-date when $x$ is read.
\ref{read-kappa} and \ref{read-tau} add these ``quiescence'' constraints,
which are simplified by \ref{write-tau}.
% Reads have trivial preconditions; thus, we introduce $\Q{x}$ in $\aTr{}{}$ \eqref{read-tau}
% not $\labelingForm$ \eqref{read-kappa}. 
Consider the following example 
\cite[\textsection6.3]{DBLP:conf/esop/PaviottiCPWOB20}:
\begin{gather*}
  \begin{gathered}    
    \PW{x}{1}
    \SEMI
    \PR{y}{r}
    \SEMI
    \mkern-8mu
    \begin{array}[t]{r}
      \IF{r\EQ0}\THEN
        \PW{x}{0}
        \SEMI
        \PR{x}{s}
        \SEMI
        \IF{s}\THEN
          \PW{z}{1}
        \FI
      \FI
      \\\ELSEnl
        \PR{x}{s}
        \SEMI
        \IF{s}\THEN
          \PW{z}{1}
        \FI
      \FI      
    \end{array}
    \PAR
    \mkern8mu
    \IF{z}\THEN
      \PW{y}{1}
    \FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a1}{\DW{x}{1}}{}
        \event{a2}{\DR{y}{1}}{right=of a1}
        %\event{a3}{\DW{x}{0}}{right=of a2}
        \event{a4}{\DR{x}{1}}{right=of a2}
        \event{a5}{\aForm\bigmid\DW{z}{1}}{right=of a4}
        \event{b1}{\DR{z}{1}}{right=5em of a5}
        \event{b2}{\DW{y}{1}}{right=of b1}
        %\po{a2}{a3}
        \po{b1}{b2}
        %\wki[out=15,in=165]{a1}{a3}
        %\wki{a3}{a4}
        \rf{a5}{b1}
        \rf[out=-170,in=-10]{b2}{a2}
        \po{a4}{a5}
      \end{tikzinline}}
  \end{gathered}
  \\
  \aForm \riff
  (\Q{y}\limplies 1{=}r \lor y{=}r)\;
  \begin{aligned}[t]
    \limplies\;&
    (r{=}0 \land ((\Q{x}[\FALSE/\Q{x}]\limplies 1{=}s)\limplies s{\neq}0))
    \\[-1ex]
    \land\;&
    (r{\neq}0 \land ((\Q{x}[1{=}1/\Q{x}]\limplies 1{=}s)\limplies
    s{\neq}0))
  \end{aligned}
\end{gather*}
\todo{Make this understandable.}
Note that the two branches of the conditional are the same except for the
leading $\PWP{x}{0}$.  Without $\Q{x}$, the precondition $\aForm$ is
$\TRUE$, which is a tautology, and the execution is
allowed, resulting in a violation of \drfsc.  To construct this pomset, we
have chosen the empty pomset for $\sembase{\PW{x}{0}}$.  The constraints on
complete pomsets do not filter out this pomset, since $\PW{x}{0}$ is in the
untaken branch of the conditional.  The problem here is that we have forgotten
the local state of $x$ in the untaken branch of the execution.  Nonetheless, we
are using the subsequent read.

With $\Q{x}$, the precondition of $\aForm$ is $\FALSE$.
%$\Q{x}[\FALSE/\Q{x}]$, which is unsatisfiable.
Intuitively, $\Q{x}$ requires that the most recent prior
write to $\aLoc$ must be in the pomset in order to read $\aLoc$.


We include $\Q{x}$ in \ref{read-kappa} to reduce the number of useless
pomsets---when $\Q{x}$ is false for $\PWP{x}{r}$, the read is useless and can
be eliminated by taking $\aEvs=\emptyset$.  By including $\Q{x}$ in
\ref{read-kappa}, we also guarantee initialization in complete pomsets:
\eqref{top-kappa} requires tautologies, which means that all variables must
be initialized sequentially in order to get rid of $\Q{\aLoc}$.

Control variant of \ref{TC12} with all initial values $0$:
\begin{gather*}
  \tag{\textsc{tc12}$'$}\label{TC12'}
  \begin{gathered}
    \PR{y}{r}\SEMI
    \IF{r}\THEN \PW{\REFVAR{1}}{1} \ELSE \PW{\REFVAR{0}}{1} \FI \SEMI
    \PR{\REFVAR{0}}{s}\SEMI
    \PW{x}{\BANG s}
    \PAR
    \PW{y}{\PR{x}{}}
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        % \event{iy}{\DW{y}{0}}{left=of a1}
        % \event{ix}{\DW{x}{0}}{right=2em of a2}
        \event{b1}{\DR{y}{1}}{}
        \event{b2}{\DW{\REFVAR{1}}{1}}{right=of b1}
        \event{b3}{\DR{\REFVAR{0}}{0}}{right=of b2}
        \event{b4}{\aForm\bigmid\DW{x}{1}}{right=of b3}
        \po{b1}{b2}
        \po{b3}{b4}
        \event{a1}{\DR{x}{1}}{right=3em of b4}
        \event{a2}{\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
        % \po[out=15,in=165]{b1}{b4}
        \rf[out=-170,in=-10]{a2}{b1}
        \rf{b4}{a1}
        % \wk[out=-15,in=-165]{iy}{a2}
        % \wk[out=-15,in=-165]{ix}{b4}
      \end{tikzinline}}
  \end{gathered}
  % \\
  % \aForm \riff
  % (\Q{y}\limplies 1{=}r \lor y{=}r)\;
  % \begin{aligned}[t]
  %   \limplies\;&
  %   (r{=}0 \land ((\Q{x}[\FALSE/\Q{x}]\limplies 1{=}s)\limplies s{=}0))
  %   \\[-1ex]
  %   \land\;&
  %   (r{\neq}0 \land ((\Q{x}[1{=}1/\Q{x}]\limplies 1{=}s)\limplies s{=}0))
  % \end{aligned}
\end{gather*}

Building the precondition $\aForm$ from right to left:
\begin{align*}
  \tag{$\PW{x}{s}$}
  \aForm_1 &\riff
  s{=}0
  \\
  \tag{Prepending $\PR{\REFVAR{0}}{s}$}
  \aForm_2 &\riff
  \PBR{\Q{\REFVAR{0}}\limplies 0{=}s}
  \limplies
  s{=}0
  \\
  \tag{Prepending $\IF{}$}
  \aForm_3 &\riff
  \PBR{
    r{\neq}0
    \land
    \aForm_2[1/\REFVAR{1}][\TRUE/\Q{\REFVAR{1}}]
  }\lor\PBR{
    r{=}0
    \land
    \aForm_2[1/\REFVAR{0}][\FALSE/\Q{\REFVAR{0}}]
  }
  \\[-1ex]
  &\riff
  \PBR{
    r{\neq}0
    \land
    \PBR{
      \PBR{
        \Q{\REFVAR{0}}
        \limplies
        0{=}s
      }
      \limplies
      s{=}0
    }
  } \lor\PBR{
    r{=}0
    \land
    % \PBR{
    % \FALSE
    % \limplies
    % 0{=}s
    % }
    %   \limplies
    s{=}0
  }
  \\
  \intertext{Dependent case:}
  \tag{Prepending $\PR{y}{r}$}
  \aForm_4 &\riff
  \PBR{
    \Q{y}
    \limplies
    1{=}r
  }
  \limplies
  \aForm_3
  \\
  \tag{Prepending Initializers}
  \aForm_5 &\riff
  1{=}r
  \limplies
  \PBR{
    r{\neq}0
    \land
    \PBR{
      0{=}s
      \limplies
      s{=}0
    }
  } \lor\PBR{
    r{=}0
    \land
    s{=}0
  }
  \\
  \intertext{Independent case:}
  \tag{Prepending $\PR{y}{r}$}
  \aForm'_4 &\riff
  \PBR{
    \Q{y}
    \limplies
    1{=}r
    \lor
    y{=}r
  }
  \limplies
  \aForm_3
  \\
  \tag{Prepending Initializers}
  \aForm'_5 &\riff
  \PBR{
    1{=}r
    \lor
    0{=}r
  }
  \limplies
  \PBR{
    r{\neq}0
    \land
    \PBR{
      0{=}s
      \limplies
      s{=}0
    }
  } \lor\PBR{
    r{=}0
    \land
    s{=}0
  }
\end{align*}

% As a sanity check, consider the
% following pomsets,
% \begin{align*}
%   \begin{gathered}    
%     \PR{y}{r}
%     \SEMI
%     \IF{r}\THEN
%       \PW{x}{1}
%     \FI
%     \SEMI
%     \PR{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a1}{\DR{y}{1}}{}
%         \event{a2}{1{=}r\limplies r{\neq}0\bigmid\DW{x}{1}}{right=of a1}
%         \event{a3}{1{=}r\limplies \aTr[1]{}{\Q{x}}\bigmid\DR{x}{2}}{right=of a2}
%         \po{a1}{a2}
%         %\wki{a2}{a3}
%       \end{tikzinline}}
%     \qquad\qquad\qquad
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a1}{\DR{y}{0}}{}
%         \event{a3}{0{=}r\limplies \aTr[2]{}{\Q{x}}\bigmid\DR{x}{2}}{right=of a1}
%       \end{tikzinline}}
%   \end{gathered}  
% \end{align*}
% where 
% \begin{math}
%   \aTr[1]{}{\bForm}=
%   (r{\neq}0 \land \bForm[1/x][1{=}1/\Q{x}])
%   \lor
%   (r{=}0 \land \bForm)
% \end{math}
% and
% \begin{math}
%   \aTr[2]{}{\bForm}=
%   (r{\neq}0 \land \bForm[1/x][\FALSE/\Q{x}])
%   \lor
%   (r{=}0 \land \bForm)
% \end{math}
% are the predicate transformers for the conditional writes, using
% \ref{write-tau-nonempty} and \ref{write-tau-empty} respectively.  The
% executions are complete since all preconditions are tautologies.

% Second, \ref{read-tau} introduces symbols $\Q{x}$ to ensure that local state
% is tracked accurately.  $\Q{x}$ only occurs positively in the preconditions
% of read actions.  Thus, per \textsection\ref{sec:read-read}, it does not add
% dependencies.  Instead, the purpose of $\Q{x}$ is to filter out pomsets with
% stale reads. Recall that all events in a pomset must have tautological
% preconditions in a complete pomset.  $\Q{x}$ strengthens the preconditions of
% reads.  Consider the following example from
% \cite[\textsection6.3]{DBLP:conf/esop/PaviottiCPWOB20}:
% \begin{align*}
%   \begin{gathered}    
%     \PW{x}{1}
%     \SEMI
%     \PR{y}{r}
%     \SEMI
%     \IF{r}\THEN
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \ELSE
%       \PW{x}{0}
%       \SEMI
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     \PAR
%     \IF{z}\THEN
%       \PW{y}{1}
%     \FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=1.5em]
%         \event{a1}{\DW{x}{1}}{}
%         \event{a2}{\DR{y}{1}}{right=of a1}
%         %\event{a3}{\DW{x}{0}}{right=of a2}
%         \event{a4}{\aForm\bigmid\DR{x}{1}}{right=of a2}
%         \event{a5}{\DW{z}{1}}{right=of a4}
%         \event{b1}{\DR{z}{1}}{right=3em of a5}
%         \event{b2}{\DW{y}{1}}{right=of b1}
%         %\po{a2}{a3}
%         \po{b1}{b2}
%         %\wki[out=15,in=165]{a1}{a3}
%         %\wki{a3}{a4}
%         \rf{a5}{b1}
%         \rf[out=-170,in=-10]{b2}{a2}
%         \po{a4}{a5}
%       \end{tikzinline}}
%   \end{gathered}
% \end{align*}
% Note that the two branches of the conditional are the same after the first
% assignment in the else branch.  Without $\Q{x}$, the precondition $\aForm$ is
% $\TRUE$, which is a tautology, and the execution is
% allowed, resulting in a violation of \drfsc.  To construct this pomset, we
% have chosen the empty pomset for $\sembase{\PW{x}{0}}$.  The constraints on
% complete pomsets do not filter out this pomset, since $\PW{x}{0}$ is in the
% false-branch of the conditional.  The problem here is that we have forgotten
% the local state of $x$ in the false-branch of the execution.  Nonetheless, we
% are using the subsequent read.

% With $\Q{x}$, the precondition of $\aForm$ is $\FALSE$.
% %$\Q{x}[\FALSE/\Q{x}]$, which is unsatisfiable.
% Intuitively, $\Q{x}$ requires that the most recent prior
% write to $\aLoc$ must be in the pomset in order to read $\aLoc$.

% $\Q{x}$ also guarantees initialization in complete pomsets: \eqref{top-kappa}
% requires tautologies, which means that all variables must be initialized
% sequentially in order to get rid of $\Q{\aLoc}$.

% The use of $\Q{x}$ is not too restrictive.  As a sanity check, consider the
% following pomsets,
% \begin{align*}
%   \begin{gathered}    
%     \PR{y}{r}
%     \SEMI
%     \IF{r}\THEN
%       \PW{x}{1}
%     \FI
%     \SEMI
%     \PR{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a1}{\DR{y}{1}}{}
%         \event{a2}{1{=}r\limplies r{\neq}0\bigmid\DW{x}{1}}{right=of a1}
%         \event{a3}{1{=}r\limplies \aTr[1]{}{\Q{x}}\bigmid\DR{x}{2}}{right=of a2}
%         \po{a1}{a2}
%         %\wki{a2}{a3}
%       \end{tikzinline}}
%     \qquad\qquad\qquad
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a1}{\DR{y}{0}}{}
%         \event{a3}{0{=}r\limplies \aTr[2]{}{\Q{x}}\bigmid\DR{x}{2}}{right=of a1}
%       \end{tikzinline}}
%   \end{gathered}  
% \end{align*}
% where 
% \begin{math}
%   \aTr[1]{}{\bForm}=
%   (r{\neq}0 \land \bForm[1/x][1{=}1/\Q{x}])
%   \lor
%   (r{=}0 \land \bForm)
% \end{math}
% and
% \begin{math}
%   \aTr[2]{}{\bForm}=
%   (r{\neq}0 \land \bForm[1/x][\FALSE/\Q{x}])
%   \lor
%   (r{=}0 \land \bForm)
% \end{math}
% are the predicate transformers for the conditional writes, using
% \ref{write-tau-nonempty} and \ref{write-tau-empty} respectively.  The
% executions are complete since all preconditions are tautologies.

% A problem \cite[\textsection6.3]{DBLP:conf/esop/PaviottiCPWOB20}.
% Version with control dependencies is \drf{}.

% \begin{align*}
%   \begin{gathered}    
%     \IF{r}\THEN
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     \\
%     \hbox{\begin{tikzinlinesmall}[node distance=1em]
%         \event{a4}{r{\neq}0\bigmid\DR{x}{1}}{}
%         \event{a5}{r{\neq}0\land((1{=}s\lor x{=}s)\limplies s{\neq}0)\bigmid\DW{z}{1}}{right=of a4}
%       \end{tikzinlinesmall}}
%     \\
%     \hbox{\begin{tikzinlinesmall}[node distance=1em]
%         \event{a4}{r{\neq}0\bigmid\DR{x}{1}}{}
%         \event{a5}{r{\neq}0\land(1{=}s\limplies s{\neq}0)\bigmid\DW{z}{1}}{right=of a4}
%         \po{a4}{a5}
%       \end{tikzinlinesmall}}
%   \end{gathered}
%   &&
%   \begin{gathered}    
%     \IF{\lnot r}\THEN
%       \PW{x}{0}
%       \SEMI
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     \\
%     % \hbox{\begin{tikzinlinesmall}[node distance=1em]
%     %     \event{a3}{r{=}0\bigmid\DW{x}{0}}{}
%     %     \event{a4}{r{=}0\bigmid\DR{x}{1}}{right=of a3}
%     %     \event{a5}{r{=}0\land((1{=}s\lor x{=}s)\limplies s{\neq}0)\bigmid\DW{z}{1}}{right=of a4}
%     %   \end{tikzinlinesmall}}
%     % \\
%     % \hbox{\begin{tikzinlinesmall}[node distance=1em]
%     %     \event{a3}{r{=}0\bigmid\DW{x}{0}}{}
%     %     \event{a4}{r{=}0\bigmid\DR{x}{1}}{right=of a3}
%     %     \event{a5}{r{=}0\land(1{=}s\limplies s{\neq}0)\bigmid\DW{z}{1}}{right=of a4}
%     %     \po{a4}{a5}
%     %   \end{tikzinlinesmall}}
%     % \\
%     \hbox{\begin{tikzinlinesmall}[node distance=1em]
%         \event{a4}{r{=}0\bigmid\DR{x}{1}}{}
%         \event{a5}{r{=}0\land((1{=}s\lor 0{=}s)\limplies s{\neq}0)\bigmid\DW{z}{1}}{right=of a4}
%       \end{tikzinlinesmall}}
%     \\
%     \hbox{\begin{tikzinlinesmall}[node distance=1em]
%         \event{a4}{r{=}0\bigmid\DR{x}{1}}{}
%         \event{a5}{r{=}0\land(1{=}s\limplies s{\neq}0)\bigmid\DW{z}{1}}{right=of a4}
%         \po{a4}{a5}
%       \end{tikzinlinesmall}}
%   \end{gathered}
% \end{align*}
% \begin{align*}
%   \begin{gathered}    
%     \IF{r}\THEN
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a4}{r{\neq}0\bigmid\DR{x}{1}}{}
%         \event{a5}{r{\neq}0\land x{\neq}0\bigmid\DW{z}{1}}{right=of a4}
%       \end{tikzinline}}
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a4}{r{\neq}0\bigmid\DR{x}{1}}{}
%         \event{a5}{r{\neq}0\bigmid\DW{z}{1}}{right=of a4}
%         \po{a4}{a5}
%       \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}    
%     \IF{\lnot r}\THEN
%       \PW{x}{0}
%       \SEMI
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a4}{r{=}0\bigmid\DR{x}{1}}{}
%         \event{a5}{\FALSE\bigmid\DW{z}{1}}{right=of a4}
%       \end{tikzinline}}
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a4}{r{=}0\bigmid\DR{x}{1}}{}
%         \event{a5}{r{=}0\bigmid\DW{z}{1}}{right=of a4}
%         \po{a4}{a5}
%       \end{tikzinline}}
%   \end{gathered}
% \end{align*}
% \begin{align*}
%   \begin{gathered}    
%     \IF{r}\THEN
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \ELSE
%       \PW{x}{0}
%       \SEMI
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a4}{\DR{x}{1}}{}
%         \event{a5}{r{\neq}0\land x{\neq}0\bigmid\DW{z}{1}}{right=of a4}
%       \end{tikzinline}}
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a4}{\DR{x}{1}}{}
%         \event{a5}{\DW{z}{1}}{right=of a4}
%         \po{a4}{a5}
%       \end{tikzinline}}
%   \end{gathered}
% \end{align*}

%         % \event{a1}{\DW{x}{1}}{}
%         % \event{a2}{\DR{y}{1}}{right=of a1}
%         % \event{a3}{\DW{x}{0}}{right=of a2}
%         % \event{a4}{\DR{x}{1}}{right=of a2}
%         % \event{a5}{\DW{z}{1}}{right=of a4}
%         % %\wki[out=15,in=165]{a1}{a3}
%         % %\wki{a3}{a4}
%         % \po[out=15,in=165]{a2}{a5}

% \begin{gather*}
%     \PW{x}{1}
%     \SEMI
%     \PR{y}{r}
%     \SEMI
%     \IF{r}\THEN
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \ELSE
%       \PW{x}{0}
%       \SEMI
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     \PAR
%     \IF{z}\THEN
%       \PW{y}{1}
%     \FI
%     % \\
%     % \PW{x}{1}
%     % \SEMI
%     % \IF{y}\THEN
%     %   \IF{x}\THEN
%     %     \PW{z}{1}
%     %   \FI
%     % \ELSE
%     %   \PW{x}{0}
%     %   \SEMI
%     %   \IF{x}\THEN
%     %     \PW{z}{1}
%     %   \FI
%     % \FI
%     % \PAR
%     % \IF{z}\THEN
%     %   \PW{y}{1}
%     % \FI
%     % \\
%     % \PW{x}{1}
%     % \SEMI
%     % \IF{y}\THEN
%     %   \PW{z}{\PR{x}{}}
%     % \ELSE
%     %   \PW{x}{0}
%     %   \SEMI
%     %   \PW{z}{\PR{x}{}}
%     % \FI
%     % \PAR
%     % \PW{y}{\PR{z}{}}
%     \\
%     \tag{\cmark}
%     \hbox{\begin{tikzinline}[node distance=1.5em]
%         \event{a1}{\DW{x}{1}}{}
%         \event{a2}{\DR{y}{1}}{right=of a1}
%         %\event{a3}{\DW{x}{0}}{right=of a2}
%         \event{a4}{\DR{x}{1}}{right=of a2}
%         \event{a5}{\DW{z}{1}}{right=of a4}
%         \event{b1}{\DR{z}{1}}{right=3em of a5}
%         \event{b2}{\DW{y}{1}}{right=of b1}
%         %\po{a2}{a3}
%         \po{b1}{b2}
%         %\wki[out=15,in=165]{a1}{a3}
%         %\wki{a3}{a4}
%         \rf{a5}{b1}
%         \rf[out=-170,in=-10]{b2}{a2}
%         \po[out=15,in=165]{a2}{a5}
%       \end{tikzinline}}
%     \\
%     \tag{\xmark}
%     \hbox{\begin{tikzinline}[node distance=1.5em]
%         \event{a1}{\DW{x}{1}}{}
%         \event{a2}{\DR{y}{1}}{right=of a1}
%         %\event{a3}{\DW{x}{0}}{right=of a2}
%         \event{a4}{\DR{x}{1}}{right=of a2}
%         \event{a5}{\DW{z}{1}}{right=of a4}
%         \event{b1}{\DR{z}{1}}{right=3em of a5}
%         \event{b2}{\DW{y}{1}}{right=of b1}
%         %\po{a2}{a3}
%         \po{b1}{b2}
%         %\wki[out=15,in=165]{a1}{a3}
%         %\wki{a3}{a4}
%         \rf{a5}{b1}
%         \rf[out=-170,in=-10]{b2}{a2}
%         \po{a4}{a5}
%       \end{tikzinline}}
%     \\
%     \tag{\cmark}
%     \hbox{\begin{tikzinline}[node distance=1.5em]
%         \event{a1}{\DW{x}{1}}{}
%         \event{a2}{\DR{y}{0}}{right=of a1}
%         \event{a3}{\DW{x}{0}}{right=of a2}
%         \event{a4}{\DR{x}{1}}{right=of a3}
%         \event{a5}{\DW{z}{1}}{right=of a4}
%         \event{b1}{\DR{z}{1}}{right=3em of a5}
%         \event{b2}{\DW{y}{1}}{right=of b1}
%         \po{a2}{a3}
%         \po{b1}{b2}
%         \wki[out=15,in=165]{a1}{a3}
%         \wki{a3}{a4}
%         \rf{a5}{b1}
%         %\rf[out=-170,in=-10]{b2}{a2}
%         \po[out=15,in=165]{a2}{a5}
%       \end{tikzinline}}
%     \\
%     \tag{\cmark}
%     \hbox{\begin{tikzinline}[node distance=1.5em]
%         \event{a1}{\DW{x}{1}}{}
%         \event{a2}{\DR{y}{0}}{right=of a1}
%         \event{a3}{\DW{x}{0}}{right=of a2}
%         \event{a4}{\DR{x}{1}}{right=of a3}
%         \event{a5}{\DW{z}{1}}{right=of a4}
%         \event{b1}{\DR{z}{1}}{right=3em of a5}
%         \event{b2}{\DW{y}{1}}{right=of b1}
%         \po{a2}{a3}
%         \po{b1}{b2}
%         \wki[out=15,in=165]{a1}{a3}
%         \wki{a3}{a4}
%         \rf{a5}{b1}
%         %\rf[out=-170,in=-10]{b2}{a2}
%         \po{a4}{a5}
%       \end{tikzinline}}
% \end{gather*}

% With $\Q{x}$, we have:
% \begin{align*}
%   \begin{gathered}    
%     \IF{r}\THEN
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     % \\
%     % \hbox{\begin{tikzinline}[node distance=1em]
%     %     \event{a4}{r{\neq}0\land\Q{x}\bigmid\DR{x}{1}}{}
%     %     \event{a5}{r{\neq}0\land x{\neq}0\bigmid\DW{z}{1}}{right=of a4}
%     %   \end{tikzinline}}
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a4}{r{\neq}0\land\Q{x}\bigmid\DR{x}{1}}{}
%         \event{a5}{r{\neq}0\bigmid\DW{z}{1}}{right=of a4}
%         \po{a4}{a5}
%       \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}    
%     \IF{\lnot r}\THEN
%       \PW{x}{0}
%       \SEMI
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     % \\
%     % \hbox{\begin{tikzinline}[node distance=1em]
%     %     \event{a4}{\FALSE\bigmid\DR{x}{1}}{}
%     %     \event{a5}{\FALSE\bigmid\DW{z}{1}}{right=of a4}
%     %   \end{tikzinline}}
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a4}{\FALSE\bigmid\DR{x}{1}}{}
%         \event{a5}{r{=}0\bigmid\DW{z}{1}}{right=of a4}
%         \po{a4}{a5}
%       \end{tikzinline}}
%   \end{gathered}
% \end{align*}
% \begin{align*}
%   \begin{gathered}    
%     \IF{r}\THEN
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \ELSE
%       \PW{x}{0}
%       \SEMI
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     % \\
%     % \hbox{\begin{tikzinline}[node distance=1em]
%     %     \event{a4}{r{\neq}0\land\Q{x}\bigmid\DR{x}{1}}{}
%     %     \event{a5}{r{\neq}0\land x{\neq}0\bigmid\DW{z}{1}}{right=of a4}
%     %   \end{tikzinline}}
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a4}{r{\neq}0\land\Q{x}\bigmid\DR{x}{1}}{}
%         \event{a5}{\DW{z}{1}}{right=of a4}
%         \po{a4}{a5}
%       \end{tikzinline}}
%   \end{gathered}
%   \\
%   \begin{gathered}    
%     \PR{y}{r}
%     \SEMI
%     \IF{r}\THEN
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \ELSE
%       \PW{x}{0}
%       \SEMI
%       \PR{x}{s}
%       \SEMI
%       \IF{s}\THEN
%         \PW{z}{1}
%       \FI
%     \FI
%     % \\
%     % \hbox{\begin{tikzinline}[node distance=1em]
%     %     \event{a4}{r{\neq}0\land\Q{x}\bigmid\DR{x}{1}}{}
%     %     \event{a5}{r{\neq}0\land x{\neq}0\bigmid\DW{z}{1}}{right=of a4}
%     %   \end{tikzinline}}
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{a2}{\DR{y}{1}}{}
%         \event{a4}{1{=}r\limplies(r{\neq}0\land\Q{x})\bigmid\DR{x}{1}}{right=of a2}
%         \event{a5}{\DW{z}{1}}{right=of a4}
%         \po{a4}{a5}
%       \end{tikzinline}}
%   \end{gathered}  
% \end{align*}



\subsection{Associativity and Skolemization}
\label{sec:ex:assoc}

The predicate transformers we have chosen for \ref{read-tau-dep} and
\ref{read-tau-ind} are different from the ones used traditionally, which are
written using substitution.
Attempting to write \ref{read-tau-dep} and \ref{read-tau-ind} in
this style we would have (as in \cite{DBLP:journals/pacmpl/JagadeesanJR20}):
\begin{enumerate}[topsep=0pt]
\item[{\labeltext[\textsc{r}4a$'$]{(\textsc{r}4a$'$)}{read-tau-dep-p}}]
  if $\aEv\in\aEvs\cap\bEvs$ then
  %if $\aEvs\neq\emptyset$ and $(\aEvs\cap\bEvs)\neq\emptyset$ then
  \begin{math}
    \aTr{\bEvs}{\bForm} \riff    
    \bForm[\aVal/\aReg]
  \end{math},    
\item[{\labeltext[\textsc{r}4b$'$]{(\textsc{r}4b$'$)}{read-tau-ind-p}}]
  if $\aEv\in\aEvs\setminus\bEvs$ then
  %if $\aEvs\neq\emptyset$ and $(\aEvs\cap\bEvs)=\emptyset$ then
  \begin{math}
    \aTr{\bEvs}{\bForm} \riff    
    \bForm[\aVal/\aReg]
    \land
    \bForm[\aLoc/\aReg]
  \end{math}.
\end{enumerate}
% Recall that \ref{read-tau-empty} says that $\bForm$ must be independent of
% $\aReg$ in order to appear in a top-level pomset: if $\aEvs=\emptyset$ then
% \begin{math}
%   \aTr{\bEvs}{\bForm} \riff
%   % \PBR{\aVal{=}\aReg \lor \aLoc{=}\aReg} \limplies
%   \bForm.
% \end{math}
% This choice for \ref{read-tau-empty} is forced by \refdef{def:family}, which
% states that the predicate transformer for a small subset of $\aEvs$ must
% imply the transformer for a larger subset.
Sadly, \ref{read-tau-ind-p} fails \ref{tr-or}, and therefore is not a
predicate transformer.  This is not merely a theoretical inconvenience:
adopting \ref{read-tau-ind-p} would also break associativity.  Consider the
following example, where we elide transformers for the writes and ``\texttt{!}''
represents logical negation:
\begin{align*}
  \begin{gathered}[t]
    \PR{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{a}{\DR{y}{1}}{}
        \xform{xd}{\bForm[1/r]}{right=of a}
        \xform{xi}{\bForm[1/r]\land\bForm[y/r]}{left=.5em of a}
        \xo{a}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{\BANG r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{b}{r{=}0\bigmid\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{\BANG\BANG r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{b}{r{\neq}0\bigmid\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
  % &&
  % \begin{gathered}[t]
  %   \PW{x}{0} 
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1em]
  %       \event{b}{\DW{x}{0}}{}
  %     \end{tikzinline}}    
  % \end{gathered}
\end{align*}
Coalescing the writes and associating to the right,
we have the following, since $(r{=}0 \lor r{\neq}0)\riff\TRUE$:
\begin{align*}
  \begin{gathered}[t]
    \PR{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{a}{\DR{y}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{\BANG r} 
    \SEMI \PW{x}{\BANG\BANG r} 
    %\SEMI \PW{x}{0} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{b}{\DW{x}{1}}{}
        %\event{c}{\DW{x}{0}}{right=of b}
        %\wki{b}{c}
      \end{tikzinline}}    
  \end{gathered}
  && &&
% \end{align*}  
% The precondition of $\DWP{x}{1}$ is a tautology, thus we have:
% \begin{align*}
  \begin{gathered}[t]
    \PR{y}{r}
    \SEMI (\PW{x}{\BANG r} 
    \SEMI \PW{x}{\BANG\BANG r} )
    %\SEMI \PW{x}{0} )
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{a}{\DR{y}{1}}{}
        \event{b}{\DW{x}{1}}{right=of a}
        %\event{c}{\DW{x}{0}}{right=of b}
        %\wki{b}{c}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
The precondition of $\DWP{x}{1}$ is a tautology.
Associating to the left and the coalescing, instead:
\begin{align*}
  \begin{gathered}[t]
    \PR{y}{r}
    \SEMI \PW{x}{\BANG r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{a}{\DR{y}{1}}{}
        \event{b}{1{=}0\land y{=}0\bigmid\DW{x}{1}}{right=of a}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{\BANG\BANG r} 
    %\SEMI \PW{x}{0} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{b}{r{\neq}0\bigmid\DW{x}{1}}{}
        %\event{c}{\DW{x}{0}}{right=of b}
        %\wki{b}{c}
      \end{tikzinline}}    
  \end{gathered}
  && &&
% \end{align*}  
% Sequencing and merging:
% \begin{align*}
  \begin{gathered}[t]
    (\PR{y}{r}
    \SEMI \PW{x}{\BANG r} )
    \SEMI \PW{x}{\BANG\BANG r} 
    %\SEMI \PW{x}{0} )
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{a}{\DR{y}{1}}{}
        \event{b}{\aForm\bigmid\DW{x}{1}}{right=of a}
        % \event{c}{\DW{x}{0}}{right=of b}
        % \wki{b}{c}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
The precondition
\begin{math}
  \aForm\riff(1{=}0\land y{=}0)\lor (1{\neq}0 \land y{\neq}0)
\end{math}
is equivalent to $y{\neq}0$, which is not a tautology.
% This pomset can
% never be complete due to the bogus write of $(\PW{x}{\BANG r})$, which will
% show up in the termination condition $(1{=}0)$.  Nevertheless, this is a
% problem, since associativity must hold for incomplete pomsets.
%
Our solution is to Skolemize, replacing substitution by implication, with 
% uses of $\bForm[\aVal/\aReg]$
% by $(\aReg{=}\aVal)\limplies\bForm$,
uniquely chosen registers.  Using \reffig{fig:seq}, we compute
\begin{math}
  \aForm\riff
  ((1{=}r\lor y{=}r)\limplies r{=}0)
  \lor
  ((1{=}r\lor y{=}r)\limplies r{\neq}0), 
\end{math}
which is a tautology.

%  We have proven associativity of
%  \refdef{def:pomsets-trans} in Agda.
% The proof of associativity requires that predicate transformers distribute
% through disjunction (\refdef{def:trans}).  The attempt to define predicate
% transformers using substitution fails because the transformer of
% \ref{read-tau-ind-p} does not distribute through disjunction:
% \begin{math}
%   \aTr{}{\bForm_1\lor \bForm_2}
%   % =
%   % (\bForm_1\lor \bForm_2)[\aVal/\aReg] \land (\bForm_1\lor \bForm_2)[\aLoc/\aReg]
%   %(\forall r)(\bForm_1\lor \bForm_2)
%   \not\riff
%   % (\bForm_1[\aVal/\aReg] \land \bForm_1[\aLoc/\aReg]) \lor (\bForm_2[\aVal/\aReg] \land \bForm_2[\aLoc/\aReg])
%   %((\forall r)(\bForm_1)) \lor ((\forall r)(\bForm_2))
%   % =
%   \aTr{}{\bForm_1} \lor \aTr{}{\bForm_2}
% \end{math}.
% Since $\aTr{}\bForm=(\forall\aReg)\bForm$ does not distribute
% through disjunction, we use $\aTr{}\bForm=\bForm$ instead (which trivially
% distributes through disjunction).  This change means we cannot use
% substitution, since $\bForm$ does not imply $\bForm[\aVal/\aReg]$.
% Fortunately, Skolemizing solves this problem, since $\bForm$ implies
% $(\aReg{=}\aVal)\limplies\bForm$.


\label{sec:ex:last}
