\section{The Basic Model}
\label{sec:model}

After some preliminaries (\textsection\ref{sec:prelim}--\ref{sec:actions}),
we define the basic model and establish some basic properties
(\textsection\ref{sec:pomsets} and \reffig{fig:seq}).  We then explain the
model using examples (\textsection\ref{sec:ex:pomset}--\ref{sec:ex:last}).
We encourage readers to skim the definitions and then skip to
\textsection\ref{sec:ex:pomset}, coming back as needed.

%% Batty suggest example where dependencies are added and also go away, perhaps
%% by store forwarding. Something like:
%% \texttt{(r=x; y=1); (s=y; z=s+r)}

% In this section, we present the mathematical preliminaries for the
% model (which can be skipped on first reading). We then present the
% model incrementally, starting with a model built using
% \emph{partially ordered multisets}
% (\emph{pomsets})~\cite{GISCHER1988199,Plotkin:1997:TSP:266557.266600},
% and then adding preconditions and finally predicate transformers.

% In later sections, we will discuss extensions to the logic, and to the
% semantics of load, store and thread initialization, in order to model
% relaxed memory more faithfully. We stress that these features do
% \emph{not} change any of the structures of the language: conditionals,
% parallel composition, and sequential composition are as defined in this section.

\subsection{Preliminaries}
\label{sec:prelim}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$.
\end{itemize}

\emph{Memory references} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory references, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.
% 
We require that
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
\item expressions include at least registers and values, 
\item expressions do \emph{not} include references: $\aExp[\bExp/\aLoc]=\aExp$.
\end{itemize}

We model the following language.
\begin{gather*}
  \begin{aligned}
    \amode,\bmode \BNFDEF& \mRLX
    \BNFSEP \mREL
    \BNFSEP \mACQ
    \BNFSEP \mSC
    % \amode \BNFDEF& \mRLX
    % \BNFSEP \mRA 
    % \BNFSEP \mSC
    % &\mkern100mu
    % \fmode \BNFDEF& \fACQ 
    % \BNFSEP \fREL
    % \BNFSEP \fSC
  \end{aligned}
  \\
  \aCmd
  \BNFDEF \LET{\aReg}{\aExp}
  \BNFSEP \PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}
  \BNFSEP \PW[\amode]{\REF{\cExp}}[\ascope]{\aExp}
  \BNFSEP \PF[\ascope]{\fmode}
  \BNFSEP \SKIP
  \BNFSEP \aCmd_1 \SEMI \aCmd_2
  \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
  \BNFSEP \aCmd_1 \LPAR[\bThrd] \aCmd_2
  % \\[-.5ex]
  % \BNFSEP& \PCAS[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
  % \BNFSEP \PFADD[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  % \BNFSEP \PEXCHG[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
\end{gather*}

% \emph{Memory modes}, $\amode$, are {relaxed} ($\mRLX$), {release-acquire}
% ($\mRA$), and {sequentially consistent} ($\mSC$).  Relaxed mode is the
% default; we regularly elide it from examples.  $\mRA$/$\mSC$ accesses are
% collectively known as \emph{synchronized accesses}.  

% \emph{Fence modes}, $\bmode$, are {acquire} ($\fACQ$), {release} ($\fREL$), 
% and {acquire-release} ($\fSC$).  

\emph{Access modes}, $\amode$, are {relaxed} ($\mRLX$),
{release} ($\mREL$), {acquire} ($\mACQ$), and
{sequentially consistent} ($\mSC$).
%
Let expressions ($\LET{\aReg}{\aExp}$) only affect thread-local state and
thus do not have a mode.
%
Reads ($\PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
%$\mWK$,
$\mRLX$,
%$\mREL$,
$\mACQ$,
%$\mRA$, 
$\mSC$. 
Writes ($\PW[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
%$\mWK$,
$\mRLX$,
$\mREL$,
%$\mACQ$,
%$\mRA$, 
$\mSC$. 
Fences ($\PF[\ascope]{\fmode}$) support
%$\mWK$,
%$\mRLX$,
$\mREL$,
$\mACQ$,
%$\mRA$,
$\mSC$.

\emph{Commands}, aka \emph{statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs. Following
\cite{DBLP:conf/icfp/FerreiraHJ96}, $\LPAR$ denotes parallel composition,
preserving thread state on the left after a join.  In examples and
sublanguages without join, we use the symmetric $\PAR$ operator.

We use common syntax sugar, such as \emph{extended expressions}, $\aEExp$,
which include memory locations.  For example, if $\aEExp$ includes a single
occurrence of $\aLoc$, then $\bLoc\GETS\aEExp\SEMI \aCmd$ is shorthand for
$\aReg\GETS\aLoc\SEMI\bLoc\GETS\aEExp[\aReg/\aLoc]\SEMI \aCmd$.  Each
occurrence of $\aLoc$ in an extended expression corresponds to an separate
read.  We also write $\IF{\aExp} \THEN \aCmd \FI$ as shorthand for
$\IF{\aExp} \THEN \aCmd\ELSE \SKIP\FI$.



Throughout \textsection\ref{sec:intro}--\ref{sec:arm} we 
require that
\begin{itemize}
\item each register is assigned at most once in a program.
  % \end{itemize}
  % In \textsection\ref{sec:complications} and following, we
  % require instead that
  % \begin{itemize}
  % \end{itemize}
\end{itemize}
In \textsection\ref{sec:additional}, we drop this restriction, requiring
instead that
\begin{itemize}
\item there are registers
  $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$, that do not
  appear in programs: $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$.
\end{itemize}
% In contexts that make no use of $\uRegs{\AllEvents}$, we make the first
% assumption.

The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, %$\dEv$,
  and subsets ranged over by $\aEvs$, $\bEvs$, $\cEvs$,  
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$,
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, $\bAct$,
\item a family of \emph{quiescence symbols} $\Q{\aLoc}$, indexed by location.
\end{itemize}
% $\dEvs$.

We require that
\begin{itemize}
\item formulae include $\TRUE$, $\FALSE$, $\Q{\aLoc}$, and the equalities $(\aExp{=}\bExp)$ and $(\aLoc{=}\aExp)$,
\item formulae are closed under $\lnot$, $\land$, $\lor$, $\limplies$, and
  substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$, $[\aForm/\Q{\aLoc}]$
\item there is a relation $\rimpliesdef$ between
  formulae, capturing entailment, %\subseteq(\Formulae\times\Formulae)$ %
\item $\rimpliesdef$ has the expected semantics for $=$, $\lnot$,
  $\land$, $\lor$, $\limplies$ and substitutions $[\aExp/\aReg]$,
  $[\aExp/\aLoc]$, $[\aForm/\Q{\aLoc}]$,
\item there are three binary relations over $\Act\times\Act$:
  $\roverlapsdef$, $\rmatchesdef$, and $\rblocksdef$,
\item there are two subsets of $\Act$, distinguishing
  $\sreaddef$ and $\sreleasedef$ actions.
\end{itemize}

Logical formulae include equations over registers and memory references, such as
$(\aReg{=}\bReg{+}1)$ and $(\aLoc{=}1)$.
% For use in \textsection\ref{sec:tc1}, we also include equations over memory references, such as $(\aLoc{=}1)$.
% I would like to drop this, an be careful about program vs logical syntax
We use expressions as formulae, coercing $\aExp$ to $\aExp{\neq}0$.
% Equations have precedence over logical operators; thus
% $\aReg{=}\aVal\limplies\bReg{>}\bVal$ is read
% $(\aReg{=}\aVal)\limplies(\bReg{>}\bVal)$.  As usual, implication associates to the
% right; thus $\aForm\limplies\bForm\limplies\cForm$ is read
% $\aForm\limplies(\bForm\limplies\cForm)$.
% As usual, implication associates to the right; thus
% $\aReg{=}\aVal\limplies\bReg{>}\bVal\limplies\bForm$ is read
% $(\aReg{=}\aVal)\limplies((\bReg{>}\bVal)\limplies\bForm)$.

% Formulae are subject to substitutions; % of the form $[\aExp/\aReg]$ and
% % $[\aExp/\aLoc]$;
% actions are not.

% \begin{definition}
%   \label{def:independent}
%   We say $\aForm$ is \emph{independent of $\aLoc$} if, for every
%   $\aVal$, $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$; it is
%   \emph{dependent} otherwise.
%   We say $\aForm$ is \emph{location independent} if it is independent of
%   every location.
%   We say
%   $\aForm$ \emph{implies} $\bForm$ if $\aForm\vDash\bForm$.
%   We say that
We write $\aForm\riff\bForm$ when $\aForm\rimplies\bForm$ and $\bForm\rimplies\aForm$.
We say
$\aForm$ is a \emph{tautology} if $\TRUE \rimplies \aForm$.
% We say that
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm \rimplies \FALSE$, and
\emph{satisfiable} otherwise.
% \end{definition}




\subsection{Actions in This Paper}
\label{sec:actions}
In this paper, we let actions be reads and writes and fences:
\begin{displaymath}
  \aAct,\bAct \BNFDEF \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DF[\ascope]{\fmode}[\aThrd]
\end{displaymath}
% % writes $\DWP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% reads $\DRP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% and fences $\DFP[\ascope]{\fmode}[\aThrd]$.

We use shorthand when referring to actions.  In definitions, we drop elements
of actions that are existentially quantified.  In examples, we drop elements
of actions, using defaults.
% We write $\DXP[\amode]{}[\ascope]{}[\aThrd]$ to
% stand for $\DWP[\amode]{}[\ascope]{}[\aThrd]$ or
% $\DRP[\amode]{}[\ascope]{}[\aThrd]$.
% 
Let $\lemode$ be the smallest order over access and fence modes such that
%$\mRLX\lemode\mRA\lemode\mSC$ and $\fREL\lemode\fSC$ and $\fACQ\lemode\fSC$.
$\mRLX\lemode\mREL\lemode\mSC$ and $\mRLX\lemode\mACQ\lemode\mSC$.
We write $\DWP[\gemode\mREL]{}{}$ to stand for either $\DWP[\mREL]{}{}$ or
$\DWP[\mSC]{}{}$, and similarly for the other actions and modes.

% We also define shorthand for sets of
% actions using an order on access and fence modes:  
% \begin{align*}
%   \begin{tikzcenter}
%     \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
%     \node (ra)  at (1, 0) {$\mathstrut\mRA$};
%     \node (sc)  at (2, 0) {$\mathstrut\mSC$};
%     \draw[->](rlx)to(ra);
%     \draw[->](ra)to(sc);
%   \end{tikzcenter}
%   &&
%   \begin{tikzcenter}
%     \node (fsc) at (3, 0) {$\mathstrut\fSC$};
%     \node (rel) at (2, -0.2) {$\mathstrut\fREL$};
%     \node (acq) at (2,  0.2) {$\mathstrut\fACQ$};
%     \draw[->](rel)to(fsc);
%     \draw[->](acq)to(fsc);
%   \end{tikzcenter}
% \end{align*}
% We write $\amode\lemode\bmode$ for this order.
% Let $\amode\lubmode\bmode$ denote the least upper bound of $\amode$ and $\bmode$.

% or $\DFP[\ascope]{\amode}[\aThrd]$.
% We write $\DWP[\gemode\mREL]{}{}$ to stand for either
% $\DWP[\mREL]{}{}$ or $\DWP[\mSC]{}{}$, and similarly for other actions and
% modes.

\begin{definition}
  \label{def:actions}
  Actions $\DRP{}{}$ are $\sreaddef$ actions.
  Actions $\DWP[\gemode\mREL]{}{}$ and $\DFP{\gemode\fREL}$ are
  $\sreleasedef$ actions.

  We say $\aAct \roverlapsdef \bAct$ if they access the same location.
  
  We say $\aAct \rmatchesdef \bAct$ if $\aAct=\DWP{\aLoc}{\aVal}$ and $\bAct=\DRP{\aLoc}{\aVal}$.
  % We say $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.
  % Action $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.

  We say $\aAct \rblocksdef \bAct$ if $\aAct=\DWP{\aLoc}{}$ and $\bAct=\DRP{\aLoc}{}$, regardless of value.
  % We say $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.
  % Action $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.

  % Let two actions \emph{overlap} if they access the same location.
  % We say $\aAct \roverlapsdef \bAct$ if they access the same location.
\end{definition}

\subsection{\PwTTITLE: Pomsets with Predicate Transformers}
\label{sec:pomsets}

\emph{Predicate transformers} are functions on formulae that preserve
logical structure, providing a natural model of sequential composition.
The definition comes from \citet{DBLP:journals/cacm/Dijkstra75}:

\begin{definition}
  \label{def:trans}
  A \emph{predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{multicols}{2}
    \begin{enumerate}[,label=(\textsc{x}\arabic*),ref=\textsc{x}\arabic*]
    \item \label{tr-implies}
      if $\aForm \rimplies \bForm$, then $\aTr{}{\aForm} \rimplies
      \aTr{}{\bForm}$,
    \item \label{tr-and}
      $\aTr{}{\bForm_1\land\bForm_2}\riff\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$,    
    \item \label{tr-or}
      $\aTr{}{\bForm_1\lor\bForm_2}\riff\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$.
    % \item \label{tr-false}
    %   $\aTr{}{\FALSE}$ is $\FALSE$,    
    \end{enumerate}
  \end{multicols}
\end{definition}
\noindent
We consistently use $\bForm$ as the parameter of predicate transformers.
Note that substitutions ($\bForm[\aExp/\aReg]$ and $\bForm[\aExp/\aLoc]$) and
implications on the right ($\aForm\limplies\bForm$) are predicate
transformers.

As discussed in \S\ref{sec:intro}, predicate transformers suffice for
sequentially consistent models, but not relaxed models, where dependency
calculation is crucial.  For dependency calculation, we use a \emph{family}
of predicate transformers, indexed by sets of events. In sequential
composition, we will use $\aTr{\Cdown{\aEv}}{}$ as the predicate transformer
applied to event $\aEv$ where $\bEv\in(\Cdown{\aEv})$ if $\bEv<\aEv$.

\begin{definition}
  \label{def:family}
  A \emph{family of predicate transformers} over $\aEvs$ consists of a
  predicate transformer $\aTr{\bEvs}{}$ for each $\bEvs\subseteq\AllEvents$,
  such that if $\cEvs \cap \aEvs \subseteq \bEvs$ then $\aTr{\cEvs}{\bForm}
  \rimplies \aTr{\bEvs}{\bForm}$.

  We write $\aTr{}{\bForm}$ as an abbreviation of $\aTr{\aEvs}{\bForm}$.
\end{definition}

\begin{definition}
  \label{def:pomset}
  A \emph{pomset with predicate transformers} (\PwT) %over $\Act$
  is a tuple $(\aEvs, \labeling, \labelingForm, \aTr{}{}, \aTerm, {\rrfx}, {\le})$ where
  % \begin{multicols}{2}
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
    \makecounter{BE}
  \item \label{pom-E} \makecounter{E}
    $\aEvs\subseteq\AllEvents$ is a set of \emph{events},
    \makecounter{Blambda}
  \item \label{pom-lambda} \makecounter{lambda}
    $\labeling: \aEvs \fun \Act$ defines a \emph{label} for each event,
    \makecounter{Bkappa}
  \item \label{pom-kappa} \makecounter{kappa}
    $\labelingForm:\aEvs\fun\Formulae$ defines a \emph{precondition} for each event,
    % such that
    % \begin{enumerate}
    % \item \label{pom-kappa-sat}
    %   $\labelingForm(\aEv)$ is satisfiable,
    % \end{enumerate}
    \makecounter{Btau}
  \item \label{pom-tau} \makecounter{tau}
    $\aTr{}{}:2^{\AllEvents}\fun\Formulae \fun\Formulae$ is a \emph{family of predicate transformers} over $\aEvs$, 
    \makecounter{Bterm}
  \item \label{pom-term} \makecounter{term}
    $\aTerm:\Formulae$ is a \emph{termination condition}, such that 
    \begin{enumerate}
    \item \label{pom-term-tau}
      $\aTerm\rimplies\aTr{}{\TRUE}$,
    \end{enumerate}
    \makecounter{Ble}
  \item \label{pom-le} \makecounter{le}
    ${\le} \subseteq \aEvs\times\aEvs$, is a partial order capturing
    \emph{causality},
    % such that
    % \begin{enumerate}
    % \item \label{pom-le-match}
    %   if $\bEv\xrfx\aEv$ then either $\bEv\le\aEv$ or $\aEv\le\bEv$,
    % \item \label{pom-le-block}
    %   if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\le\bEv$ or $\aEv\le\cEv$.
    % \end{enumerate}
    \makecounter{Brf}
  \end{enumerate}
  % \end{multicols}
  
  A \PwT{} is \emph{complete} if
  \begin{multicols}{2}
    \begin{enumerate}[,label=(\textsc{c}\arabic*),ref=\textsc{c}\arabic*]
      \setcounter{enumi}{\value{Bkappa}}
    \item \label{top-kappa}
      % $\labelingForm(\aEv)$ is a tautology (for every $\aEv\in\aEvs$),
      $\labelingForm(\aEv)$ is a tautology (for every $\aEv\in\aEvs$),
      \setcounter{enumi}{\value{Bterm}}
    \item \label{top-term}
      $\aTerm$ is a tautology.
    \end{enumerate}
  \end{multicols}
  % \labeltext[\textsc{t}1]{(\textsc{t}1)}{top-term} $\aTerm$ is a tautology and \labeltext[\textsc{t}2]{(\textsc{t}2)}{top-ev} for every $\aEv\in\aEvs$,
  % % $\labelingForm(\aEv)$ is a tautology and
  % % if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$.
  % % \begin{multicols}{2}
  % \begin{enumerate}[label=(\textsc{t}\arabic*),ref=\textsc{t}\arabic*]
  %   \setcounter{enumi}{2}
  % \item[]
  %   \begin{enumerate}[leftmargin=0pt]
  %   \item \label{top-kappa}
  %     $\labelingForm(\aEv)$ is a tautology,    
  %   \item \label{top-rf}
  %     if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$.
  %   \end{enumerate}
  % \end{enumerate}
  % % \end{multicols}
\end{definition}
\input{fig-seq.tex}
Preconditions are doing two things:
\begin{itemize}
\item determining which events can appear in a pomset, and which ones can go
  together
\item helping to calculate dependencies.
\end{itemize}
Empty set is used for code that does not run in any given execution.  To get
a complete pomset for $\sem{\IF{\FALSE}\THEN\PW{x}{1}\FI}$ you need to take
the empty set for $\sem{\PW{x}{1}}$.

Idea behind $\Q{\aLoc}$:
\begin{itemize}
\item most recent prior write to $\aLoc$ must be in the pomset in order to read $\aLoc$...
\item similar to release/termination: all prior writes must be in the pomset
  in order to release...
\item terminology: ``prior'' means sequentially before, different from $\le$,
  which is ``ordered before''.
\item \eqref{top-kappa} requires tautologies, which means that all variables
  are initialized sequentially in order to get rid of $\Q{\aLoc}$.
\end{itemize}
Sanity check:
\begin{align*}
  \begin{gathered}    
    \PR{y}{r}
    \SEMI
    \IF{r}\THEN
      \PW{x}{1}
    \FI
    \SEMI
    \PR{x}{s}
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{a1}{\DR{y}{1}}{}
        \event{a2}{1{=}r\limplies r{\neq}0\mid\DW{x}{1}}{right=of a1}
        \event{a3}{1{=}r\limplies (r{\neq}0\land\Q{x})\mid\DR{x}{2}}{right=of a2}
        \po{a1}{a2}
        \wki{a2}{a3}
      \end{tikzinline}}
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{a1}{\DR{y}{0}}{}
        \event{a3}{0{=}r\limplies \aTr{}{\Q{x}}\mid\DR{x}{2}}{right=of a1}
      \end{tikzinline}}
  \end{gathered}  
\end{align*}
where
\begin{math}
  \aTr{}{\bForm}=
  (r{\neq}0 \land \bForm[1/x][\FALSE/\Q{x}])
  \lor
  (r{=}0 \land \bForm)
\end{math}

We give the semantics of programs $\sembase{}$ in \reffig{fig:seq}.

Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.
% Let $\Pom$ be the set of all pomsets.

The model has seven components, which can be daunting at first glance.  To
aid the reader, we use consistent numbering throughout. For example, item $7$
always refers to the order relation.

The core of the model is a pomset, which includes a set of events
\eqref{pom-E}, a labeling \eqref{pom-lambda}, and an order \eqref{pom-le}.
We also include the \emph{reads-from} relation explicitly in the model
\eqref{pom-rf}.

On top of this basic structure, \ref{pom-kappa}--\ref{pom-term} add a layer
of logic.  For each pomset, \ref{pom-term} provides a termination condition.
For each event in a pomset, \ref{pom-kappa} provides a precondition.  For
each set of events in a pomset, \ref{pom-tau} provides a predicate
transformer.  Sequential dependency is calculated by $\labelingForm'_2$ in
the semantics of sequential composition.

Before discussing the details of the model, we note that the semantics
satisfies the expected monoid laws and is closed with respect to
\emph{augmentation}.  Augments include more order and stronger formulae; in
examples, we typically consider pomsets that are augment-minimal.  One
intuitive reading of augment closure is that adding order can only cause
preconditions to weaken.
\begin{lemma}
  \label{lem:monoid}
  
  \begin{enumerate*}[label=(\alph*),ref=\alph*]
  \item \label{monoid:unit}
    \begin{math}
      \aPSS
      =
      \xLPARP{\aPSS}{\sSKIP}
      =
      \xSEMIP{\aPSS}{\sSKIP}
      =
      \xSEMIP{\sSKIP}{\aPSS}.
    \end{math}

  \\\item \label{monoid:par}
    \begin{math}
      \xLPAR{\xLPARP{\aPSS_1}{\aPSS_2}}{\aPSS_3}
      =
      \xLPAR{\aPSS_1}{\xLPARP{\aPSS_2}{\aPSS_3}}.
    \end{math}

  \\\item \label{monoid:seq}
    \begin{math}
      \xSEMI{\xSEMIP{\aPSS_1}{\aPSS_2}}{\aPSS_3}
      =
      \xSEMI{\aPSS_1}{\xSEMIP{\aPSS_2}{\aPSS_3}}.
    \end{math}

  \end{enumerate*}      
  \vspace{-.5\baselineskip}
  \begin{proof}
    Straightforward calculation.
    \eqref{monoid:unit} requires \ref{pom-term-tau} for
    the termination condition in $\xSEMIP{\aPSS}{\sSKIP}$.

    \eqref{monoid:seq} requires both
    conjunction closure (\ref{tr-and}, for the termination condition) and disjunction
    closure (\ref{tr-or}, for the predicate transformers themselves).
  \end{proof}
\end{lemma}
\begin{lemma}
  \label{lem:if}

  \begin{enumerate*}[label=(\alph*),ref=\alph*]
    \setcounter{enumi}{3}
    \item \label{lem:if:if}
    \begin{math}
      \xIFTHEN{\aForm}{
        \xIFTHEN{\bForm}{\aPSS}{}
      }{}
      =
      \xIFTHEN{\aForm\land\bForm}{\aPSS}{}.
    \end{math}

  \\\item \label{lem:if:seq}
    \begin{math}
      \xIFTHEN{\aForm}{
        \xSEMI{\aPSS_1}{\aPSS_3}
      }{
        \xSEMI{\aPSS_2}{\aPSS_3}
      }
      \supseteq
      \xSEMI{
        \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
      }{
        \aPSS_3
      }.
    \end{math}

  \\\item \label{lem:seq:if}
    \begin{math}
      \xIFTHEN{\aForm}{
        \xSEMI{\aPSS_1}{\aPSS_2}
      }{
        \xSEMI{\aPSS_1}{\aPSS_3}
      }
      \supseteq
      \xSEMI{
        \aPSS_1
      }{
        \xIFTHEN{\aForm}{\aPSS_2}{\aPSS_3}
      }.
    \end{math}

  \\\item \label{lem:if:elim}
    \begin{math}
      \xIFTHEN{\aForm}{\aPSS}{\aPSS}
      \supseteq
      \aPSS.
    \end{math}

  \\\item \label{lem:if:dead}
    \begin{math}
      \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
      \supseteq
      \aPSS_1
    \end{math}
    if $\aForm$ is a tautology.

  \\\item
    \begin{math} \label{lem:ifelse:if:if1}
      \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
      =
      \xSEMI{
        \xIFTHEN{\aForm}{\aPSS_1}{}
      }{
        \xIFTHEN{\lnot\aForm}{\aPSS_2}{}
      }.
    \end{math}
    
  \\\item
    \begin{math} \label{lem:ifelse:if:if2}
      \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
      =
      \xSEMI{
        \xIFTHEN{\lnot\aForm}{\aPSS_2}{}
      }{
        \xIFTHEN{\aForm}{\aPSS_1}{}
      }.
    \end{math}
  \end{enumerate*}      
  \vspace{-.5\baselineskip}
  \begin{proof}
    Straightforward calculation.
    In \textsection\ref{sec:semca}, we refine the semantics to validate the
    reverse inclusions for \eqref{lem:if:seq}, \eqref{lem:seq:if}, and
    \eqref{lem:if:elim}.

    In \textsection\ref{sec:false}, we refine the semantics to validate the
    reverse inclusion for \eqref{lem:if:dead}.

    For \PwP, \eqref{lem:ifelse:if:if1} and \eqref{lem:ifelse:if:if2}
    are inclusions rather than equations.  In \textsection\ref{sec:delay}, we
    refine the semantics to validate the reverse inclusions.    
  \end{proof}
\end{lemma}
\begin{definition}
  \label{def:augment}
  $\aPS_2$ is an \emph{augment} of $\aPS_1$ if
  \begin{multicols}{4}
    \begin{enumerate}
    \item $\aEvs_2=\aEvs_1$,
    \item $\labelingAct_2(\aEv)=\labelingAct_1(\aEv)$,
    \item $\labelingForm_2(\aEv) \riff \labelingForm_1(\aEv)$,
    \item $\aTr[2]{\bEvs}{\bForm}\riff \aTr[1]{\bEvs}{\bForm}$,
    \item $\aTerm[2] \riff \aTerm[1]$,
    \item ${\le_2}\supseteq{\le_1}$,
    \item ${\rrfx_2}\supseteq{\rrfx_1}$.
    \end{enumerate}
  \end{multicols}
\end{definition}
\begin{lemma}
  % Suppose $\aPS_1\in\sembase{\aCmd}$.
  If $\aPS_1\in\sembase{\aCmd}$ and $\aPS_2$  augments $\aPS_1$ then $\aPS_2\in\sembase{\aCmd}$.
  % \item If $\aPS_2$ is a downset of $\aPS_1$ then $\aPS_2\in\sembase{\aCmd}$.
  % \end{lemma}

  \vspace{-.5\baselineskip}
  \begin{proof}
    Induction on the definition of $\sembase{}$.
  \end{proof}
\end{lemma}





% \begin{definition}
%   Suppose $\aRel_1:\aEvs_1\times\aEvs_1$ and $\aRel_2:\aEvs_2\times\aEvs_2$.
%   We say $\aRel \rextendsdef{\aRel_1}{\aRel_2}$ if
%   $\aRel\supseteq (\aRel_1\cup \aRel_2)$ and
%   $\aRel\cap(\aEvs_1\times \aEvs_1) = \aRel_1$ and
%   $\aRel\cap(\aEvs_2\times \aEvs_2) = \aRel_2$.
% \end{definition}

% We include empty sets as prep for adding while loops.


% In diagrams, we use different colors for arrows.  We distinguish
% $\rrfx$ edges that are included in order from those that are not.
% \begin{itemize}
% \item \makebox{$\aEv\xrf\bEv$} arises from $\rrfx$, where $\aEv\le\bEv$,
% \item \makebox{$\aEv\xrfint\bEv$} arises from $\rrfx$, where $\lnot(\aEv\le\bEv)$.
% \end{itemize}
% To help the reader understand why order is included, we also different colors
% for arrows induced by order.  We adopt the following conventions:
% \begin{itemize}  
%   % \item relaxed accesses are blue, with a single border,
%   % \item synchronized accesses are red, with a double border,
%   % \item \makebox{$\aEv\xrf\bEv$} arises from fulfillment, where $\aEv$ \emph{matches} $\bEv$,
%   % \item \makebox{$\aEv\xwk\bEv$} arises either from fulfillment, where $\aEv$
%   %   \emph{blocks} $\bEv$, or from prefixing, where $\aEv$ was prefixed before
%   %   $\bEv$ and their actions \emph{conflict},
% \item \makebox{$\aEv\xwk\bEv$} arises from \emph{fulfillment},
% \item \makebox{$\aEv\xpo\bEv$} arises from control/data/address \emph{dependency},
% \item \makebox{$\aEv\xsync\bEv$} arises from \emph{synchronized access}.
% \end{itemize}



\subsection{Pomsets}
\label{sec:ex:pomset}

We first explain the core of model, ignoring the logic (rules 3--5).
%We defer the discussion of $\sLET{}{}$ to \textsection\ref{sec:ex:data}.
We defer discussion of $\sIF{}$ to \textsection\ref{sec:ex:control}.

Reads, writes, and fences map to pomsets with at most one event.  $\SKIP$
maps to the empty pomset.  Ignoring the logic, the definitions are
straightforward.  Note only that $\sembase{\PW{x}{1}}$ can write any value
$\aVal$; the fact that $\aVal$ must be $1$ is captured in the logic (see
\textsection\ref{sec:ex:term}).

The structural rules combine pomsets:  Parallel composition is disjoint
union, inheriting labeling, order and $\rrfx$ from the two sides.  Any
$\rrfx$ edges added between the two sides must also be added to the order
(\ref{par-rf-le1} and \ref{par-rf-le2}).
% 
Sequential composition is similar, with two changes: \ref{seq-E} does not
require disjointness (see \textsection\ref{sec:ex:term}), and
\ref{seq-le-delays} may require order (see example \ref{pub}, below).

Note that reads-from implies order by \eqref{pom-rf-le}.
% \begin{lemma}
%   \label{lem:rf:implies:le}
%   For any $\aPS$ in the range of $\sembase{}$, $\bEv\xrfx\aEv$ implies
%   $\bEv\le\aEv$.

%   \vspace{-.5\baselineskip}
%   \begin{proof}
%     Induction on the definition of $\sembase{}$, using \ref{par-rf-le1}, \ref{par-rf-le2}, and \ref{pom-rf-le}.
%   \end{proof}
% \end{lemma}
In top-level pomsets, every read must have a matching write in $\rrfx$
\eqref{top-rf}.  Together with \ref{pom-rf-match} and \ref{pom-rf-block}, the lemma
guarantees that reads are \emph{fulfilled} at top-level, as in
\cite[\textsection 2.7]{DBLP:journals/pacmpl/JagadeesanJR20}.\footnote{The
  basic model would be the same if we move $\rrfx$ from the model itself to
  be existentially quantified in the definition of top-level pomset, along
  with \ref{pom-rf-match} and \ref{pom-rf-block}.  This was the approach of
  \citeauthor{DBLP:journals/pacmpl/JagadeesanJR20} We include $\rrfx$
  explicitly for use in \textsection\ref{sec:arm2}, where we introduce a
  variant semantics $\frf{\semrr{}}$ where \ref{pom-rf-le} is not required.}

From \refdef{def:actions}, recall that $\aAct \rdelaysdef \bAct$ if
$\aAct\eqreorderco\bAct$ or $\aAct\reorderra\bAct$ or
$\aAct\eqreordersc\bAct$.  \ref{seq-le-delays} guarantees that sequential
order is enforced between conflicting accesses of the same location
($\eqreorderco$), into a release and out of an acquire ($\reorderra$), and
between SC accesses ($\eqreordersc$).  Combined with the fulfillment
requirements (\ref{pom-rf-match}, \ref{pom-rf-block} and \ref{pom-rf-le}),
these ensure coherence, publication, subscription and other idioms.  For
example, consider the following:\footnote{We use different colors for arrows representing order:
  \begin{itemize}  
  \item \makebox{$\bEv\xpo\aEv$} arises from control/data/address \emph{dependency} (\ref{seq-kappa}, definition of $\labelingForm'_2(\bEv)$),
  \item \makebox{$\bEv\xsync\aEv$} arises from $\reorderra$ or $\eqreordersc$ \eqref{seq-le-delays},
  \item \makebox{$\bEv\xwki\aEv$} arises from $\eqreorderco$ \eqref{seq-le-delays},
  \item \makebox{$\bEv\xrf\aEv$} arises from \emph{reads-from} \eqref{pom-rf-match},
  %\item \makebox{$\bEv\xsyncsc\aEv$} arises from \emph{strong fencing} \eqref{cand-lesync-sc},
  \item \makebox{$\bEv\xwk\aEv$} arises from \emph{blocking} \eqref{pom-rf-block}.
  \end{itemize}
  In \textsection\ref{sec:arm2}, it is possible for $\rrf$ to contradict
  $\le$.  In this case, we use a dotted arrow for $\rrf$: $\bEv\xrfint\aEv$
  indicates that $\aEv\le\bEv$.}
\begin{gather*}
  \taglabel{pub}
  \begin{gathered}    
    \PW{x}{0}\SEMI 
    \PW{x}{1}\SEMI \PW[\mREL]{y}{1} \PAR \PR[\mACQ]{y}{r}\SEMI \PR{x}{s}
    \\[-.4ex]
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wx0}{\DW{x}{0}}{}
        \event{wx1}{\DW{x}{1}}{right=of wx0}
        \event{wy1}{\DW[\mREL]{y}{1}}{right=of wx1}
        \event{ry1}{\DR[\mACQ]{y}{1}}{right=2.5em of wy1}
        \event{rx0}{\DR{x}{0}}{right=of ry1}
        \sync{wx1}{wy1}
        \sync{ry1}{rx0}
        \rf{wy1}{ry1}
        \wk[out=170,in=10]{rx0}{wx1}
        \wki{wx0}{wx1}
      \end{tikzinline}}
  \end{gathered}
\end{gather*}
The execution is disallowed due to the cycle.  All of the order shown is
required at top-level: The intra-thread order comes from \ref{seq-le-delays}:
$\DWP{x}{0}\xwki \DWP{x}{1}$ is required by $\eqreorderco$.
$\DWP{x}{1}\xsync \DWP[\mREL]{y}{1}$ and $\DRP[\mACQ]{y}{1}\xsync \DRP{x}{0}$ are
required by $\reorderra$.  The cross-thread order is required by fulfillment:
\ref{top-rf} requires that all top-level reads are in the image of $\xrfx$.
\ref{pom-rf-match} ensures that $\DWP[\mREL]{y}{1}\xrfx \DRP[\mACQ]{y}{1}$, and
\ref{pom-rf-le} subsequently ensures that
$\DWP[\mREL]{y}{1}\le \DRP[\mACQ]{y}{1}$.  The \emph{antidependency}
$\DRP{x}{0}\xwk \DWP{x}{1}$ is required by \ref{pom-rf-block}.  (Alternatively,
we could have $\DWP{x}{1}\xwk \DWP{x}{0}$, again resulting in a cycle.)

The semantics gives the expected results for store buffering and load buffering,
as well as litmus tests involving fences and SC access.  The model of
coherence is weaker than C11, in order to support common subexpression
elimination, and stronger than Java, in order to support local reasoning
about data races.  See
\cite[\textsection3.1]{DBLP:journals/pacmpl/JagadeesanJR20} for a discussion.

In the structural rules $\sSEMI{}{}$ and $\sIF{}$, we say that
$\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ \emph{coalesce} if $\bEv=\aEv$.

\ref{seq-E} allows \emph{mumbling} \cite{DBLP:journals/iandc/Brookes96} by
coalescing events.  For example
\begin{math}
  \sembase{\PW{x}{1} \SEMI \PW{x}{1}}
\end{math}
includes the singleton pomset
\begin{tikzinlinesmall}[node distance=.5em and 1.5em]
  \event{a1}{\DW{x}{1}}{}
\end{tikzinlinesmall}.  From this it is easy to see that
\begin{math}
  \sembase{\PW{x}{1}\SEMI\PW{x}{1}}
  \supseteq
  \sembase{\PW{x}{1}}
\end{math}
is a valid refinement.  It is equally obvious that
\begin{math}
  \sem{\PW{\aLoc}{1}} 
  \not\supseteq
  \sem{\PW{\aLoc}{1} \SEMI \PW{\aLoc}{1}}
\end{math}
is not a valid refinement, since the latter includes a two-element pomset,
but the former does not.\footnote{These are distinguished by the context:
  \begin{math}
    \hole{} \PAR
    \PR{x}{r} \SEMI
    \PW{x}{2} \SEMI
    \PR{x}{s}\SEMI
    \IF{\aReg {=} \bReg} \THEN \PW{\cLoc}{1} \FI.
  \end{math}}


\subsection{Termination}
\label{sec:ex:term}

In top-level pomsets, \ref{top-term} requires that $\aTerm$ is a tautology,
capturing termination.  Terminated pomsets are often called \emph{complete},
whereas nonterminated pomsets are \emph{incomplete}.

Ignoring predicate transformers, the structural rules, \ref{par-term} and
\ref{seq-term}, take $\aTerm$ to be $\aTerm_1\land\aTerm_2$.  This is as
expected: the program terminates if both subprograms terminate.

The interesting rules are $\sLOAD{}{}$, $\sFENCE{}$, and $\sSTORE{}{}$.


In $\sLOAD{}{}$, there is no restriction on $\aTerm$ for relaxed reads.  From
this, it is easy to see that
\begin{math}
  \sembase{\PR{x}{r}}
  \supseteq
  \sembase{\SKIP}
\end{math}
is a valid refinement (where the default mode is $\mRLX$).

In $\sFENCE{}$, instead, \ref{fence-term} ensures that all fences are included at
top-level.  This also ensures
$\sembase{\PF{\amode}}\not\supseteq\sembase{\IF{\aExp}\THEN\PF{\amode}\FI}$,
since $\sembase{\IF{\aExp}\THEN\PF{\amode}\FI}$ includes the empty set with
termination condition $\lnot\aExp$, but $\sembase{\PF{\amode}}$ can only
include the empty set with termination condition $\FALSE$.

In $\sSTORE{}{}$, \ref{write-term-empty} is similar.  In addition,
\ref{write-term-nonempty} ensures that top-level pomsets do not include bogus
writes.  Suppose $\aPS\in\sembase{\PW{x}{1}}$.  As we noted above, $\aPS$ can
include $(1{=}\aVal\mid\DW{x}{\aVal})$, for any value $\aVal$.  At top-level,
however, \ref{write-term-nonempty} requires that $\aTerm$ implies
$1{=}\aVal$.  In this case, \ref{pom-kappa-sat} would filter the pomset,
since preconditions must be satisfiable.  However, unsatisfiable writes can be become satisfiable via
merging:
% Nonetheless, it is important that
% \ref{write-term-nonempty} specifies $\aTerm\riff\aExp{=}\aVal$ rather than
% $\aTerm\riff\TRUE$, since 
\begin{align*}
  \begin{gathered}
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a}{\DW{x}{1}}{}      
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{b}{2{=}3\mid\DW{x}{3}}{}      
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \IF{\aExp}\THEN\PW{x}{3}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{c}{\aExp\mid\DW{x}{3}}{}      
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
By merging, the semantics allows the following:
\begin{align*}
  \begin{gathered}
    \PW{x}{1}
    \SEMI
    \PW{x}{2}
    \SEMI
    \IF{\aExp}\THEN\PW{x}{3}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a}{\DW{x}{1}}{}      
        \event{c}{\aExp\mid\DW{x}{3}}{right=of a}
        \wki{a}{c}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
This pomset is incomplete, however, since $\aTerm\riff2{=}3$.

\subsection{Data Dependencies, Preconditions, and Predicate Transformers}
\label{sec:ex:data}

% Predicate transformers affect preconditions in the definition of
% $\labelingForm'_2$, which is used in \ref{seq-kappa2} and \ref{seq-kappa12}
% to calculate dependencies.  In this subsection we ignore predicate
% transformers, taking $\labelingForm'_2=\labelingForm_2$.

In top-level pomsets, \ref{top-kappa} requires that every precondition
$\labelingForm(\aEv)$ is a tautology.

Preconditions are discharged during sequential composition by applying
predicate transformers $\aTr[1]{}{}$ from the left to preconditions
$\labelingForm_2(\aEv)$ on the right.  The specific rules are
\ref{seq-kappa2} and \ref{seq-kappa12}, which use the transformed predicate
$\labelingForm'_2(\aEv)=\aTr[1]{\Cdown{\aEv}}{\labelingForm_2(\aEv})$, where
$\Cdown{\aEv}=\{ \cEv \mid \cEv \lt \aEv \}$ is the set of events that
precede $\aEv$ in causal order.  We call $\Cdown{\aEv}$ the \emph{dependent
  set} for $\aEv$.  Then $\aEvs\setminus(\Cdown{\aEv})$ is the
\emph{independent set}. % for $\aEv$.

% Sequential composition uses the usual rule for composition of predicate
% transformers (but preserving the indexing set). For the pomset, we take the
% union of their events, preserving actions, but crucially in
% cases~\ref{seq-kappa2} and~\ref{seq-kappa12} we apply a predicate transformer
% $\aTr[1]{\cEvs}{}$ from the left-hand side to a precondition
% $\labelingForm_2(\aEv)$ from the right-hand side to build the precondition
% $\labelingForm'_2(\aEv)$.  The indexing set $\cEvs$ for the predicate
% transformer is $\{ \cEv\mid \cEv<\aEv \}$, so can depend on the causal order.


Before looking at the details, it is useful to have a high-level view of how
nontrivial preconditions and predicate transformers are introduced.  (We
discuss address dependencies in \textsection\ref{sec:addr}.)
\begin{multicols}{2}
  Preconditions are introduced in: 
  \begin{itemize}
  \item[\eqref{seq-kappa}] for release actions,
  \item[\eqref{if-kappa}] for control dependencies, 
  \item[\eqref{write-kappa}] for data dependencies on writes.
  \end{itemize}

  Predicate transformers are introduced in:
  \begin{itemize}
  \item[\eqref{read-tau-dep}] for reads in the dependent set,
  \item[\eqref{read-tau-ind}] for reads in the independent set,
  \item[\eqref{write-tau}] for writes.
  \end{itemize}
  % \item These are glued together in \ref{seq-kappa}.
  %   \begin{itemize}
  %   \item \ref{seq-kappa2}  handles non-coalescing events,
  %   \item \ref{seq-kappa12} handles coalescing events.
  %   \end{itemize}
\end{multicols}


The rules track dependencies.  We discuss data dependencies \eqref{write-kappa}
here and control dependencies \eqref{if-kappa} in
\textsection\ref{sec:ex:control}.  Unless otherwise noted, we assume pomsets
are \emph{complete} and \emph{augment-minimal}.  We do not discuss
\ref{seq-kappa} further.  It simply ensures that all writes are
present before a release, even for incomplete pomsets (see
\textsection\ref{sec:ex:term}).

A simple example of a data dependency is a pomset
$\aPS\in\sem{\PR{x}{r}\SEMI \PW{y}{r}}$.  If $\aPS$ is complete, it must have
two events. Then $\sSEMI{}{}$ requires that there are %$\aVal,\bVal\in\Val$ and
$\aPS_1\in \sem{\PR{x}{r}}$ and $\aPS_2\in \sem{\PW{y}{r}}$ of the form:
\begin{align*}
  \tag{$\ddagger$}\label{eq2}
  \begin{gathered}
    \PR{x}{r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aVal{=}r\limplies\bForm}{}
        \eventr{\bEv}{a1}{\DR{x}{\aVal}}{left=of xd}
        \xform{xi}{(x{=}r\lor\aVal{=}r)\limplies\bForm}{left=.5em of a1}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\bForm[r/y]}{}
        \eventr{\aEv}{a2}{r{=}\bVal\mid\DW{y}{\bVal}}{left=of xd}      
        \xform{xi}{\bForm[r/y]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
First we consider the case that $\aVal=\bVal$.  For example if $\aVal=\bVal=1$, we have:
\begin{align*}
  \begin{gathered}
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{1{=}r\limplies\bForm}{}
        \eventr{\bEv}{a1}{\DR{x}{1}}{left=of xd}
        \xform{xi}{(x{=}r\lor1{=}r)\limplies\bForm}{left=.5em of a1}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\bForm[r/y]}{}
        \eventr{\aEv}{a2}{r{=}1\mid\DW{y}{1}}{left=of xd}      
        \xform{xi}{\bForm[r/y]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
For the read, the dependent transformer $\smash{\aTr[1]{\{\bEv\}}{}}$ is
$1{=}r\limplies\bForm$; the independent transformer $\aTr[1]{\emptyset}{}$ is
$(x{=}r\lor1{=}r)\limplies\bForm$.  These are determined by
\ref{read-tau-dep} and \ref{read-tau-ind}, respectively.  For the write, both
% the dependent transformer
$\smash{\aTr[2]{\{\aEv\}}{}}$ and
% the independent transformer
$\aTr[2]{\emptyset}{}$ are $\bForm[r/y]$, as are determined by
\ref{write-tau}.
%
Combining these into a single pomset, we have:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{1{=}r\limplies\bForm[r/y]}{}
        \eventr{\bEv}{a1}{\DR{x}{1}}{left=of xd}
        \xform{xi}{(x{=}r\lor1{=}r)\limplies\bForm[r/y]}{left=.5em of a1}
        \eventr{\aEv}{a2}{\aForm\mid\DW{y}{1}}{right=of xd}      
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
By \ref{seq-tau}, predicate transformers are determined by composition; thus
$\aTr{\bEvs}{\bForm}$ is $\aTr[1]{\bEvs}{\aTr[2]{\bEvs}{\bForm}}$.  Since the
transformer does not depend on whether the write is included, we do not draw
dependencies for the write in the diagram.

Turning to the precondition $\aForm$ on the write, recall that in order for
$\aEv$ to participate in a top-level pomset, the precondition $\aForm$ must
be a tautology at top-level.  There are two possibilities.
\begin{itemize}
\item If $\bEv\le\aEv$ then we apply the dependent transformer and
  $\aForm=(1{=}r\limplies r{=}1)$, a tautology.
\item If $\bEv\not\le\aEv$ then we apply the independent transformer and
  $\aForm=((x{=}r\lor1{=}r)\limplies r{=}1)$.  Under the assumption that $r$
  is bound, this is logically equivalent to $(x{=}1)$. (We make this more
  precise in \textsection\ref{sec:semreg}.)
\end{itemize}
Eliding transformers, the two outcomes are:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{x{=}1\mid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
The independent case on the right can only participate in a top-level pomset
if the precondition $(x{=}1)$ is discharged.  To do so, we must prepend a
pomset $\aPS_0$ that writes $1$ to $x$:
\begin{align*}
  \begin{gathered}
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\bForm[1/x]}{}
        \eventr{\cEv}{a2}{1{=}1\mid\DW{x}{1}}{left=of xd}      
        \xform{xi}{\bForm[1/x]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{1}\SEMI \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\cEv}{a0}{1{=}1\mid\DW{x}{1}}{}
        \eventr{\bEv}{a1}{\DR{x}{1}}{right=of a0}
        \eventr{\aEv}{a2}{1{=}1\mid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Here we apply the predicate transformer $\aTr[0]{\emptyset}{}$ to $(x{=}1)$,
resulting in the tautology $(1{=}1)$.


Now suppose that $\aVal\neq\bVal$ in \eqref{eq2}.  Again there are two
possibilities, where we take $\aVal=0$ and $\bVal=1$:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{0}}{}
        \eventr{\aEv}{a2}{0{=}r\limplies r{=}1\mid\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{0}}{}
        \eventr{\aEv}{a2}{(x{=}r\lor0{=}r)\limplies r{=}1\mid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Assuming that $r$ is bound, both preconditions on $\aEv$ are unsatisfiable.

If a write is independent of a read, then clearly no order is imposed between
them.  For example, the precondition of $\aEv$ is a tautology in:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{0{=}r\limplies\bForm[r/y]}{}
        \eventr{\bEv}{a1}{\DR{x}{0}}{left=of xd}
        \xform{xi}{(x{=}r\lor0{=}r)\limplies\bForm[r/y]}{left=.5em of a1}
        \eventr {\aEv}{a2}{(x{=}r\lor0{=}r)\limplies 1{=}1\mid\DW{y}{1}}{right=of xd}      
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
% \begin{gather*}
%   \PR{x}{r}\SEMI \PW{y}{1}
%   \\
%   \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
%       \event{rx0}{\DR{x}{0}}{}
%       \event{wy1}{1{=}1 \mid \DW{y}{1}}{right=of rx0}
%     \end{tikzinline}}
% \end{gather*}


\subsection{Control Dependencies}
\label{sec:ex:control}

In $\sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$, the predicate transformer
\eqref{if-tau} is
$(\aForm\land\aTr[1]{\bEvs}{\bForm})\lor(\neg\aForm\land\aTr[2]{\bEvs}{\bForm})$,
%$\aTerm \rimplies (\aForm\land\aTerm[1])\lor(\neg\aForm\land\aTerm[2])$,
which is the disjunctive equivalent of \citeauthor{DBLP:journals/cacm/Dijkstra75}'s
conjunctive formulation: $(\aForm\limplies\aTr[1]{\bEvs}{\bForm})\land(\neg\aForm\limplies\aTr[2]{\bEvs}{\bForm})$.
% $\aTerm \rimplies (\aForm\limplies\aTerm[1])\land(\neg\aForm\limplies\aTerm[2])$.
%  \citet{DBLP:journals/cacm/Dijkstra75} used conjunctive normal form.
%  Recall that
%  \href{https://www.wolframalpha.com/input/?i=\%28a+and+b\%29+or+\%28not+a+and+c\%29}{$(\aForm\land\cForm_1)\lor(\neg\aForm\land\cForm_2)$}
%  is logically equivalent to
%  \href{https://www.wolframalpha.com/input/?i=\%28a+implies+b\%29+and+\%28\%28not+a\%29+implies+c\%29}{$(\aForm\limplies\cForm_1)\land(\neg\aForm\limplies\cForm_2)$}. 

This semantics validates dead code elimination:
if $\aExp{\neq}0$ is a tautology then
\begin{math}
  \sem{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} \supseteq
  \sem{\aCmd_1}.
\end{math}
The reverse inclusion does not hold.

For events from $\aEvs_1$, \ref{if-kappa1} requires
$\aForm\land\labelingForm_1(\aEv)$. For events from $\aEvs_2$,
\ref{if-kappa2} requires $\lnot\aForm\land\labelingForm_2(\aEv)$.  For
coalescing events in $\aEvs_1\cap\aEvs_2$, \ref{if-kappa12} requires
$(\aForm\land\labelingForm_1(\aEv)) \lor
(\lnot\aForm\land\labelingForm_2(\aEv))$.  This semantics allows common code
to be lifted out of a conditional, validating the transformation
\begin{math}
  \sem{\IF{\aExp}\THEN\aCmd\ELSE\aCmd\FI} \supseteq
  \sem{\aCmd}.
\end{math}
%
The use of $\rextendsdef{}{}$ in \ref{if-rf-extends}
ensures that no $\rrfx$ is introduced between events in
$\aEvs_1\cap\aEvs_2$ when coalescing; see \textsection\ref{sec:arm2}.



By allowing events to coalesce, \ref{if-kappa12} ensures that control
dependencies are calculated semantically.  For example, consider
$\aPS\in\sem{\IF {r{=}1} \THEN \PW{y}{r} \ELSE \PW{y}{1}\FI}$, which is build
from $\aPS_1\in\sem{\PW{y}{r}}$ and $\aPS_2\in\sem{\PW{y}{1}}$ such as:
\begin{align*}
  \begin{gathered}
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventr{e}{wy1}{r{=}1 \mid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PW{y}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventr{e}{wy1}{1{=}1 \mid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r{=}1} \THEN \PW{y}{r} \ELSE \PW{y}{1}\FI
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventr{e}{wy1}{(r{=}1 \limplies r{=}1) \land (r{\ne}1 \limplies 1{=}1) \mid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}  
\end{align*}
Here, the precondition in the combined pomset is a tautology, independent of $r$.


Control dependencies are eliminated in the same way as data dependencies.
For example:
\begin{align*}
  \begin{gathered}
    \PR{x}{r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aVal{=}r\limplies\bForm}{}
        \eventr{\bEv}{a1}{\DR{x}{\aVal}}{left=of xd}
        \xform{xi}{(x{=}r\lor\aVal{=}r)\limplies\bForm}{left=.5em of a1}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r{=}1}\THEN\PW{y}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{r{=}1\limplies\bForm[1/y]}{}
        \eventr{\aEv}{a2}{r{=}1\mid\DW{y}{\bVal}}{left=of xd}      
        \xform{xi}{r{=}1\limplies\bForm[1/y]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Reasoning as we did for \eqref{eq2} in \textsection\ref{sec:ex:data}, there are two possibilities:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \IF{r{=}1}\THEN\PW{y}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PR{x}{r}\SEMI \IF{r{=}1}\THEN\PW{y}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{x{=}1\mid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}

As another example, consider JMM causality test case 1 \cite{PughWebsite}:
\begin{gather*}
  \begin{gathered}
    \PW{x}{0} \SEMI
    (\PR{x}{r}\SEMI\IF{r{\geq}0}\THEN \PW{y}{1} \FI
    \PAR
    \PW{x}{y})
    \\[-1ex]
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wx0}{\DW{x}{0}}{}
        \event{rx1}{\DR{x}{1}}{right=3em of wx0}
        \event{wy1}{\aForm\mid\DW{y}{1}}{right=of rx1}
        \event{ry1}{\DR{y}{1}}{right=3em of wy1}
        \event{wx1}{\DW{x}{1}}{right=of ry1}
        \po{ry1}{wx1}
        \rf[out=-168,in=-12]{wx1}{rx1}
        \rf{wy1}{ry1}
        \wk[out=10,in=170]{wx0}{wx1}
        \wki{wx0}{rx1}
      \end{tikzinline}}
    % \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
    %   \event{wy1}{0\geq0\mid\DW{y}{1}}{}
    %   \event{rx1}{\DR{x}{1}}{left=of wy1}
    %   \event{wx0}{\DW{x}{0}}{below left=-.2em and 2em of rx1}
    %   \event{ry1}{\DR{y}{1}}{below=of rx1}
    %   \event{wx1}{\DW{x}{1}}{right=of ry1}
    %   \po{ry1}{wx1}
    %   \rf[out=140,in=-20]{wx1}{rx1}
    %   \rf{wy1}{ry1}
    %   \wk[out=10,in=155]{wx0}{wx1}
    %   \wk{wx0}{rx1}
    % \end{tikzinline}}
  \end{gathered}
\end{gather*}
The precondition $\aForm$ is
\begin{math}
  \PBR{(1{=}r \lor x{=}r) \limplies r{\geq}0}[0/x]
\end{math}
which is 
\begin{math}
  \PBR{(1{=}r \lor 0{=}r) \limplies r{\geq}0}
\end{math}
which is a tautology.



\subsection{Reordering Transformations}
\label{sec:ex:valid}

% When $\sem{\aCmd} \supseteq \sem{\aCmd'}$, we say that $\aCmd'$ is a
% \emph{valid transformation} of $\aCmd$.
% In this subsection, we show the
% validity of specific optimizations.  

The semantics validates many peephole optimizations.  Most apply only to
relaxed access.
\begin{align*}
  %\taglabel{RR}
  \sembase{\PR{\aLoc}{\aReg} \SEMI \PR{\bLoc}{\bReg}} &=
  \sembase{\PR{\bLoc}{\bReg}\SEMI \PR{\aLoc}{\aReg}} &&\text{if } \aReg\neq\bReg
  \\
  %\taglabel{WW}
  \sembase{\aLoc \GETS \aExp \SEMI \bLoc  \GETS \bExp} &=
  \sembase{\bLoc  \GETS \bExp\SEMI \aLoc \GETS \aExp} &&\text{if } \aLoc\neq\bLoc
  \\
  %\taglabel{RW}
  \sembase{\aLoc \GETS \aExp  \SEMI \PR{\bLoc}{\bReg}} &=
  \sembase{\PR{\bLoc}{\bReg} \SEMI\aLoc \GETS \aExp} &&\text{if }
  \aLoc\neq\bLoc \textand \bReg\not\in\free(\aExp)%\disjoint{{\free(\aLoc \GETS \aExp)}}{{\free(\PR{\bLoc}{\bReg})}}
\end{align*}
% \ref{WW}, \ref{RW} and \ref{RR} require that two sides of the semicolon
% have disjoint ids; for example, \ref{RW} requires $\disjoint{{\free(\aReg
% \GETS \aLoc)}}{{\free(\bLoc \GETS \bExp)}}$. 
% \ref{RR} requires either $\aReg\neq\bReg$ or
% $\aLoc=\bLoc$.  \ref{WW} and \ref{RW} require that two sides of the
% semicolon have disjoint ids; for example, \ref{RW} requires
% $\disjoint{{\free(\PR{\aLoc}{\aReg})}}{{\free(\bLoc \GETS \bExp)}}$.
%\ref{5} imposes no order between events in \ref{RR}--\ref{RW}.  %Note that \ref{RR} allows aliasing.
Here $\free(\aCmd)$ is the set of locations and registers that occur in $\aCmd$.
Using augmentation closure, the semantics also validates roach-motel reorderings \cite{SevcikThesis}.  For
example, on read/write pairs:
  \begin{align*}
    %\tag{\textsc{roach1}}\label{AcqW}
    \sembase{x^\amode \GETS \aExp \SEMI\PR{y}{\bReg}} &\supseteq
    \sembase{\PR{y}{\bReg}  \SEMI x^\amode\GETS \aExp} 
    &&\text{if }
    \aLoc\neq\bLoc \textand \bReg\not\in\free(\aExp)%\disjoint{{\free(\aLoc \GETS \aExp)}}{{\free(\PR{\bLoc}{\bReg})}}
    \\
    %\tag{\textsc{roach2}}\label{RelW}
    \sembase{x \GETS \aExp \SEMI\PR[\amode]{y}{\bReg}} &\supseteq
    \sembase{\PR[\amode]{y}{\bReg}  \SEMI x\GETS \aExp} 
    &&\text{if }
    \aLoc\neq\bLoc \textand \bReg\not\in\free(\aExp)%\disjoint{{\free(\aLoc \GETS \aExp)}}{{\free(\PR{\bLoc}{\bReg})}}
  \end{align*}


% As expected, %sequential and
% parallel composition commutes with conditionals and declarations, and
% conditionals and declarations commute with each other.  For example,
% we have \emph{scope extrusion}~\cite{Milner:1999:CMS:329902}:
% \begin{align*}
%   \taglabel{SE}
%   \sem{\aCmd\PAR \VAR\aLoc\SEMI\bCmd} &=
%   \sem{\VAR\aLoc\SEMI(\aCmd\PAR\bCmd)}
%   &&\text{if } \aLoc\not\in\free(\aCmd)
% \end{align*}

\label{sec:ex:last}
