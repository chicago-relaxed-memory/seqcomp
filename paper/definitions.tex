\section{Model}

Batty suggest example where dependencies are added and also go away, perhaps
by store forwarding. Something like:
\texttt{(r=x; y=1); (s=y; z=s+r)}

\subsection{Preliminaries}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$.
\end{itemize}
\emph{Memory locations} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory locations, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.

We require that
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
\item for any set $\aEvs$ there are registers $\uRegs{\aEvs}=\{\uReg{\aEv}\mid\aEv\in\aEvs\}$,
\item expressions include at least registers and values, 
\item expressions do \emph{not} include memory locations or registers in
  $\uRegs{\aEvs}$, for any set $\aEvs$.
\end{itemize}
We model the following language.
\begin{align*}
  \amode \BNFDEF& \mRLX
  \BNFSEP \mRA 
  \BNFSEP \mSC
  \\
  \aCmd,\,\bCmd
  \BNFDEF& \SKIP
  \BNFSEP \LET{\aReg}{\aExp}
  % \BNFSEP \PR[\amode]{\aLoc}{\aReg}
  % \BNFSEP \PW[\amode]{\aLoc}{\aExp}
  \BNFSEP \PRREF[\amode]{\cExp}{\aReg}
  \BNFSEP \PWREF[\amode]{\cExp}{\aExp}
  % \BNFSEP \PA{\aLoc}{\aExp} 
  \\[-.5ex]
  \BNFSEP& \FORK{\aGrp}
  \BNFSEP \aCmd \SEMI \bCmd
  \BNFSEP \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
  \\
  \aGrp ,\,\bGrp
  \BNFDEF& \NIL
  \BNFSEP\THREAD{\aCmd}
  \BNFSEP\aGrp \PAR \bGrp
\end{align*}
\emph{Memory modes}, $\amode$, are {relaxed} ($\mRLX$), {release-acquire}
($\mRA$), and {sequentially consistent} ($\mSC$).  Relaxed is the default.
% 
\emph{Commands}, $\aCmd$, include reads from and writes to memory at a given
mode, as well as the usual structural constructs.
% 
\emph{Thread groups}, $\aGrp$, include commands and $\NIL$, which denotes
inaction. %, or deadlock.
% 
The $\FORK{}$ command spawns a thread group.  We often drop the words
$\FORK{}$ and $\THREAD{}$.

The semantics is built from the following.
\begin{itemize}
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, 
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$.
\end{itemize}
We require that
\begin{itemize}
\item actions include writes $\DWP{\aLoc}{\aVal}$ and reads $\DRP{\aLoc}{\aVal}$,
\item formulae include equalities $(\aExp{=}\bExp)$ and $(\aExp{=}\aLoc)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitutions $[\aExp/\aReg]$ and $[\aExp/\aLoc]$, 
\item there is an entailment relation $\vDash$ between formulae, with the
  expected semantics.
\end{itemize}

% Action $\DWP{\aLoc}{\aVal}$ models a write of $\aVal$ to $\aLoc$, and
% $\DRP{\aLoc}{\aVal}$ models a read of $\aVal$ from $\aLoc$.
% We use $\DAP{\aLoc}{\aVal}$ to indicate a generic access, which could be
% either a read or a write.

Logical formulae include equations over locations and registers, such
$(\aLoc{=}1)$ and $(\aReg{=}\bReg{+}1)$.
We use expressions as formulae, coercing $\aExp$ to $\aExp{\neq}0$.
Formulae are subject to substitutions of the form $[\aExp/\aLoc]$; actions are not.

% \begin{definition}
%   \label{def:independent}
%   We say $\aForm$ is \emph{independent of $\aLoc$} if, for every
%   $\aVal$, $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$; it is
%   \emph{dependent} otherwise.
%   We say $\aForm$ is \emph{location independent} if it is independent of
%   every location.
We say
$\aForm$ \emph{implies} $\bForm$ if $\aForm\vDash\bForm$.
% We say that
We say
$\aForm$ is a \emph{tautology} if $\TRUE\vDash\aForm$.
% We say that
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm\vDash\FALSE$.
% \end{definition}




\subsection{Pomsets}

We first consider a fragment of our language that can be modeled using simple
pomsets.
\begin{definition}
  A \emph{pomset} over $\Act$ is a tuple
  $(\Event, {\le}, \labeling)$ where
  \begin{itemize}
  \item $\Event$ is a set of \emph{events},
  \item
    ${\le} \subseteq (\Event\times\Event)$ is the \emph{causality} partial order, 
  \item
    $\labeling: \Event \fun \Act$ is a \emph{labeling}.
  \end{itemize}
\end{definition}
Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.

We lift terminology from actions to events.  For example, we say that $\aEv$
writes $\aLoc$ if $\labeling(\aEv)$ writes $\aLoc$.  We also drop quantifiers
when clear from context, such as
$(\forall\aEv\in\Event)(\forall\aLoc\in\Loc)$.

\begin{definition}
  Action $\DWP{\aLoc}{\aVal}$ \emph{matches} $\DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.
  Action $\DWP{\aLoc}{\aVal}$ \emph{blocks} $\DRP{\aLoc}{\bVal}$, for any
  $\aVal$, $\bVal$.
  
  % A pomset $\aPS$ is \emph{closed} if for every $\aEv$ which can be
  % fulfilled, there is a $\bEv\le\aEv$ which fulfills it, and for any $\cEv$
  % which can block $\aEv$, either $\cEv\le\bEv$ or $\aEv\le\cEv$.

  Event $\aEv$ is \emph{fulfilled} if there is a $\bEv\le\aEv$ which
  matches it and, for any $\cEv$ which can block $\aEv$, either $\cEv\le\bEv$
  or $\aEv\le\cEv$.

  Pomset $\aPS$ is \emph{fulfilled} if every read in $\aPS$ is fulfilled.

  \emph{Independency} (${\reorder}\subseteq\Act\times\Act$) is defined as follows.
  \begin{align*}
    % {\reorderSC} &= \emptyset
    % \\
    % {\reorderRLX} &=
    \reorder &=
    \{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}
    \\[-.5ex]&\mkern2mu\cup\mkern2mu
    \{(\DR{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \}
    % \\[-.5ex]&\mkern2mu\cup\mkern2mu
    % \{(\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc \lor \aVal=\bVal\}
    % \\[-.5ex]&\mkern2mu\cup\mkern2mu
    % \{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}
  \end{align*}
\end{definition}

In order to give the semantics, we define several operators over sets of
pomsets.

\begin{definition} $\phantom{\;}$\par
  \label{tab:pomsets}
  % Let $\aPSS$ range over sets of pomsets.

  \noindent
  If $\aPS\SB0\in\sNIL$ then $\aEvs\SB0 = \emptyset$.

  \noindent
  If $\aPS\SB0 \in (\aPSS_1\sPAR\aPSS_2)$ then  
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
  \item \label{par-E}
    $\aEvs\SB0 = (\aEvs_1\cup\aEvs_2)$,
  \item \label{par-lambda1}
    if $\aEv\in\aEvs_1$ then $\labeling\SB0(\aEv) = \labeling_1(\aEv)$, 
  \item \label{par-lambda2}
    if $\aEv\in\aEvs_2$ then $\labeling\SB0(\aEv) = \labeling_2(\aEv)$,
  \item \label{par-le1}
    if $\bEv\le_1\aEv$ then $\bEv\le\SB0\aEv$, 
  \item \label{par-le2}
    if $\bEv\le_2\aEv$ then $\bEv\le\SB0\aEv$, 
    \newcounter{pomsetParCount}
    \setcounter{pomsetParCount}{\value{enumi}}
  \item \label{par-disjoint}
    $\aEvs_1$ and $\aEvs_2$ are disjoint.
    \newcounter{pomsetParDisjointCount}
    \setcounter{pomsetParDisjointCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS\SB0 \in (\aAct\sPREFIX\aPSS_2)$ then
  $(\exists\aPS_2\in\aPSS_2)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}
  \item \label{pre-E}
    $\aEvs\SB0=(\aEvs_1 \cup \aEvs_2)$,
  \item \label{pre-unique}
    if $\bEv,\aEv\in\aEvs_1$ then $\bEv=\aEv$,
  \item \label{pre-lambda1}
    if $\aEv\in\aEvs_1$ then $\labelingAct\SB0(\aEv) = \aAct$,
  \item \label{pre-lambda2}
    if $\aEv\in\aEvs_2$ then $\labelingAct\SB0(\aEv) = \labelingAct_2(\aEv)$,
  \item \label{pre-le2}
    if $\bEv\le_2\aEv$ then $\bEv\le\SB0\aEv$, 
    % \newcounter{pomsetPrefixCount}
    % \setcounter{pomsetPrefixCount}{\value{enumi}}
  \item
    \label{pre-reorder}
    if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ then either $\bEv\leq\SB0\aEv$ or $a\reorder\labeling_2(\aEv)$.
    \newcounter{pomsetPrefixOrderCount}
    \setcounter{pomsetPrefixOrderCount}{\value{enumi}}
  \end{enumerate}
\end{definition}
Using these operators, we can give the semantics for a simple fragment of our
language.
% To allow interesting examples, we add the operator
% ``$\PA{\aLoc}{\aVal}$.''
\begin{align*}
  \sem{\SKIP} = \sem{\NIL} &= \sNIL
  \\
  % \sem{\THREAD{\aCmd} \PAR \THREAD{\bCmd}} &= \sem{\aCmd}\sPAR\sem{\bCmd}
  % \\
  \sem{\aGrp \PAR \bGrp} &= \sem{\aGrp}\sPAR\sem{\bGrp}
  \\
  % \sem{{\aCmd} \PAR {\bCmd}} &= \sem{\aCmd}\sPAR\sem{\bCmd}
  % \\
  \sem{\PW{\aLoc}{\aVal}\SEMI \aCmd} &= \textstyle\DWP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
  \\
  \sem{\PR{\aLoc}{\aReg}\SEMI \aCmd} &= \textstyle\bigcup_{\aVal}\DRP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
  % \\
  % \sem{\PA{\aLoc}{\aVal}\SEMI \aCmd} &= \textstyle\DRP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
\end{align*}

If we take ${\reorder} = \emptyset$, then we have sequentially consistent
execution.

[Do Examples.]

[Do examples with coherence.]

[Note that this allows mumbling for reads and writes.]

[Use refinement (that is subset order) as notion of compiler optimization.]

[Talk about Mazurkiewicz traces.]

\subsection{Pomsets with Preconditions}

[Problem with previous section is that notion of dependency is impoverished]

The model described here is essentially the model of
\cite{DBLP:journals/pacmpl/JagadeesanJR20}, restricting attention
to relaxed access.  We discuss the differences in the appendix.

\begin{definition}
  A \emph{pomset with preconditions} is
  a pomset together with $\labelingForm:\aEvs\fun\Formulae$.
\end{definition}

\begin{definition}
  A pomset with preconditions is \emph{top level} if it is fulfilled and
  every precondition is a tautology.
\end{definition}

\begin{definition}
  Let $\aSub$ be a substitution.  If $\aPS\in(\aPSS\aSub)$ then
  $(\exists\aPS\in\aPSS)$ $\Event = \Event'$, ${\le} = {\le'}$,
  $\labelingAct = \labelingAct'$, and
  $\labelingForm(\aEv) = \labelingForm'(\aEv)\aSub$.
\end{definition}

\begin{definition}$\phantom{\;}$\par
  \label{tab:pomsets-pre}
  
  \noindent
  If $\aPS\SB0\in\sNIL$ then $\aEvs\SB0 = \emptyset$.

  \noindent
  If $\aPS\SB0 \in (\aPSS_1\sPAR\aPSS_2)$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetParDisjointCount}}
  \item[\ref{par-E}--\ref{par-disjoint})]
    as for $\sPAR$ in Definition~\ref{tab:pomsets},
  \item \label{par-kappa1}
    if $\aEv\in\aEvs_1$ then $\labelingForm\SB0(\aEv)$ implies $\labelingForm_1(\aEv)$,
  \item \label{par-kappa2}
    if $\aEv\in\aEvs_2$ then $\labelingForm\SB0(\aEv)$ implies $\labelingForm_2(\aEv)$.
    \newcounter{pomsetPreParCount}
    \setcounter{pomsetPreParCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS\SB0 \in \sIF{\bForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[\ref{par-E}--\ref{par-le2})] 
    as for $\sPAR$  in Definition~\ref{tab:pomsets} (ignoring disjointness),
  \item \label{if-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm\SB0(\aEv)$ implies $\bForm\land\labelingForm_1(\aEv)$,
  \item \label{if-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm\SB0(\aEv)$ implies $\neg\bForm\land\labelingForm_2(\aEv)$, 
  \item \label{if-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then\\ $\labelingForm\SB0(\aEv)$ implies $(\bForm\land\labelingForm_1(\aEv))\lor(\neg\bForm\land\labelingForm_2(\aEv))$.
    \newcounter{pomsetPreIfCount}
    \setcounter{pomsetPreIfCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS\SB0 \in \sSTOREPRE{\aLoc}{\aExp}{\aPSS_2}$ then
  $(\exists\aPS_2\in\aPSS_2)$
  $(\exists\aVal\in\Val)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPrefixOrderCount}}
  \item[\ref{pre-E}--\ref{pre-reorder})]
    as for $\DWP{\aLoc}{\aVal}\sPREFIX\aPSS_2$ in Definition~\ref{tab:pomsets}, % (ignoring \thepomsetPrefixOrderCount),
  \item \label{storepre-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm\SB0(\aEv)$ implies $\aExp{=}\aVal$,
  \item \label{storepre-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm\SB0(\aEv)$ implies $\labelingForm_2(\aEv)$,
  \item \label{storepre-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm\SB0(\aEv)$ implies $\aExp{=}\aVal \lor \labelingForm_2(\aEv)$.
    % \item if $\aEv\in\aEvs_2$ then either
    %   $\labelingForm\SB0(\aEv)$ implies $\labelingForm_2(\aEv)$ or\\
    %   $\aEv\in\aEvs_1$ and $\labelingForm\SB0(\aEv)$ implies $(\aExp{=}\aVal)\lor \labelingForm_2(\aEv)$.
  \end{enumerate}

  \noindent
  If $\aPS\SB0 \in \sLOADPRE{\aReg}{\aLoc}{\aPSS_2}$ then
  $(\exists\aPS_2\in\aPSS_2)$
  $(\exists\aVal\in\Val)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPrefixOrderCount}}
  \item[\ref{pre-E}--\ref{pre-reorder})]
    as for $\DRP{\aLoc}{\aVal}\sPREFIX\aPSS_2$ in Definition~\ref{tab:pomsets}, % (ignoring \thepomsetPrefixOrderCount),
  \item \label{loadpre-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then either \\
    $\labelingForm\SB0(\aEv)$ implies $(\aReg{=}\aVal\lor\aReg{=}\aLoc)\limplies\labelingForm_2(\aEv)[\aReg/\aLoc]$ or\\
    $\labelingForm\SB0(\aEv)$ implies $(\aReg{=}\aVal)\limplies\labelingForm_2(\aEv)[\aReg/\aLoc]$ and $\bEv<\SB0\aEv$ \\
    \mbox{$\quad$} for some $\bEv\in\aEvs_1$.
  \end{enumerate}  
\end{definition}
Following our convention for subscripts, in the final clause of
$\sLOADPRE{}{}{}$, $<$ refers to the order of $\aPS$.  Also note that
$\sLOADPRE{}{}{}$ does not constrain $\labelingForm\SB0(\aEv)$ if
$\aEv\in\aEvs_1$.

The semantics of $\SKIP$, $\NIL$, and $\PAR$ are as before.
\begin{align*}
  % \sem{\NIL} &= \sNIL
  % \\
  % \sem{\aCmd \PAR \bCmd} &= \sem{\aCmd}\sPAR\sem{\bCmd}
  % \\
  \sem{\IF{\aExp}\THEN\aCmd\ELSE\bCmd\FI} &= \sIF{\aExp{\neq}0}\sTHEN\sem{\aCmd}\sELSE\sem{\bCmd}\sFI
  \\
  \sem{\LET{\aReg}{\aExp}\SEMI \aCmd} &= \sem{\aCmd}[\aExp/\aReg]
  \\
  \sem{\PW{\aLoc}{\aExp}\SEMI \aCmd} &= \sSTOREPRE{\aLoc}{\aExp}{\sem{\aCmd}}
  \\
  \sem{\PR{\aLoc}{\aReg}\SEMI \aCmd} &= \sLOADPRE{\aReg}{\aLoc}{\sem{\aReg}}
\end{align*}

[Stuff about conditionals and merging events.]


\subsection{Pomsets with Predicate Transformers}

\begin{figure*}
  \input{fig-sp}
  \caption{Weakest Precondition and Strongest Postcondition \cite{}}
\end{figure*}

[The problem with the previous section is that there's no story for
sequential composition.]

\begin{definition}
  A \emph{predicate transformer} is a monotone function
  $\aTr:\Formulae\fun\Formulae$ such that
  $\aTr(\FALSE)$ is $\FALSE$,
  $\aTr(\aForm\land\bForm)$ is $\aTr(\aForm)\land\aTr(\bForm)$, and
  $\aTr(\aForm\lor\bForm)$ is $\aTr(\aForm)\lor\aTr(\bForm)$.
\end{definition}

\begin{definition}
  A \emph{family of predicate transformers}
  for $\aEvs$
  consists of a predicate transformer
  $\aTr[\bEvs]$ for each set of events $\bEvs$,
  such that if $\cEvs \cap \aEvs \subseteq \bEvs$
  then $\aTr[\cEvs](\aForm)$ implies $\aTr[\bEvs](\aForm)$.
\end{definition}

[Predicates with smaller subsets of $\aEvs$ are stronger.]

\begin{definition}
  A pomset with predicate tansformers is a pomset with preconditions,
  together with a family of predicate transformers for $\aEvs$.
\end{definition}

% \begin{definition}
%   For pomset $\aPS\SB0$ and $\aEv\in\aEvs\SB0$, let
%   $\downclose[0]{\aEv} = \{ \bEv\in\aEvs\SB0 \mid \bEv <\SB0 \aEv \}$.
% \end{definition}

\begin{definition}
  If $\aPS\SB0\in\sABORT$ then $\aEvs\SB0 = \emptyset$ and
  \begin{enumerate}
  \item $\aTr[\bEvs]\SB0(\aForm)$ implies $\FALSE$.
  \end{enumerate}

  \noindent
  If $\aPS\SB0\in\sSKIP$ then $\aEvs\SB0 = \emptyset$ and
  \begin{enumerate}
  \item $\aTr[\bEvs]\SB0(\aForm)$ implies $\aForm$.
  \end{enumerate}

  \noindent
  If $\aPS\SB0\in\sLET{\aReg}{\aExp}$ then $\aEvs\SB0 = \emptyset$ and
  \begin{enumerate}
  \item $\aTr[\bEvs]\SB0(\aForm)$ implies $\aForm[\aExp/\aReg]$.
  \end{enumerate}

  \noindent
  If $\aPS\SB0 \in \sIF{\bForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPreIfCount}}
  \item[1--\ref{if-kappa12})] as for $\sIF{}$ in Definition~\ref{tab:pomsets-pre},
  \item \label{if-tau}
    $\aTr[\bEvs]\SB0(\aForm)$ implies $(\bForm\land\aTr[\bEvs]_1(\aForm))\lor(\neg\bForm\land\aTr[\bEvs]_2(\aForm))$.
  \end{enumerate}

  \noindent
  If $\aPS\SB0 \in (\aPSS_1\sSEMI\aPSS_2)$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$,
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  % let $\labelingForm'_2(\aEv)=\aTr[{\downclose[0]{\aEv}}]_1(\labelingForm_2(\aEv))$  
  % let $\labelingForm'_2(\aEv)=\aTr[\{ \bEv \mid \bEv <\SB0 \aEv \}]_1(\labelingForm_2(\aEv))$  
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[1--\ref{par-le2})]
    as for $\sPAR$  in Definition~\ref{tab:pomsets} (ignoring disjointness),
  \item \label{seq-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm\SB0(\aEv)$ implies $\labelingForm_1(\aEv)$,
  \item \label{seq-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm\SB0(\aEv)$ implies $\labelingForm'_2(\aEv)$,
  \item \label{seq-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm\SB0(\aEv)$ implies $\labelingForm_1(\aEv)\lor\labelingForm'_2(\aEv)$,
    \\ where $\labelingForm'_2(\aEv)=\aTr[\cEvs]_1(\labelingForm_2(\aEv))$, where $\cEvs=\{ \cEv \mid \cEv <\SB0 \aEv \}$,
  \item \label{seq-tau}
    $\aTr[\bEvs]\SB0(\aForm)$ implies $\aTr[\bEvs]_1(\aTr[\bEvs]_2(\aForm))$.
    \newcounter{pomsetXSemiCount}
    \setcounter{pomsetXSemiCount}{\value{enumi}}
    % \item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ either $\bEv<\SB0\aEv$ or $a\reorder\labeling_2(\aEv)$.
  \end{enumerate}
  % where we define $\labelingForm'_2(\aEv)$ to be $\aTr[\{ \bEv \mid \bEv <\SB0 \aEv \}]_1(\labelingForm_2(\aEv))$.

  \noindent
  If $\aPS\SB0 \in \sSTORE[\amode]{\aLoc}{\aExp}$ then
  $(\exists\aVal\in\Val)$
  $(\forall\bEvs\neq\emptyset)$
  \begin{enumerate}
  \item[{\labeltext[S1]{S1)}{S1}}]
    if $\bEv,\aEv\in\aEvs\SB0$ then $\bEv=\aEv$,
  \item[{\labeltext[S2]{S2)}{S2}}]
    $\labelingAct\SB0(\aEv) = \DWP{\aLoc}{\aVal}$,
  \item[{\labeltext[S3]{S3)}{S3}}]
    $\labelingForm\SB0(\aEv)$ implies $\aExp{=}\aVal$,
  \item[{\labeltext[S4]{S4)}{S4}}]
    $\aTr[\bEvs]\SB0(\aForm)$ implies $\aForm[\aExp/\aLoc]$, % \land (\Q{}\limplies\aExp{=}\aVal)$,
  \item[{\labeltext[S5]{S5)}{S5}}]
    $\aTr[\emptyset]\SB0(\aForm)\;$ implies $\aForm[\aExp/\aLoc]$. % \land \lnot\Q{}$.
    % \item %if $\bEvs\neq\emptyset$ then
    %   $\aTr[\bEvs]\SB0(\aForm)$ implies $(\aExp{=}\aVal) \land \aForm[\aExp/\aLoc]$, if $\bEvs\neq\emptyset$,
    %   \newcounter{pomsetXStoreCount}
    %   \setcounter{pomsetXStoreCount}{\value{enumi}}
  \end{enumerate}

  % \noindent
  % If $\aPS\SB0 \in \sLOAD[\amode]{\aReg}{\aLoc}$ then
  % $(\exists\aVal\in\Val)$
  % $(\forall\bEvs\neq\emptyset)$
  % \begin{enumerate}
  % \item[{\labeltext[L1]{L1)}{L1}}] 
  %   if $\bEv,\aEv\in\aEvs\SB0$ then $\bEv=\aEv$,
  % \item[{\labeltext[L2]{L2)}{L2}}]
  %   $\labelingAct\SB0(\aEv) = \DRP{\aLoc}{\aVal}$,
  % \item[{\labeltext[L3]{L3)}{L3}}]
  %   $\labelingForm\SB0(\aEv)$ implies $\TRUE$,
  % \item[{\labeltext[L4]{L4)}{L4}}]
  %   % if $\bEvs\neq\emptyset$ then
  %   $\aTr[\bEvs]\SB0(\aForm)$ implies %$\phantom{(\aLoc{=}\aReg\lor{}}
  %   $\aVal{=}\aReg\limplies\aForm[\aReg/\aLoc]$, 
  % \item[{\labeltext[L5]{L5)}{L5}}]
  %   % if $\bEvs=\emptyset$ then
  %   $\aTr[\emptyset]\SB0(\aForm)\;$ implies $((\aLoc{=}\aReg\lor\aVal{=}\aReg)\limplies\aForm[\aReg/\aLoc]) \land \lnot\Q{}$.
  % \item[{\labeltext[L6]{L6)}{L6}}]
  %    if $\aEvs=\emptyset$ then
  %   $\aTr[\emptyset]\SB0(\aForm)\;$ implies $\aForm[\aReg/\aLoc] \land \lnot\Q{}$.
  % \end{enumerate}

  \noindent
  If $\aPS\SB0 \in \sLOAD[\amode]{\aReg}{\aLoc}$ then either
  $\aEvs{\neq}\emptyset$
  $(\exists\aVal{\in}\Val)$
  $(\forall\bEvs{\neq}\emptyset)$
  \begin{enumerate}
  \item[{\labeltext[L1]{L1)}{L1}}] 
    if $\bEv,\aEv\in\aEvs\SB0$ then $\bEv=\aEv$,
  \item[{\labeltext[L2]{L2)}{L2}}]
    $\labelingAct\SB0(\aEv) = \DRP{\aLoc}{\aVal}$,
  \item[{\labeltext[L3]{L3)}{L3}}]
    $\labelingForm\SB0(\aEv)$ implies $\TRUE$,
  \item[{\labeltext[L4]{L4)}{L4}}]
    $\aTr[\bEvs]\SB0(\aForm)$ implies $\aVal{=}\aReg\limplies\aForm[\aReg/\aLoc]$, 
  \item[{\labeltext[L5]{L5)}{L5}}]
    $\aTr[\emptyset]\SB0(\aForm)\;$ implies $((\aLoc{=}\aReg\lor\aVal{=}\aReg)\limplies\aForm[\aReg/\aLoc])$, % \land \lnot\Q{}$,
  \end{enumerate}
  or
  $\aEvs=\emptyset$ and 
  \begin{enumerate}
  \item[{\labeltext[E1]{E1)}{E1}}] 
    $\aTr[\emptyset]\SB0(\aForm)\;$ implies $\aForm[\aReg/\aLoc]$. % \land \lnot\Q{}$.
  \end{enumerate}
\end{definition}
% [Note that we could change the premise of $\aTr[\emptyset]$ in $\sLOAD{}{}$
% from $(\aVal{=}\aReg\lor\aLoc{=}\aReg)$ to $(\aLoc{=}\aReg)$. The
% requirements of a family of predicate transforms effectively adds the
% additional requirement.]

OOPSLA is non-skolemized---with $[x/r]$ rather than $[r/x]$:
\begin{enumerate}
\item[\ref{L4})]
  $\aTr[\bEvs]\SB0(\aForm)$ implies $\aForm[\aLoc/\aReg][\aVal/\aLoc]$, 
\item[\ref{L5})]
  $\aTr[\emptyset]\SB0(\aForm)\;$ implies $\aForm[\aLoc/\aReg][\aVal/\aLoc]\land\aForm[\aLoc/\aReg]$,
\item[\ref{E1})]
  $\aTr[\emptyset]\SB0(\aForm)\;$ implies $\aForm[\aLoc/\aReg]$.
\end{enumerate}

[Skolemization ensures disjunction closure, which is necessary
for associativity. Show example.]



\begin{example} Consider the following executions.
\begin{align*}
\begin{gathered}
  \PW{x}{1}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{1{=}1\mid\DW{x}{1}}{}
      \xform{x1d}{\aForm[1/x]}{right=of a1}
      \xform{x1i}{\aForm[1/x]}{below=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gathered}
&&
\begin{gathered}
  \PW{x}{2}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{2{=}1\mid\DW{x}{1}}{}
      \xform{x1d}{\aForm[2/x]}{right=of a1}
      \xform{x1i}{\aForm[2/x]}{below=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gathered}
\end{align*}
% Simplifying:
% \begin{align*}
% \begin{gathered}
%   % \PW{x}{1}
%   % \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DW{x}{1}}{}
%       \xform{x1d}{\aForm[1/x]}{right=of a1}
%       \xform{x1i}{\aForm[1/x]}{right=of x1d}
%       \xo{a1}{x1d}
%     \end{tikzinline}}
% \end{gathered}
% &&
% \begin{gathered}
%   % \PW{x}{2}
%   % \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\FALSE\mid\DW{x}{1}}{}
%       \xform{x1d}{\FALSE}{right=of a1}
%       \xform{x1i}{\aForm[2/x]}{right=of x1d}
%       \xo{a1}{x1d}
%     \end{tikzinline}}
% \end{gathered}
% \end{align*}
Merging the actions, we have:
% \begin{gather*}
%   \PW{x}{1}\SEMI \PW{x}{2}
%   \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
%       \xform{x1d}{(\aForm[1/x])[2/x]}{below=of a1}
%       \xform{x1i}{(\aForm[1/x])[2/x]}{below=of x1d}
%       \xo{a1}{x1d}
%     \end{tikzinline}}
% \end{gather*}
% which simplifies to
% \begin{gather*}
%   % \PW{x}{1}\SEMI \PW{x}{2}
%   % \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DW{x}{1}}{}
%       \xform{x1d}{\aForm[1/x] }{right=of a1}
%       \xform{x1i}{\aForm[1/x]}{right=of x1d}
%       \xo{a1}{x1d}
%     \end{tikzinline}}
% \end{gather*}
% which simplifies to
\begin{gather*}
  \PW{x}{1}\SEMI \PW{x}{2}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
      \xform{x1d}{(\aForm[2/x])[1/x]}{right=of a1}
      \xform{x1i}{(\aForm[2/x])[1/x]}{right=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gather*}
which simplifies to
\begin{gather*}
  % \PW{x}{1}\SEMI \PW{x}{2}
  % \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{\DW{x}{1}}{}
      \xform{x1d}{\aForm[2/x]}{right=of a1}
      \xform{x1i}{\aForm[2/x]}{right=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gather*}
% \end{example}
% \begin{example} Merging right.
% \begin{align*}
% \begin{gathered}
%   \PW{x}{1}
%   \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{1{=}2\mid\DW{x}{1}}{}
%       \xform{x1d}{\aForm[1/x]}{right=of a1}
%       \xform{x1i}{\aForm[1/x]}{below=of x1d}
%       \xo{a1}{x1d}
%     \end{tikzinline}}
% \end{gathered}
% &&
% \begin{gathered}
%   \PW{x}{2}
%   \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{2{=}2\mid\DW{x}{1}}{}
%       \xform{x1d}{\aForm[2/x]}{right=of a1}
%       \xform{x1i}{\aForm[2/x]}{below=of x1d}
%       \xo{a1}{x1d}
%     \end{tikzinline}}
% \end{gathered}
% \end{align*}
% Simplifying:
% \begin{align*}
% \begin{gathered}
%   \PW{x}{1}
%   \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\FALSE\mid\DW{x}{2}}{}
%       \xform{x1d}{\FALSE}{right=of a1}
%       \xform{x1i}{\aForm[1/x]}{right=of x1d}
%       \xo{a1}{x1d}
%     \end{tikzinline}}
% \end{gathered}
% &&
% \begin{gathered}
%   \PW{x}{2}
%   \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DW{x}{2}}{}
%       \xform{x1d}{\aForm[2/x]}{right=of a1}
%       \xform{x1i}{\aForm[2/x]}{right=of x1d}
%       \xo{a1}{x1d}
%     \end{tikzinline}}
% \end{gathered}
% \end{align*}
% Merging the actions, we have:
The programs are also capable of writing 2.
\begin{align*}
\begin{gathered}
  \PW{x}{1}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{1{=}2\mid\DW{x}{2}}{}
      \xform{x1d}{\aForm[1/x]}{right=of a1}
      \xform{x1i}{\aForm[1/x]}{below=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gathered}
&&
\begin{gathered}
  \PW{x}{2}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{2{=}2\mid\DW{x}{2}}{}
      \xform{x1d}{\aForm[2/x]}{right=of a1}
      \xform{x1i}{\aForm[2/x]}{below=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gathered}
\end{align*}
Merging right.
\begin{gather*}
  % \PW{x}{1}\SEMI \PW{x}{2}
  % \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{\DW{x}{2}}{}
      \xform{x1d}{\aForm[2/x]}{right=of a1}
      \xform{x1i}{\aForm[2/x]}{right=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gather*}
\end{example}

\begin{example}
Separate actions:
\begin{align*}
  \begin{gathered}
    \PW{x}{1} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aForm[1/x]}{}
        \xform{xi}{\aForm[1/x]}{below=of xd}
        \event{a1}{1{=}1\mid\DW{x}{1}}{left=of xd}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aForm[2/x]}{}
        \xform{xi}{\aForm[2/x]}{below=of xd}
        \event{a2}{2{=}2\mid\DW{x}{2}}{left=of xd}      
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Simplifying:
\begin{align*}
  \begin{gathered}
    % \PW{x}{1} 
    % \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aForm[1/x]}{}
        \xform{xi}{\aForm[1/x]}{right=of xd}
        \event{a1}{\DW{x}{1}}{left=of xd}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    % \PW{x}{2}
    % \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aForm[2/x]}{}
        \xform{xi}{\aForm[2/x]}{right=of xd}
        \event{a2}{\DW{x}{2}}{left=of xd}      
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Putting these together unordered:
\begin{gather*}
  \PW{x}{1}\SEMI \PW{x}{2}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \xform{xdi}{\aForm[2/x]}{}
      \xform{xdd}{\aForm[2/x]}{right=of xdi}
      \xform{xid}{\aForm[2/x]}{right=of xdd}
      \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
      \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
      \xform{xii}{\aForm[2/x]}{right=of xid}
      \xo{a1}{xdi}
      \xo{a2}{xid}
      \xo{a1}{xdd}
      \xo{a2}{xdd}
    \end{tikzinline}}
\end{gather*}
Adding order does nothing since the preconditions are tautologies.
% \begin{gather*}
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \xform{xdi}{\aForm[1/x]}{}
%       \xform{xdd}{\aForm[1/x]}{right=of xdi}
%       \xform{xid}{\aForm[1/x]}{right=of xdd}
%       \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
%       \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
%       \xform{xii}{\aForm[1/x]}{right=of xid}
%       \xo{a1}{xdi}
%       \xo{a2}{xid}
%       \xo{a1}{xdd}
%       \xo{a2}{xdd}
%       \po{a1}{a2}
%     \end{tikzinline}}
% \end{gather*}
\end{example}

\begin{example}
Read to write dependency, first separately:
\begin{align*}
  \begin{gathered}
    \PR{x}{r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{(1{=}r)\limplies\aForm[r/x]}{}
        \xform{xi}{((x{=}r\lor1{=}r)\limplies\aForm[r/x])}{below=of xd}
        \event{a1}{\DR{x}{1}}{above=of xd}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aForm[r/y]\land r{=}1}{}
        \xform{xi}{\aForm[r/y]}{below=of xd}
        \event{a2}{r{=}1\mid\DW{y}{1}}{above=of xd}      
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Putting these together without order:
% \begin{gather*}
%   \PR{x}{r} \SEMI
%   \PW{y}{r}
%   \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \xform{xdi}{((1{=}r)\limplies\aForm[r/x])[r/y]}{}
%       \xform{xid}{(((x{=}r\lor1{=}r)\limplies\aForm[r/x]))[r/y]\land r{=}1}{right=of xdi}
%       \event{a1}{\DR{x}{1}}{above=of xdi}
%       \event{a2}{((x{=}r\lor1{=}r)\limplies r{=}1)\mid\DW{y}{1}}{right=of a1}
%       \xform{xdd}{((1{=}r)\limplies\aForm[r/x])[r/y]\land r{=}1}{above right=.5em and -1em of a1}
%       \xform{xii}{(((x{=}r\lor1{=}r)\limplies\aForm[r/x]))[r/y]}{below=2.7em of a2}
%       \xo{a1}{xdi}
%       \xo{a2}{xid}
%       \xo{a1}{xdd}
%       \xo{a2}{xdd}
%     \end{tikzinline}}
% \end{gather*}
% simplifying:
\begin{gather*}
  \PR{x}{r} \SEMI
  \PW{y}{r}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \xform{xdi}{(1{=}r)\limplies\aForm[r/x][r/y]}{}
      \xform{xid}{((x{=}r\lor1{=}r)\limplies\aForm[r/x][r/y]) \land r{=}1}{right=of xdi}
      \event{a1}{\DR{x}{1}}{above=of xdi}
      \event{a2}{((x{=}r\lor1{=}r)\limplies r{=}1)\mid\DW{y}{1}}{right=of a1}
      \xform{xdd}{((1{=}r)\limplies\aForm[r/x][r/y])\land r{=}1}{above right=.5em and -1em of a1}
      \xform{xii}{(x{=}r\lor1{=}r)\limplies\aForm[r/x][r/y]}{below=2.7em of a2}
      \xo{a1}{xdi}
      \xo{a2}{xid}
      \xo{a1}{xdd}
      \xo{a2}{xdd}
    \end{tikzinline}}
\end{gather*}
If the read is ordered before the write, then the precondition of the write
can be weakened: % to
% \begin{math}
%   1{=}r\limplies r{=}1.
% \end{math}
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{1{=}r\limplies r{=}1\mid\DW{y}{1}}{right=of a1}
      \po{a1}{a2}
    \end{tikzinline}}
\end{gather*}
\end{example}


We have not given a semantics for parallel composition with predicate transformers.
Define $\sTHREAD{}$ to embed pomsets with predicate transformers into pomsets with preconditions
simply by dropping the predicate transformer.
For the reverse embedding, $\sFORK{}$ adopts the identity transformer.
\begin{definition} $\phantom{\;}$\par
  \label{def:thread}
  \noindent
  If $\aPS\SB0 \in \sTHREAD{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}
  \item \label{thread-E}
    $\aEvs\SB0=\aEvs_1$,
  \item \label{thread-lambda}
    $\labelingAct\SB0(\aEv) = \labelingAct_1(\aEv)$,
  \item \label{thread-kappa}
    $\labelingForm\SB0(\aEv)$ implies $\labelingForm_1(\aEv)$.
    \newcounter{pomsetXThreadCount}
    \setcounter{pomsetXThreadCount}{\value{enumi}}
  \end{enumerate}  

  \label{def:fork}
  \noindent
  If $\aPS\SB0 \in \sFORK{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}
  \item[{\labeltext[F1]{F1)}{F1}\labeltext[1]{}{F1x}}]
    $\aEvs\SB0=\aEvs_1$,
  \item[{\labeltext[F2]{F2)}{F2}}]
    $\labelingAct\SB0(\aEv) = \labelingAct_1(\aEv)$,
  \item[{\labeltext[F3]{F3)}{F3}}]
    $\labelingForm\SB0(\aEv)$ implies $\labelingForm_1(\aEv)$, 
  \item[{\labeltext[F4]{F4)}{F4}\labeltext[4]{}{F4x}}]
    $\aTr[\bEvs]\SB0(\aForm)$ implies $\aForm$.
    \newcounter{pomsetXForkCount}
    \setcounter{pomsetXForkCount}{\value{enumi}}
  \end{enumerate}  
\end{definition}



The complete semantics is as follows.
\begin{scope}
  \allowdisplaybreaks
  \begin{align*}
    \sem{\ABORT} &= \sABORT
    \\
    \sem{\SKIP} &= \sSKIP
    \\
    \sem{\PR[\amode]{\aLoc}{\aReg}} &= \sLOAD[\amode]{\aReg}{\aLoc}
    \\
    \sem{\PW[\amode]{\aLoc}{\aExp}} &= \sSTORE[\amode]{\aLoc}{\aExp}
    \\
    \sem{\LET{\aReg}{\aExp}} &= \sLET{\aReg}{\aExp}
    \\
    \sem{\FORK{\aGrp}} &= \sFORK{}\sem{\aGrp}
    \\
    \sem{\aCmd \SEMI \bCmd} &= \sem{\aCmd}\sSEMI\sem{\bCmd}
    \\
    \sem{\IF{\aExp}\THEN\aCmd\ELSE\bCmd\FI} &= \sIF{\aExp{\neq}0}\sTHEN\sem{\aCmd}\sELSE\sem{\bCmd}\sFI
    \\
    \sem{\NIL} &= \sNIL
    \\
    \sem{\THREAD{\aCmd}} &= \sTHREAD{}\sem{\aCmd}
    \\
    \sem{\aGrp \PAR \bGrp} &= \sem{\aGrp}\sPAR\sem{\bGrp}
  \end{align*}
\end{scope}
[Examples.]










\subsection{Quiescence}

Strengthen the transformers as follow.
\begin{enumerate}
\item[\ref{S4})]
  %$\aTr[\bEvs]\SB0(\aForm)$ implies $\Q{}\limplies\aExp{=}\aVal$,
  $\aTr[\bEvs]\SB0(\aForm)$ implies $\aForm[\aExp/\aLoc] \land (\Q{}\limplies\aExp{=}\aVal)$,
\item[\ref{S5})]
  %$\aTr[\emptyset]\SB0(\aForm)\;$ implies $\lnot\Q{}$,
  $\aTr[\emptyset]\SB0(\aForm)\;$ implies $\aForm[\aExp/\aLoc] \land \lnot\Q{}$.
\item[\ref{L5})]
  %$\aTr[\emptyset]\SB0(\aForm)\;$ implies $\lnot\Q{}$,
  $\aTr[\emptyset]\SB0(\aForm)\;$ implies $((\aLoc{=}\aReg\lor\aVal{=}\aReg)\limplies\aForm[\aReg/\aLoc]) \land \lnot\Q{}$,
\item[\ref{E1})]
  %$\aTr[\emptyset]\SB0(\aForm)\;$ implies $\lnot\Q{}$,
  $\aTr[\emptyset]\SB0(\aForm)\;$ implies $\aForm[\aReg/\aLoc] \land \lnot\Q{}$.
\end{enumerate}
Update fork as follows
\begin{enumerate}
\item[\ref{F3})]
  $\labelingForm\SB0(\aEv)$ implies $\labelingForm_1(\aEv)[\TRUE/\Q{}]$, 
\end{enumerate}
% or
% \begin{enumerate}
% \item[{\labeltext[S6]{S6)}{S6}}] 
%   $\aTr[\bEvs]\SB0(\aForm)$ implies $\Q{}\limplies\aExp{=}\aVal$,
% \item[{\labeltext[S7]{S7)}{S7}}] 
%   $\aTr[\emptyset]\SB0(\aForm)\;$ implies $\lnot\Q{}$,
% \item[{\labeltext[L6]{L6)}{L6}}] 
%   $\aTr[\emptyset]\SB0(\aForm)\;$ implies $\lnot\Q{}$,
% \item[{\labeltext[E2]{E2)}{E2}}] 
%   $\aTr[\emptyset]\SB0(\aForm)\;$ implies $\lnot\Q{}$.
% \end{enumerate}

\begin{definition}
  $\aPS$ is \emph{quiescent} if $\aTr[\aEvs](\Q{})$ implies $\Q{}$.
\end{definition}


\begin{example}
  Merging left.
\begin{align*}
\begin{gathered}
  \PW{x}{1}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{1{=}1\mid\DW{x}{1}}{}
      \xform{x1d}{\aForm[1/x]\land (\Q{}\limplies 1{=}1)}{below=of a1}
      \xform{x1i}{\aForm[1/x]\land \lnot\Q{}}{below=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gathered}
&&
\begin{gathered}
  \PW{x}{2}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{2{=}1\mid\DW{x}{1}}{}
      \xform{x1d}{\aForm[2/x]\land (\Q{}\limplies 2{=}1)}{below=of a1}
      \xform{x1i}{\aForm[2/x]\land \lnot\Q{}}{below=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gathered}
\end{align*}
Simplifying:
\begin{align*}
\begin{gathered}
  \PW{x}{1}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{\DW{x}{1}}{}
      \xform{x1d}{\aForm[1/x]}{right=of a1}
      \xform{x1i}{\aForm[1/x]\land \lnot\Q{}}{below=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gathered}
&&
\begin{gathered}
  \PW{x}{2}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{\FALSE\mid\DW{x}{1}}{}
      \xform{x1d}{\aForm[2/x]\land \lnot\Q{}}{right=of a1}
      \xform{x1i}{\aForm[2/x]\land \lnot\Q{}}{below=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gathered}
\end{align*}
Merging the actions, we have:
% \begin{gather*}
%   \PW{x}{1}\SEMI \PW{x}{2}
%   \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
%       \xform{x1d}{(\aForm[1/x]\land (\Q{}\limplies 1{=}1))[2/x]\land (\Q{}\limplies 2{=}1)}{below=of a1}
%       \xform{x1i}{(\aForm[1/x]\land \lnot\Q{})[2/x]\land \lnot\Q{}}{below=of x1d}
%       \xo{a1}{x1d}
%     \end{tikzinline}}
% \end{gather*}
% which simplifies to
% \begin{gather*}
%   % \PW{x}{1}\SEMI \PW{x}{2}
%   % \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \event{a1}{\DW{x}{1}}{}
%       \xform{x1d}{\aForm[1/x]\land (\Q{}\limplies 1{=}1 \land 2{=}1)}{right=of a1}
%       \xform{x1i}{\aForm[1/x]\land \lnot\Q{}}{right=of x1d}
%       \xo{a1}{x1d}
%     \end{tikzinline}}
% \end{gather*}
% which simplifies to
\begin{gather*}
  % \PW{x}{1}\SEMI \PW{x}{2}
  % \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{\DW{x}{1}}{}
      \xform{x1d}{(\aForm[1/x])[2/x]\land \lnot\Q{}}{right=of a1}
      \xform{x1i}{(\aForm[1/x]\land \lnot\Q{})[2/x]\land \lnot\Q{}}{below=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gather*}
which simplifies to
\begin{gather*}
  % \PW{x}{1}\SEMI \PW{x}{2}
  % \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{\DW{x}{1}}{}
      \xform{x1d}{\aForm[1/x]\land \lnot\Q{}}{right=of a1}
      \xform{x1i}{\aForm[1/x]\land \lnot\Q{}}{right=of x1d}
      \xo{a1}{x1d}
    \end{tikzinline}}
\end{gather*}
\end{example}

\begin{example}
 Separate actions:
\begin{align*}
  \begin{gathered}
    \PW{x}{1} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aForm[1/x]\land (\Q{}\limplies 1{=}1)}{}
        \xform{xi}{\aForm[1/x]\land \lnot\Q{}}{below=of xd}
        \event{a1}{1{=}1\mid\DW{x}{1}}{above=of xd}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aForm[2/x]\land (\Q{}\limplies 2{=}2)}{}
        \xform{xi}{\aForm[2/x]\land \lnot\Q{}}{below=of xd}
        \event{a2}{2{=}2\mid\DW{x}{2}}{above=of xd}      
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Simplifying:
\begin{align*}
  \begin{gathered}
    \PW{x}{1} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aForm[1/x]}{}
        \xform{xi}{\aForm[1/x]\land \lnot\Q{}}{below=of xd}
        \event{a1}{\DW{x}{1}}{left=of xd}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aForm[2/x]}{}
        \xform{xi}{\aForm[2/x]\land \lnot\Q{}}{below=of xd}
        \event{a2}{\DW{x}{2}}{left=of xd}      
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Putting these together unordered:
\begin{gather*}
  \PW{x}{1}\SEMI \PW{x}{2}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \xform{xdi}{\aForm[1/x]\land \lnot\Q{}}{}
      \xform{xdd}{\aForm[1/x]}{right=of xdi}
      \xform{xid}{\aForm[1/x]\land \lnot\Q{}}{right=of xdd}
      \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
      \event{a2}{\lnot\Q{}\mid\DW{x}{2}}{above right=.5em and -1em of xdd}
      \xform{xii}{\aForm[1/x]\land \lnot\Q{}}{below=of xdd}
      \xo{a1}{xdi}
      \xo{a2}{xid}
      \xo{a1}{xdd}
      \xo{a2}{xdd}
    \end{tikzinline}}
\end{gather*}
Adding order does nothing since the preconditions are tautologies.
% \begin{gather*}
%   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%       \xform{xdi}{\aForm[1/x]\land \lnot\Q{}}{}
%       \xform{xdd}{\aForm[1/x]}{right=of xdi}
%       \xform{xid}{\aForm[1/x]\land \lnot\Q{}}{right=of xdd}
%       \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
%       \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
%       \xform{xii}{\aForm[1/x]\land \lnot\Q{}}{below=of xdd}
%       \xo{a1}{xdi}
%       \xo{a2}{xid}
%       \xo{a1}{xdd}
%       \xo{a2}{xdd}
%       \po{a1}{a2}
%     \end{tikzinline}}
% \end{gather*}
\end{example}

\begin{comment}
Read to write dependency, first separately:
\begin{align*}
  \begin{gathered}
    \PR{x}{r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{(1{=}r)\limplies\aForm[r/x]}{}
        \xform{xi}{((x{=}r\lor1{=}r)\limplies\aForm[r/x])\land \lnot\Q{}}{below=of xd}
        \event{a1}{\DR{x}{1}}{above=of xd}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aForm[r/y]\land (\Q{}\limplies r{=}1)}{}
        \xform{xi}{\aForm[r/y]\land \lnot\Q{}}{below=of xd}
        \event{a2}{r{=}1\mid\DW{y}{1}}{above=of xd}      
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Putting these together without order:
\begin{gather*}
  \PR{x}{r} \SEMI
  \PW{y}{r}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \xform{xdi}{((1{=}r)\limplies\aForm[r/x])[r/y]\land \lnot\Q{}}{}
      \xform{xid}{(((x{=}r\lor1{=}r)\limplies\aForm[r/x])\land \lnot\Q{})[r/y]\land (\Q{}\limplies r{=}1)}{below right=.5em and -10em of xdi}
      \event{a1}{\DR{x}{1}}{above=of xdi}
      \event{a2}{((x{=}r\lor1{=}r)\limplies r{=}1) \land\lnot\Q{}\mid\DW{y}{1}}{above right=2.7em and -16em of xid}
      \xform{xdd}{((1{=}r)\limplies\aForm[r/x])[r/y]\land (\Q{}\limplies r{=}1)}{above right=.5em and -1em of a1}
      \xform{xii}{(((x{=}r\lor1{=}r)\limplies\aForm[r/x])\land \lnot\Q{})[r/y]\land \lnot\Q{}}{below=of xid}
      \xo{a1}{xdi}
      \xo{a2}{xid}
      \xo{a1}{xdd}
      \xo{a2}{xdd}
    \end{tikzinline}}
\end{gather*}
Note that
\begin{math}
  \lnot\Q{}\land (\Q{}\limplies r{=}1)
\end{math}
simplifies to 
\begin{math}
  \lnot\Q{}.
\end{math}
\begin{gather*}
  \PR{x}{r} \SEMI
  \PW{y}{r}
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \xform{xdi}{((1{=}r)\limplies\aForm[r/x][r/y])\land \lnot\Q{}}{}
      \xform{xid}{((x{=}r\lor1{=}r)\limplies\aForm[r/x][r/y])\land \lnot\Q{}}{below right=.5em and -4em of xdi}
      \event{a1}{\DR{x}{1}}{above=of xdi}
      \event{a2}{((x{=}r\lor1{=}r)\limplies r{=}1) \land\lnot\Q{}\mid\DW{y}{1}}{above=2.7em of xid}
      \xform{xdd}{((1{=}r)\limplies\aForm[r/x][r/y])\land (\Q{}\limplies r{=}1)}{above right=.5em and -1em of a1}
      \xform{xii}{((x{=}r\lor1{=}r)\limplies\aForm[r/x][r/y])\land \lnot\Q{}}{below=of xid}
      \xo{a1}{xdi}
      \xo{a2}{xid}
      \xo{a1}{xdd}
      \xo{a2}{xdd}
    \end{tikzinline}}
\end{gather*}
With order:
\begin{gather*}
  % \PR{x}{r} \SEMI
  % \PW{y}{r}
  % \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{1{=}r\limplies r{=}1\mid\DW{y}{1}}{right=of a1}
      \po{a1}{a2}
    \end{tikzinline}}
\end{gather*}
\end{comment}



\subsection{Fork-Join}

[We drop $\reorder$ because incompatible with $\sFORK{}$.  If you want to use
$\reorder$, then you need to use fork-join as the sequential combinator,
rather than fork.]

\begin{definition}
  A \emph{pomset with preconditions and termination} is
  a pomset with preconditions together with a predicate $\TICK$.
\end{definition}

% Define $\sTHREAD{}$ to transform a pomset with predicate transformers into a
% pomset with preconditions and termination by dropping the predicate
% transformer and setting $\TICK$ to indicate whether the pomset was completed.

% Extend the definition of $\sNIL$ so that $\TICK$ is true.

% Extend the definition of $\sPAR$ to handle for $\TICK$ by adding the
% following.
% \begin{enumerate}
%   \setcounter{enumi}{\value{pomsetPreParCount}}
% \item \label{par-tick}
%   if $\TICK$ then $\TICK_1$ and $\TICK_2$.
% \end{enumerate}

% Similarly, $\sFORKJOIN{}$ extends $\sFORK{}$ by adding the following.
% % \noindent
% % If $\aPS\SB0 \in \sFORKJOIN{\aPSS}$ then
% % $(\exists\aPS_1\in\aPSS)$
% \begin{enumerate}
%   \setcounter{enumi}{\value{pomsetXForkCount}}
% \item $\TICK_1$.
% \end{enumerate}

\begin{definition}$\phantom{\;}$\par
  % \noindent
  % If $\aPS\SB0\in\sNIL$ then $\aEvs\SB0 = \emptyset$ and $\TICK$.

  \noindent
  If $\aPS\SB0 \in (\aPSS_1\sPAR\aPSS_2)$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPreParCount}}
  \item[\ref{par-E}--\ref{par-kappa2})]
    as for $\sPAR$ in Definition~\ref{tab:pomsets-pre},
  \item \label{par-tick}
    $\TICK$ implies $\TICK_1\land\TICK_2$.
  \end{enumerate}

  \noindent
  If $\aPS\SB0 \in \sTHREAD{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetXThreadCount}}
  \item[\ref{thread-E}--\ref{thread-kappa})]
    as for $\sTHREAD{}$ in Definition~\ref{def:thread},
  \item if $\TICK$ then $\aTr[\aEvs](\Q{})$ implies $\Q{}$.
  \end{enumerate}    

  \noindent
  If $\aPS\SB0 \in \sFORKJOIN{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetXForkCount}}
  \item[\ref{F1x}--\ref{F4x})]
    as for $\sFORK{}$ in Definition~\ref{def:fork},
  \item[{\labeltext[F5]{F5)}{F5}}]
    $\TICK_1$.
  \end{enumerate}    
\end{definition}

\begin{align*}
  \sem{\FORKJOIN{\aGrp}} &= \sFORKJOIN{}\sem{\aGrp}  
\end{align*}

We can then encode coherence as follows.
\begin{enumerate}
  \setcounter{enumi}{\value{pomsetXSemiCount}}
\item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ either $\bEv<\SB0\aEv$ or $a\reorder\labeling_2(\aEv)$.
\end{enumerate}

