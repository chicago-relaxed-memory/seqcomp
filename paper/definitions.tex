\section{Model}
\label{sec:model}

%% Batty suggest example where dependencies are added and also go away, perhaps
%% by store forwarding. Something like:
%% \texttt{(r=x; y=1); (s=y; z=s+r)}

In this section, we present the mathematical preliminaries for the
model (which can be skipped on first reading). We then present the
model incrementally, starting with a model built using
\emph{partially ordered multisets}
(\emph{pomsets})~\cite{GISCHER1988199,Plotkin:1997:TSP:266557.266600},
and then adding preconditions and finally predicate transformers.

In later sections, we will discuss extensions to the logic, and to the
semantics of load, store and thread initialization, in order to model
relaxed memory more faithfully. We stress that these features do
\emph{not} change any of the structures of the language: conditionals,
and parallel and sequential composition are as defined in this section.

\subsection{Preliminaries}
\label{sec:prelim}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$.
\end{itemize}

\emph{Memory references} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory references, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.

We require that
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
  % \item for any set $\aEvs$ there are registers $\uRegs{\aEvs}=\{\uReg{\aEv}\mid\aEv\in\aEvs\}$,
\item expressions include at least registers and values, 
\item expressions do \emph{not} include references: $\aExp[\bExp/\aLoc]=\aExp$.
  % or registers in
  % $\uRegs{\aEvs}$, for any set $\aEvs$.
\end{itemize}

We model the following language.
\begin{align*}
  \amode \BNFDEF& \mRLX
  \BNFSEP \mRA 
  \BNFSEP \mSC
  \\
  \aCmd
  \BNFDEF& \ABORT
  \BNFSEP \SKIP
  \BNFSEP \LET{\aReg}{\aExp}
  % \BNFSEP \PR[\amode]{\aLoc}{\aReg}
  % \BNFSEP \PW[\amode]{\aLoc}{\aExp}
  \BNFSEP \PRREF[\amode]{\cExp}{\aReg}
  \BNFSEP \PWREF[\amode]{\cExp}{\aExp}
  % \BNFSEP \PA{\aLoc}{\aExp} 
  \\[-.5ex]
  \BNFSEP& \FORK{\aGrp}
  \BNFSEP \aCmd_1 \SEMI \aCmd_2
  \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
  \\
  \aGrp 
  \BNFDEF& \NIL
  \BNFSEP\THREAD{\aCmd}
  \BNFSEP\aGrp_1 \PAR \aGrp_2
\end{align*}

\emph{Memory modes}, $\amode$, are {relaxed} ($\mRLX$), {release-acquire}
($\mRA$), and {sequentially consistent} ($\mSC$).  Relaxed mode is the
default; we regularly elide it from examples.  $\mRA$/$\mSC$ accesses are
collectively known as \emph{synchronized accesses}.
 
\emph{Commands}, aka \emph{statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs.
% 
\emph{Thread groups}, $\aGrp$, include commands and $\NIL$, which denotes
inaction. %, or deadlock.
% 
The $\FORK{}$ command spawns a thread group.  % We often drop the words
% $\FORK{}$ and $\THREAD{}$.

The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, $\dEv$, 
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, 
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$.
\end{itemize}
Subsets of $\AllEvents$ are ranged over by $\aEvs$, $\bEvs$, $\cEvs$,
$\dEvs$.

We require that:
\begin{itemize}
\item actions include writes $\DWP{\aLoc}{\aVal}$ and reads $\DRP{\aLoc}{\aVal}$,
\item formulae include equalities $(\aExp{=}\bExp)$ and $(\aLoc{=}\aExp)$,
\item formulae include symbols % for all $\aLoc$,
  % \item formulae include the symbols
  $\Qsc$, $\Qr{\aLoc}$, $\Qw{\aLoc}$, $\Dx{\aLoc}$, $\RW$, % for all $\aLoc$,
  (which are used in \textsection\ref{sec:q}--\ref{sec:arm}),
\item formulae are closed under negation, conjunction, disjunction, and
  substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$, and $[\aForm/\aSym]$
  for each symbol $\aSym$,
\item there is an entailment relation $\vDash$ between formulae,
\item $\vDash$ has the expected semantics for $=$, $\lnot$, $\land$, $\lor$,
  $\limplies$ and substitution.
\end{itemize}


% Action $\DWP{\aLoc}{\aVal}$ models a write of $\aVal$ to $\aLoc$, and
% $\DRP{\aLoc}{\aVal}$ models a read of $\aVal$ from $\aLoc$.
% We use $\DAP{\aLoc}{\aVal}$ to indicate a generic access, which could be
% either a read or a write.

Logical formulae include equations over registers, such as
$(\aReg{=}\bReg{+}1)$.
For use in \textsection\ref{sec:tc1}, we also include equations over memory references, such as $(\aLoc{=}1)$.
% I would like to drop this, an be careful about program vs logical syntax
Formulae are subject to substitutions; % of the form $[\aExp/\aReg]$ and
% $[\aExp/\aLoc]$;
actions are not.
We use expressions as formulae, coercing $\aExp$ to $\aExp{\neq}0$.
Equations have precedence over logical operators; thus
$\aReg{=}\aVal\limplies\bReg{>}\bVal$ is read
$(\aReg{=}\aVal)\limplies(\bReg{>}\bVal)$.  As usual, implication associates to the
right; thus $\aForm\limplies\bForm\limplies\cForm$ is read
$\aForm\limplies(\bForm\limplies\cForm)$.

% \begin{definition}
%   \label{def:independent}
%   We say $\aForm$ is \emph{independent of $\aLoc$} if, for every
%   $\aVal$, $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$; it is
%   \emph{dependent} otherwise.
%   We say $\aForm$ is \emph{location independent} if it is independent of
%   every location.
We say
$\aForm$ \emph{implies} $\bForm$ if $\aForm\vDash\bForm$.
% We say that
We say
$\aForm$ is a \emph{tautology} if $\TRUE\vDash\aForm$.
% We say that
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm\vDash\FALSE$.
% \end{definition}


Throughout \textsection\ref{sec:model}--\ref{sec:arm} we 
additionally require that
\begin{itemize}
\item each register appears at most once in a program.
  % \end{itemize}
  % In \textsection\ref{sec:complications} and following, we
  % require instead that
  % \begin{itemize}
  % \end{itemize}
\end{itemize}
In \textsection\ref{sec:complications}, we drop this restriction, requiring
instead that
\begin{itemize}
\item there are registers
  $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$,
\item registers in $\uRegs{\AllEvents}$ do not appear in programs.
\end{itemize}
% In contexts that make no use of $\uRegs{\AllEvents}$, we make the first
% assumption.

\subsection{Pomsets}

We first consider a fragment of our language that can be modeled using simple
pomsets.  This captures read and write actions which may be reordered,
but as we shall see does\emph{not} capture control or data dependencies.

\begin{definition}
  \label{def:pomsets}
  A \emph{pomset} over $\Act$ is a tuple
  $(\Event, {\le}, \labeling)$ where
  \begin{itemize}
  \item $\Event\subset\AllEvents$ is a set of \emph{events},
  \item
    ${\le} \subseteq (\Event\times\Event)$ is the \emph{causality} partial order, 
  \item
    $\labeling: \Event \fun \Act$ is a \emph{labeling}.
  \end{itemize}
\end{definition}
Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.

We lift terminology from actions to events.  For example, we say that $\aEv$
writes $\aLoc$ if $\labeling(\aEv)$ writes $\aLoc$.  We also drop quantifiers
when clear from context, such as
$(\forall\aEv\in\Event)(\forall\aLoc\in\Loc)$.

\begin{definition}
  \label{def:fulfilled}
  Action $\DWP{\aLoc}{\aVal}$ \emph{matches} $\DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.
  Action $\DWP{\aLoc}{\aVal}$ \emph{blocks} $\DRP{\aLoc}{\bVal}$, for any
  $\aVal$, $\bVal$.
  
  % A pomset $\aPS$ is \emph{closed} if for every $\aEv$ which can be
  % fulfilled, there is a $\bEv\le\aEv$ which fulfills it, and for any $\cEv$
  % which can block $\aEv$, either $\cEv\le\bEv$ or $\aEv\le\cEv$.

  A read event $\aEv$ is \emph{fulfilled} if there is a $\bEv\le\aEv$ which
  matches it and, for any $\cEv$ which can block $\aEv$, either $\cEv\le\bEv$
  or $\aEv\le\cEv$.

  Pomset $\aPS$ is \emph{fulfilled} if every read in $\aPS$ is fulfilled.
\end{definition}

We introduce independency \cite{DBLP:books/ws/95/Mazurkiewicz95} in order to
provide examples with coherence in this subsection.  In
\textsection\ref{sec:q} we show that coherence can be encoded in the logic,
making independency unnecessary.
\begin{definition}
  Actions $\aAct$ and $\bAct$ are \emph{independent}
  (${\aAct\reorder\bAct}$) if either both are reads or they are accesses to
  different locations.  Formally
  \begin{math}
    {\reorder} = \{(\DR{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \}
    \cup\{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}.
  \end{math}
  % \emph{Independency} (${\reorder}\subseteq\Act\times\Act$), is defined:
  \begin{comment}
    % {\reorderSC} &= \emptyset
    % \\
    % {\reorderRLX} &=
    \reorder &=
    \{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}
    \\[-.5ex]&\mkern2mu\cup\mkern2mu
    \{(\DR{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \}
    % \\[-.5ex]&\mkern2mu\cup\mkern2mu
    % \{(\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc \lor \aVal=\bVal\}
    % \\[-.5ex]&\mkern2mu\cup\mkern2mu
    % \{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}
  \end{comment}

  Actions that are not independent are in \emph{conflict}.
\end{definition}
We can now define a model of processes given as sets of pomsets
sufficient to give the semantics for a fragment of our language
without control or data dependencies.
\begin{definition} %$\phantom{\;}$\par
  \label{def:pomset-semantics}

  \noindent
  If $\aPS\in\sNIL$ then $\aEvs = \emptyset$.

  \noindent
  If $\aPS \in (\aPSS_1\sPAR\aPSS_2)$ then  
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
  \item \label{par-E}
    $\aEvs = (\aEvs_1\cup\aEvs_2)$,
  \item \label{par-lambda1}
    if $\aEv\in\aEvs_1$ then $\labeling(\aEv) = \labeling_1(\aEv)$, 
  \item \label{par-lambda2}
    if $\aEv\in\aEvs_2$ then $\labeling(\aEv) = \labeling_2(\aEv)$,
  \item \label{par-le1}
    if $\bEv\le_1\aEv$ then $\bEv\le\aEv$, 
  \item \label{par-le2}
    if $\bEv\le_2\aEv$ then $\bEv\le\aEv$, 
    \newcounter{pomsetParCount}
    \setcounter{pomsetParCount}{\value{enumi}}
  \item \label{par-disjoint}
    $\aEvs_1$ and $\aEvs_2$ are disjoint.
    \newcounter{pomsetParDisjointCount}
    \setcounter{pomsetParDisjointCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS \in (\aAct\sPREFIX\aPSS_2)$ then
  $(\exists\aPS_2\in\aPSS_2)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}
  \item \label{pre-E}
    $\aEvs=(\aEvs_1 \cup \aEvs_2)$,
  \item \label{pre-unique}
    if $\bEv,\aEv\in\aEvs_1$ then $\bEv=\aEv$,
  \item \label{pre-lambda1}
    if $\aEv\in\aEvs_1$ then $\labelingAct(\aEv) = \aAct$,
  \item \label{pre-lambda2}
    if $\aEv\in\aEvs_2$ then $\labelingAct(\aEv) = \labelingAct_2(\aEv)$,
  \item \label{pre-le2}
    if $\bEv\le_2\aEv$ then $\bEv\le\aEv$, 
    % \newcounter{pomsetPrefixCount}
    % \setcounter{pomsetPrefixCount}{\value{enumi}}
  \item
    \label{pre-reorder}
    if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ then either $\bEv\leq\aEv$ or $a\reorder\labeling_2(\aEv)$.
    \newcounter{pomsetPrefixOrderCount}
    \setcounter{pomsetPrefixOrderCount}{\value{enumi}}
  \end{enumerate}
\end{definition}
\begin{definition}
  \noindent
  For a language fragment, the semantics is:
  \begin{align*}
    \sem{\PW[\amode]{\aLoc}{\aVal}\SEMI \aCmd} &= \textstyle\DWP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
    &
    \sem{\SKIP} &= \sem{\NIL} = \sNIL 
    \\
    \sem{\PR[\amode]{\aLoc}{\aReg}\SEMI \aCmd} &= \textstyle\bigcup_{\aVal}\DRP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
    &
    \sem{\aGrp_1 \PAR \aGrp_2} &= \sem{\aGrp_1}\sPAR\sem{\aGrp_2}
    % \\
    % \sem{\PA{\aLoc}{\aVal}\SEMI \aCmd} &= \textstyle\DRP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
  \end{align*}
  % Let $\aPSS$ range over sets of pomsets.
\end{definition}

In this semantics, both $\SKIP$ and $\NIL$ map to the empty pomset.  Parallel
composition is disjoint union, inheriting labeling and order from the two
side.  Prefixing may add a new action (on the left) to an existing pomset
(on the right), inheriting labeling and order from the right.  

It is worth noting that if ${\reorder}$ is taken to be the empty relation,
then fulfilled pomsets of \refdef{def:pomsets} correspond to sequentially
consistent executions \cite{Lamport:1979:MMC:1311099.1311750} up to mumbling
\cite{DBLP:journals/iandc/Brookes96}.

\begin{example}
  \label{ex:mumble1}
  Mumbling is allowed, since there is no requirement that left and right be
  disjoint in the definition of prefixing.  Both of the pomsets below are
  allowed.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1} \SEMI \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{\DW{x}{1}}{}
          \event{a2}{\DW{x}{1}}{right=of a1}
          \wk{a1}{a2}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{1} \SEMI \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{\DW{x}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  In the left pomset, the order between the events is enforced by clause
  \ref{pre-reorder}, since the actions are in conflict.
\end{example}

\begin{example}
  \label{ex:pub1}
  Although this model enforces coherence, it is very weak.  For example, it
  makes no distinction between synchronizing and relaxed access, thus
  allowing:
  \begin{gather*}
    x\GETS0\SEMI %y\GETS0\SEMI
    x\GETS 1\SEMI y^\mRA\GETS1 \PAR r\GETS y^\mRA\SEMI s\GETS x
    \\[-.4ex]
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wx0}{\DW{x}{0}}{}
        \event{wx1}{\DW{x}{1}}{right=of wx0}
        \raevent{wy1}{\DW[\mRA]{y}{1}}{right=of wx1}
        \raevent{ry1}{\DR[\mRA]{y}{1}}{right=2.5em of wy1}
        \event{rx0}{\DR{x}{0}}{right=of ry1}
        % \sync{wx1}{wy1}
        % \sync{ry1}{rx0}
        \rf{wy1}{ry1}
        \wk[in=-15,out=-165]{rx0}{wx1}
        \wk{wx0}{wx1}
        \rf[out=15,in=165]{wx0}{rx0}
      \end{tikzinline}}
  \end{gather*}  
  We show how to enforce the intended semantics, where $\DWP[\mRA]{y}{1}$
  \emph{publishes} $\DWP{x}{1}$ in \refex{ex:pub2}.
\end{example}
In diagrams, we use different shapes and colors for arrows and events.  These
are included only to help the reader understand why order is included.  We
adopt the following conventions (dependency and synchronization order will
appear later in the paper):
\begin{itemize}  
\item relaxed accesses are blue, with a single border,
\item synchronized accesses are red, with a double border,
% \item sequentially-consistent accesses are orange, with a bold double
%   border,
\item \makebox{$\aEv\xrf\bEv$} arises from fulfillment, where $\aEv$ \emph{matches} $\bEv$,
\item \makebox{$\aEv\xwk\bEv$} arises either from fulfillment, where $\aEv$
  \emph{blocks} $\bEv$, or from prefixing, where $\aEv$ was prefixed before
  $\bEv$ and their actions \emph{conflict},
\item \makebox{$\aEv\xpo\bEv$} arises from control/data/address \emph{dependency},% (eg, control),
\item \makebox{$\aEv\xsync\bEv$} arises from \emph{synchronized access}.
\end{itemize}

\begin{definition}
  $\aPSS_1$ \emph{refines} $\aPSS_2$ if $\aPSS_1\subseteq\aPSS_2$.
\end{definition}

\begin{example}
  \refex{ex:mumble1} shows that $\sem{\PW{x}{1}}$ refines $\sem{\PW{x}{1}\SEMI\PW{x}{1}}$.
\end{example}

\subsection{Pomsets with Preconditions}
\label{sec:pomsets-pre}

The previous section modeled a language fragment without conditionals (and hence no
control dependencies) or expressions (and hence no data dependencies). We now
address this, by adopting a \emph{pomsets with preconditions} model
similar to~\cite{DBLP:journals/pacmpl/JagadeesanJR20}.
% restricting attention to relaxed access.
We discuss the differences in \S\ref{sec:discussion}.

\begin{definition}
  A \emph{pomset with preconditions} is
  a pomset (\refdef{def:pomsets}) together with $\labelingForm:\aEvs\fun\Formulae$.
\end{definition}

\begin{definition}
  A pomset with preconditions is \emph{top level} if it is fulfilled (\refdef{def:fulfilled}) and
  every precondition is a tautology.
\end{definition}

% \begin{definition}
%   Let $\aSub$ be a substitution.  If $\aPS\in(\aPSS\aSub)$ then
%   $(\exists\aPS\in\aPSS)$ $\Event = \Event'$, ${\le} = {\le'}$,
%   $\labelingAct = \labelingAct'$, and
%   $\labelingForm(\aEv) = \labelingForm'(\aEv)\aSub$.
% \end{definition}

% Definition \ref{def:pomsets-pre}, describes operators 
% sufficient to give the semantics to a larger fragment of our language:
We can now define a model of processes given as sets of pomsets with preconditions
sufficient to give the semantics for a fragment of our language
where every use of sequential composition is either
$(\aLoc\GETS\aExp\SEMI \aCmd)$ or
$(\aReg\GETS\aLoc\SEMI \aCmd)$.
\begin{definition}%$\phantom{\;}$\par
  \label{def:pomsets-pre}
  
  \noindent
  If $\aPS\in\sNIL$ then $\aEvs = \emptyset$.

  \noindent
  If $\aPS \in (\aPSS_1\sPAR\aPSS_2)$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetParDisjointCount}}
  \item[\ref{par-E}--\ref{par-disjoint})]
    as for $\sPAR$ in \refdef{def:pomset-semantics},
  \item \label{par-kappa1}
    if $\aEv\in\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$,
  \item \label{par-kappa2}
    if $\aEv\in\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$.
    \newcounter{pomsetPreParCount}
    \setcounter{pomsetPreParCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS \in \sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[\ref{par-E}--\ref{par-le2})] 
    as for $\sPAR$  in \refdef{def:pomset-semantics} (ignoring disjointness),
  \item \label{if-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\aForm\land\labelingForm_1(\aEv)$,
  \item \label{if-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\neg\aForm\land\labelingForm_2(\aEv)$, 
  \item \label{if-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then\\
    $\labelingForm(\aEv)$ implies $(\aForm\limplies\labelingForm_1(\aEv))\land(\neg\aForm\limplies\labelingForm_2(\aEv))$.
    % $\labelingForm(\aEv)$ implies $(\aForm\land\labelingForm_1(\aEv))\lor(\neg\aForm\land\labelingForm_2(\aEv))$.
    \newcounter{pomsetPreIfCount}
    \setcounter{pomsetPreIfCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS \in \sSTOREPRE{\aLoc}{\aExp}{\aPSS_2}$ then
  $(\exists\aPS_2\in\aPSS_2)$
  $(\exists\aVal\in\Val)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPrefixOrderCount}}
  \item[\ref{pre-E}--\ref{pre-reorder})]
    as for $\DWP{\aLoc}{\aVal}\sPREFIX\aPSS_2$ in \refdef{def:pomset-semantics}, % (ignoring \thepomsetPrefixOrderCount),
  \item \label{storepre-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\aExp{=}\aVal$,
  \item \label{storepre-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$,
  \item \label{storepre-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm(\aEv)$ implies $\aExp{=}\aVal \lor \labelingForm_2(\aEv)$.
    % \item if $\aEv\in\aEvs_2$ then either
    %   $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$ or\\
    %   $\aEv\in\aEvs_1$ and $\labelingForm(\aEv)$ implies $(\aExp{=}\aVal)\lor \labelingForm_2(\aEv)$.
  \end{enumerate}

  \noindent
  If $\aPS \in \sLOADPRE{\aReg}{\aLoc}{\aPSS_2}$ then
  $(\exists\aPS_2\in\aPSS_2)$
  $(\exists\aVal\in\Val)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPrefixOrderCount}}
  \item[\ref{pre-E}--\ref{pre-reorder})]
    as for $\DRP{\aLoc}{\aVal}\sPREFIX\aPSS_2$ in \refdef{def:pomset-semantics}, % (ignoring \thepomsetPrefixOrderCount),
  \item \label{loadpre-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then either \\
    $\labelingForm(\aEv)$ implies $\aReg{=}\aVal\limplies\labelingForm_2(\aEv)$ and $(\exists\bEv\in\aEvs_1)\;\bEv<\aEv$, or \\
    $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$.
    % \\ \mbox{$\quad$} for some $\bEv\in\aEvs_1$.
  \end{enumerate}  
\end{definition}
\begin{definition}
  \noindent
  For a language fragment, the semantics is:
  \begin{gather*}
    \sem{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} = \sIF{\aExp{\neq}0}\sTHEN\sem{\aCmd_1}\sELSE\sem{\aCmd_2}\sFI
    \\
    \begin{aligned}
      \sem{\PW{\aLoc}{\aExp}\SEMI \aCmd} &=
      \sSTOREPRE{\aLoc}{\aExp}{\sem{\aCmd}}
      &
      \sem{\SKIP} &= \sem{\NIL} = \sNIL 
      \\
      \sem{\PR{\aLoc}{\aReg}\SEMI \aCmd} &=
      \sLOADPRE{\aReg}{\aLoc}{\sem{\aCmd}}
      &
      \makebox[3.5em][r]{$\sem{\aGrp_1 \PAR \aGrp_2}$} &= \sem{\aGrp_1}\sPAR\sem{\aGrp_2}
    \end{aligned}
  \end{gather*}
\end{definition}
%% Following our convention for subscripts, in the final clause of
%% $\sLOADPRE{}{}{}$, $<$ refers to the order of $\aPS$.  Also note that
%% $\sLOADPRE{}{}{}$ does not constrain $\labelingForm(\aEv)$ if
%% $\aEv\in\aEvs_1$.

\begin{example}
  A simple example of a data dependency
  is a pomset $\aPS\in\sem{r\GETS x\SEMI y\GETS r}$,
  for which there must be an $\aVal\in\Val$ and $\aPS'\in \sem{y\GETS r}$
  such as:
    \begin{gather*}
      y\GETS r
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{r{=}1\mid\DW{y}{1}}{}
      \end{tikzinline}}
    \end{gather*}
  If $\aVal$ is chosen badly, we have a pomset with a precondition
  that cannot be part of a top-level pomset such as:
    \begin{gather*}
      r\GETS x\SEMI y\GETS r
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx0}{\DR{x}{0}}{}
        \event{wy1}{r{=}0\limplies r{=}1 \mid \DW{y}{1}}{right=of rx0}
        \po{rx0}{wy1}
      \end{tikzinline}}
    \end{gather*}
  But if $\aVal$ is $1$ then we have two cases, the independent case, which again cannot
  be part of a top-level pomset:
    \begin{gather*}
      r\GETS x\SEMI y\GETS r
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx1}{\DR{x}{1}}{}
        \event{wy1}{r{=}1 \mid \DW{y}{1}}{right=of rx1}
      \end{tikzinline}}
    \end{gather*}
  or the dependent case:
    \begin{gather*}
      r\GETS x\SEMI y\GETS r
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx1}{\DR{x}{1}}{}
        \event{wy1}{r{=}1\limplies r{=}1 \mid \DW{y}{1}}{right=of rx1}
        \po{rx1}{wy1}
      \end{tikzinline}}
    \end{gather*}
  Since $r{=}1\limplies r{=}1$ is a tautology, this can be part of
  a top-level pomset.
\end{example}

\begin{example}
  Control dependencies are similar, for example
  for any $\aPS\in\sem{r\GETS x\SEMI \IF r \THEN y\GETS 1 \FI}$,
  there must be an $\aVal\in\Val$ and $\aPS'\in \sem{\IF r \THEN y\GETS 1 \FI}$
  such as:
    \begin{gather*}
      \IF r \THEN y\GETS 1 \FI
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{r{\ne}0\mid\DW{y}{1}}{}
      \end{tikzinline}}
    \end{gather*}
  The rest of the reasoning is the same as for a data dependency.
\end{example}

\begin{example}
  A simple example of an independency
  is a pomset $\aPS\in\sem{r\GETS x\SEMI y\GETS 1}$,
  for which there must be an $\aVal\in\Val$ and $\aPS'\in \sem{y\GETS r}$
  such as:
    \begin{gather*}
      y\GETS 1
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{1{=}1\mid\DW{y}{1}}{}
      \end{tikzinline}}
    \end{gather*}
  In this case it doesn't matter what $\aVal$ is, for example:
    \begin{gather*}
      r\GETS x\SEMI y\GETS 1
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx0}{\DR{x}{0}}{}
        \event{wy1}{1{=}1 \mid \DW{y}{1}}{right=of rx0}
      \end{tikzinline}}
    \end{gather*}
  % Since $1{=}1$ is a tautology, this can be part of
  % a top-level pomset.
\end{example}

\begin{example}
  Consider $\aPS\in\sem{\IF {r{=}1} \THEN y\GETS r \ELSE y\GETS 1\FI}$, so
  there must be $\aPS_1\in\sem{y\GETS r}$,
  and $\aPS_2\in\sem{y\GETS 1}$, such as:
  \begin{align*}
    \begin{gathered}
      y \GETS r
      \\
      \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
          \event{wy1}{r{=}1 \mid \DW{y}{1}}{}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      y \GETS 1
      \\
      \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
          \event{wy1}{1{=}1 \mid \DW{y}{1}}{}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  Since there is no requirement for disjointness in the semantics of conditionals,
  we can consider the case where the event \emph{coalesces} from the two pomsets,
  in which case:
    \begin{gather*}
      \IF{r{=}1} \THEN y\GETS r \ELSE y\GETS 1\FI
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
          \event{wy1}{(r{=}1 \limplies r{=}1) \land (r{\ne}1 \limplies 1{=}1) \mid \DW{y}{1}}{}
      \end{tikzinline}}
    \end{gather*}
    Here, the precondition on $(\DW{y}{1})$ is a tautology, and so is
    independent of $r$.
    %We refer to event sharing as \emph{coalescing} or \emph{merging}.
\end{example}

\subsection{Pomsets with Predicate Transformers}

Having reviewed the work we are building on, we now turn to
the contribution of this paper, which is a model of \emph{pomsets with predicate transformers},
which provide a natural model of sequential composition.

Our model is based on \emph{predicate transformers},
which are functions on formulae which preserve logical structure.
Note that substitutions ($\aTr{}{\psi}=\psi[\aExp/\aReg]$) and implications on the right
($\aTr{}{\psi}=\phi\limplies\psi$) are predicate transformers.

\begin{definition}
  A \emph{predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{itemize}
  \item $\aTr{}{\FALSE}$ is $\FALSE$,    
  \item $\aTr{}{\bForm_1\land\bForm_2}$ is $\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$,    
  \item $\aTr{}{\bForm_1\lor\bForm_2}$ is $\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$, 
  \item if $\aForm$ implies $\bForm$, then $\aTr{}{\aForm}$ implies $\aTr{}{\bForm}$.
  \end{itemize}
\end{definition}

As discussed in \S\ref{sec:intro}, predicate transformers suffice for sequentially consistent
models, but not relaxed models in which dependency calculation is crucial.
For dependency calculation, we use \emph{family} of predicate transformers,
indexed by sets of events. We use $\aTr{\bEvs}{}$ as the predicate transformer
applied to any event $\aEv$ where if $\bEv\in\bEvs$ then $\bEv<\aEv$.

\begin{definition}
  A \emph{family of predicate transformers} for $\aEvs$ consists of a
  predicate transformer $\aTr{\bEvs}{}$ for each $\bEvs\subseteq\AllEvents$,
  such that if $\cEvs \cap \aEvs \subseteq \bEvs$ then $\aTr{\cEvs}{\bForm}$
  implies $\aTr{\bEvs}{\bForm}$.
\end{definition}

%% Note that in a family of predicate transformers for $\aEvs$, transformers for
%% smaller subsets of $\aEvs$ are stronger.

\begin{definition}
  A \emph{pomset with predicate transformers} is a pomset with preconditions (\refdef{def:pomsets-pre}),
  together with a family of predicate transformers for $\aEvs$.
\end{definition}

% \begin{definition}
%   For pomset $\aPS$ and $\aEv\in\aEvs$, let
%   $\downclose[0]{\aEv} = \{ \bEv\in\aEvs \mid \bEv < \aEv \}$.
% \end{definition}

We can covert back and forth between pomsets with preconditions
and with predicate transformers. In one direction, $\sTHREAD{}$
drops predicate transformers, and in the other, $\sFORK{}$ adopts
the identity transformer.

\begin{definition}
  \label{def:pomsets-group}
  \noindent
  If $\aPS \in \sTHREAD{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}
  \item[{\labeltext[T1]{T1)}{T1}}] % \label{thread-E}
    $\aEvs=\aEvs_1$,
  \item[{\labeltext[T2]{T2)}{T2}}] % \label{thread-lambda}
    $\labelingAct(\aEv) = \labelingAct_1(\aEv)$,
  \item[{\labeltext[T3]{T3)}{T3}}] % \label{thread-kappa}
    $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$.
    \newcounter{pomsetXThreadCount}
    \setcounter{pomsetXThreadCount}{\value{enumi}}
  \end{enumerate}  

  \noindent
  If $\aPS \in \sFORK{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}
  \item[{\labeltext[F1]{F1)}{F1}}] %\label{fork-E}
    $\aEvs=\aEvs_1$,
  \item[{\labeltext[F2]{F2)}{F2}}] % \label{fork-lambda}
    $\labelingAct(\aEv) = \labelingAct_1(\aEv)$,
  \item[{\labeltext[F3]{F3)}{F3}}] % \label{fork-kappa} 
    $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$, 
  \item[{\labeltext[F4]{F4)}{F4}}] % \label{fork-tau} 
    $\aTr{\bEvs}{\bForm}$ implies $\bForm$.
    \newcounter{pomsetXForkCount}
    \setcounter{pomsetXForkCount}{\value{enumi}}
  \end{enumerate}  
\end{definition}

We model thread groups as sets of pomsets with preconditions,
as in \S\ref{sec:pomsets-pre}.

\begin{definition}
  \noindent
  Adopting $\sNIL$ and $\sPAR$ from \refdef{def:pomsets-pre},
  the semantics of thread groups is:
  \begin{align*}
    \sem{\THREAD{\aCmd}} &= \sTHREAD{}\sem{\aCmd}
    &
    \sem{\aGrp_1 \PAR \aGrp_2} &= \sem{\aGrp_1}\sPAR\sem{\aGrp_2}      
    &
    \sem{\NIL} &= \sNIL     
  \end{align*}
  % , and
  % $\sTHREAD{}$ is as follows.
\end{definition}

We model commands as sets of pomsets with predicate transformers,
by combining \S\ref{sec:pomsets-pre} with a weakest precondition
semantics.

\begin{definition}
  \label{def:pomsets-trans}

  \noindent
  If $\aPS\in\sABORT$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm}$ implies $\FALSE$.
  \end{itemize}

  \noindent
  If $\aPS\in\sSKIP$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm}$ implies $\bForm$.
  \end{itemize}

  \noindent
  If $\aPS\in\sLET{\aReg}{\aExp}$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm}$ implies $\bForm[\aExp/\aReg]$.
  \end{itemize}

  \noindent
  If $\aPS \in \sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPreIfCount}}
  \item[1--\ref{if-kappa12})] as for $\sIF{}$ in \refdef{def:pomsets-pre},
  \item \label{if-tau}
    $\aTr{\bEvs}{\bForm}$ implies
    $(\aForm\limplies\aTr[1]{\bEvs}{\bForm})\land(\neg\aForm\limplies\aTr[2]{\bEvs}{\bForm})$.
    % $(\aForm\land\aTr[1]{\bEvs%\cap\aEvs_1
    % }{\bForm})\lor(\neg\aForm\land\aTr[2]{\bEvs%\cap\aEvs_2
    % }{\bForm})$.
  \end{enumerate}

  \noindent
  If $\aPS \in (\aPSS_1\sSEMI\aPSS_2)$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  % let $\labelingForm'_2(\aEv)=\aTr[1]{{\downclose[0]{\aEv}}}{\labelingForm_2(\aEv)}$  
  % let $\labelingForm'_2(\aEv)=\aTr[1]{\{ \bEv \mid \bEv < \aEv \}}{\labelingForm_2(\aEv})$  
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[1--\ref{par-le2})]
    as for $\sPAR$  in \refdef{def:pomsets} (ignoring disjointness),
  \item \label{seq-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$,
  \item \label{seq-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm'_2(\aEv)$,
  \item \label{seq-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)\lor\labelingForm'_2(\aEv)$,
    \\ where $\labelingForm'_2(\aEv)=\aTr[1]{\cEvs%\cap\aEvs_1
    }{\labelingForm_2(\aEv})$, where $\cEvs=\{ \cEv \mid \cEv < \aEv \}$,
  \item \label{seq-tau}
    $\aTr{\bEvs}{\bForm}$ implies $\aTr[1]{\bEvs}{\aTr[2]{\bEvs}{\bForm}}$.
    \newcounter{pomsetXSemiCount}
    \setcounter{pomsetXSemiCount}{\value{enumi}}
    % \item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ either $\bEv<\aEv$ or $a\reorder\labeling_2(\aEv)$.
  \end{enumerate}
  % where we define $\labelingForm'_2(\aEv)$ to be $\aTr[1]{\{ \bEv \mid \bEv < \aEv \}}{\labelingForm_2(\aEv})$.

  \noindent
  If $\aPS \in \sSTORE[\amode]{\aLoc}{\aExp}$ then
  $(\exists\aVal\in\Val)$
  % $(\forall\bEvs\neq\emptyset)$
  \begin{enumerate}
  \item[{\labeltext[S1]{S1)}{S1}}]
    if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item[{\labeltext[S2]{S2)}{S2}}]
    $\labelingAct(\aEv) = \DW{\aLoc}{\aVal}$,
  \item[{\labeltext[S3]{S3)}{S3}}]
    $\labelingForm(\aEv)$ implies $\aExp{=}\aVal$,
  \item[{\labeltext[S4]{S4)}{S4}}]
    $\aTr{\bEvs}{\bForm}$ implies $\bForm\noSUB{[\aExp/\aLoc]}$, % \land (\Q{}\limplies\aExp{=}\aVal)$,
  \item[{\labeltext[S5]{S5)}{S5}}]
    $\aTr{\cEvs}{\bForm}$ implies $\bForm\noSUB{[\aExp/\aLoc]}$, % \land % \lnot\Q{}$.
    \\ where $\bEvs\cap\aEvs\neq\emptyset$ and $\cEvs\cap\aEvs=\emptyset$.
    % \item %if $\bEvs\neq\emptyset$ then
    %   $\aTr{\bEvs}{\bForm}$ implies $(\aExp{=}\aVal) \land \bForm[\aExp/\aLoc]$, if $\bEvs\neq\emptyset$,
    %   \newcounter{pomsetXStoreCount}
    %   \setcounter{pomsetXStoreCount}{\value{enumi}}
  \end{enumerate}

  % \noindent
  % If $\aPS \in \sLOAD[\amode]{\aReg}{\aLoc}$ then
  % $(\exists\aVal\in\Val)$
  % $(\forall\bEvs\neq\emptyset)$
  % \begin{enumerate}
  % \item[{\labeltext[L1]{L1)}{L1}}] 
  %   if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  % \item[{\labeltext[L2]{L2)}{L2}}]
  %   $\labelingAct(\aEv) = \DRP{\aLoc}{\aVal}$,
  % \item[{\labeltext[L3]{L3)}{L3}}]
  %   $\labelingForm(\aEv)$ implies $\TRUE$,
  % \item[{\labeltext[L4]{L4)}{L4}}]
  %   %   if $\bEvs\neq\emptyset$ then
  %   $\aTr{\bEvs}{\bForm}$ implies %$\phantom{(\aLoc{=}\aReg\lor{}}
  %   $\aVal{=}\aReg\limplies\bForm$, 
  % \item[{\labeltext[L5]{L5)}{L5}}]
  %   %   if $\bEvs=\emptyset$ then
  %   $\aTr{\emptyset}{\bForm}\;$ implies $((\aLoc{=}\aReg\lor\aVal{=}\aReg)\limplies\bForm) \land \lnot\Q{}$.
  % \item[{\labeltext[L6]{L6)}{L6}}]
  %   if $\aEvs=\emptyset$ then
  %   $\aTr{\emptyset}{\bForm}\;$ implies $\bForm \land \lnot\Q{}$.
  % \end{enumerate}

  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}{\aLoc}$ then %either $\aEvs\neq\emptyset$ and
  $(\exists\aVal\in\Val)$
  % $(\forall\bEvs{\neq}\emptyset)$
  \begin{enumerate}
  \item[{\labeltext[L1]{L1)}{L1}}] 
    if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item[{\labeltext[L2]{L2)}{L2}}]
    $\labelingAct(\aEv) = \DR{\aLoc}{\aVal}$,
  \item[{\labeltext[L3]{L3)}{L3}}]
    $\labelingForm(\aEv)$ implies $\TRUE$,
  \item[{\labeltext[L4]{L4)}{L4}}]
    $\aTr{\bEvs}{\bForm}$ implies $\aVal{=}\aReg\limplies\bForm$, 
  \item[{\labeltext[L5]{L5)}{L5}}]
    %$\aTr{\cEvs}{\bForm}$ implies $(\aVal{=}\aReg\lor\aLoc{=}\aReg)\limplies\bForm$, % \land \lnot\Q{}$,
    $\aTr{\cEvs}{\bForm}$ implies $\bForm$, % \land \lnot\Q{}$,
    \\ where $\bEvs\cap\aEvs\neq\emptyset$ and $\cEvs\cap\aEvs=\emptyset$,
  \end{enumerate}
  % or
  % $\aEvs=\emptyset$ and 
  % \begin{enumerate}
  % \item[{\labeltext[L6]{L6)}{L6}}] 
  %   $\aTr{\dEvs}{\bForm}\;$ implies $\bForm$. % \land \lnot\Q{}$.
  % \end{enumerate}
\end{definition}
\begin{definition}
  \noindent
  The semantics of commands is:
  \begin{scope}
    \allowdisplaybreaks
    \begin{gather*}
      \sem{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} = \sIF{\aExp{\neq}0}\sTHEN\sem{\aCmd_1}\sELSE\sem{\aCmd_2}\sFI
      \\
      \begin{aligned}
        \sem{\PW[\amode]{\aLoc}{\aExp}} &= \sSTORE[\amode]{\aLoc}{\aExp}
        &
        \makebox[0em][r]{$\sem{\ABORT}$} &= \sABORT 
        \\
        \sem{\PR[\amode]{\aLoc}{\aReg}} &= \sLOAD[\amode]{\aReg}{\aLoc}
        &
        \sem{\SKIP} &= \sSKIP 
        \\
        \sem{\LET{\aReg}{\aExp}} &= \sLET{\aReg}{\aExp}
        &
        \sem{\FORK{\aGrp}} &= \sFORK{}\sem{\aGrp}      
        \\
        \sem{\aCmd_1 \SEMI \aCmd_2} &= \sem{\aCmd_1}\sSEMI\sem{\aCmd_2}
      \end{aligned}
    \end{gather*}
  \end{scope}
\end{definition}

Most of these definitions are straightforward adaptations of
\S\ref{sec:pomsets-pre}, but the treatment of sequential composition
is new.  This uses the usual rule for composition of predicate
transformers (but preserving the indexing set). For the pomset, we
take the union of their events, preserving actions, but crucially in
cases~\ref{seq-kappa2} and~\ref{seq-kappa12} we apply a predicate
transformer $\aTr[1]{\cEvs}{}$ from the LHS to a precondition
$\labelingForm_2(\aEv)$ from the RHS to build the precondition
$\labelingForm'_2(\aEv)$.  The indexing set $\cEvs$ for the predicate
transformer is $\{ \cEv\mid \cEv<\aEv \}$, so can depend on the causal
order.

%% In the predicate transformers for store and load, \ref{S4} and \ref{L4}
%% denote the \emph{dependent case}, whereas \ref{S5} and \ref{L5}
%% denote the \emph{independent case}.  For stores, the dependent and
%% independent cases are the same; this will change in the next section, where
%% we introduce quiescence.  In the dependent case for load, we can assume that
%% $\aReg$ is the value $\aVal$, which has appears in the read action, when
%% proving $\bForm$.  In the independent case for load, we can only make the
%% weaker assumption that either $\aReg$ is $\aVal$ or it is value defined by
%% preceding code for $\aLoc$.  That is, we do not know whether subsequent code
%% sees the value $\aVal$, or the value of some preceding write of $\aLoc$.


% Recall that $\uRegs{\bEvs}=\{\uReg{\bEv}\mid\bEv\in\bEvs\}$.



% [Note that we could change the premise of $\aTr{\emptyset}{}$ in $\sLOAD{}{}$
% from $(\aVal{=}\aReg\lor\aLoc{=}\aReg)$ to $(\aLoc{=}\aReg)$. The
% requirements of a family of predicate transforms effectively adds the
% additional requirement.]


% \aCmd if P is top-level and quiescent then predicate transformer may be wp(\aCmd,phi).
% Only thing is we are substituting v/r, rather than x/r.


% \aCmd any substitution/valuation sigma giving values for register, can find a
% pomset P such that when you apply the substitution to all the preconditions
% are tautologies and if the substitution validates the wp, then the
% substitution validates the $tau_E$

% substitution validates the wp: wp(\aCmd,phi)sigma is a tautology





\begin{comment} Consider the following executions.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{1{=}1\mid\DW{x}{1}}{}
          \xform{x1d}{\bForm[1/x]}{right=of a1}
          \xform{x1i}{\bForm[1/x]}{below=of x1d}
          \xo{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{2{=}1\mid\DW{x}{1}}{}
          \xform{x1d}{\bForm[2/x]}{right=of a1}
          \xform{x1i}{\bForm[2/x]}{below=of x1d}
          \xo{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  % Simplifying:
  % \begin{align*}
  %   \begin{gathered}
  %   %     \PW{x}{1}
  %   %     \\
  %     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %       \event{a1}{\DW{x}{1}}{}
  %       \xform{x1d}{\bForm[1/x]}{right=of a1}
  %       \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %       \xo{a1}{x1d}
  %     \end{tikzinline}}
  %   \end{gathered}
  %   &&
  %   \begin{gathered}
  %   %     \PW{x}{2}
  %   %     \\
  %     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %       \event{a1}{\FALSE\mid\DW{x}{1}}{}
  %       \xform{x1d}{\FALSE}{right=of a1}
  %       \xform{x1i}{\bForm[2/x]}{right=of x1d}
  %       \xo{a1}{x1d}
  %     \end{tikzinline}}
  %   \end{gathered}
  % \end{align*}
  Merging the actions, we have:
  % \begin{gather*}
  %   \PW{x}{1}\SEMI \PW{x}{2}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
  %     \xform{x1d}{(\bForm[1/x])[2/x]}{below=of a1}
  %     \xform{x1i}{(\bForm[1/x])[2/x]}{below=of x1d}
  %     \xo{a1}{x1d}
  %   \end{tikzinline}}
  % \end{gather*}
  % which simplifies to
  % \begin{gather*}
  %   %   \PW{x}{1}\SEMI \PW{x}{2}
  %   %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{a1}{\DW{x}{1}}{}
  %     \xform{x1d}{\bForm[1/x] }{right=of a1}
  %     \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %     \xo{a1}{x1d}
  %   \end{tikzinline}}
  % \end{gather*}
  % which simplifies to
  \begin{gather*}
    \PW{x}{1}\SEMI \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
        \xform{x1d}{(\bForm[2/x])[1/x]}{right=of a1}
        \xform{x1i}{(\bForm[2/x])[1/x]}{right=of x1d}
        \xo{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
  which simplifies to
  \begin{gather*}
    % \PW{x}{1}\SEMI \PW{x}{2}
    % \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{1}}{}
        \xform{x1d}{\bForm[2/x]}{right=of a1}
        \xform{x1i}{\bForm[2/x]}{right=of x1d}
        \xo{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
  % \end{example}
  % \begin{example} Merging right.
  %   \begin{align*}
  %     \begin{gathered}
  %       \PW{x}{1}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{1{=}2\mid\DW{x}{1}}{}
  %         \xform{x1d}{\bForm[1/x]}{right=of a1}
  %         \xform{x1i}{\bForm[1/x]}{below=of x1d}
  %         \xo{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %     &&
  %     \begin{gathered}
  %       \PW{x}{2}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{2{=}2\mid\DW{x}{1}}{}
  %         \xform{x1d}{\bForm[2/x]}{right=of a1}
  %         \xform{x1i}{\bForm[2/x]}{below=of x1d}
  %         \xo{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %   \end{align*}
  %   Simplifying:
  %   \begin{align*}
  %     \begin{gathered}
  %       \PW{x}{1}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{\FALSE\mid\DW{x}{2}}{}
  %         \xform{x1d}{\FALSE}{right=of a1}
  %         \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %         \xo{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %     &&
  %     \begin{gathered}
  %       \PW{x}{2}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{\DW{x}{2}}{}
  %         \xform{x1d}{\bForm[2/x]}{right=of a1}
  %         \xform{x1i}{\bForm[2/x]}{right=of x1d}
  %         \xo{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %   \end{align*}
  %   Merging the actions, we have:
  The programs are also capable of writing 2.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{1{=}2\mid\DW{x}{2}}{}
          \xform{x1d}{\bForm[1/x]}{right=of a1}
          \xform{x1i}{\bForm[1/x]}{below=of x1d}
          \xo{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{2{=}2\mid\DW{x}{2}}{}
          \xform{x1d}{\bForm[2/x]}{right=of a1}
          \xform{x1i}{\bForm[2/x]}{below=of x1d}
          \xo{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  Merging right.
  \begin{gather*}
    % \PW{x}{1}\SEMI \PW{x}{2}
    % \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{2}}{}
        \xform{x1d}{\bForm[2/x]}{right=of a1}
        \xform{x1i}{\bForm[2/x]}{right=of x1d}
        \xo{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
\end{comment}

\begin{comment}
  Separate actions:
  \begin{align*}
    \begin{gathered}
      \PW{x}{1} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[1/x]}{}
          \xform{xi}{\bForm[1/x]}{below=of xd}
          \event{a1}{1{=}1\mid\DW{x}{1}}{left=of xd}
          \xo{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[2/x]}{}
          \xform{xi}{\bForm[2/x]}{below=of xd}
          \event{a2}{2{=}2\mid\DW{x}{2}}{left=of xd}      
          \xo{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Simplifying:
  \begin{align*}
    \begin{gathered}
      % \PW{x}{1} 
      % \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[1/x]}{}
          \xform{xi}{\bForm[1/x]}{right=of xd}
          \event{a1}{\DW{x}{1}}{left=of xd}
          \xo{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      % \PW{x}{2}
      % \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[2/x]}{}
          \xform{xi}{\bForm[2/x]}{right=of xd}
          \event{a2}{\DW{x}{2}}{left=of xd}      
          \xo{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together unordered:
  \begin{gather*}
    \PW{x}{1}\SEMI \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdi}{\bForm[2/x]}{}
        \xform{xdd}{\bForm[2/x]}{right=of xdi}
        \xform{xid}{\bForm[2/x]}{right=of xdd}
        \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
        \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
        \xform{xii}{\bForm[2/x]}{right=of xid}
        \xo{a1}{xdi}
        \xo{a2}{xid}
        \xo{a1}{xdd}
        \xo{a2}{xdd}
      \end{tikzinline}}
  \end{gather*}
  Adding order does nothing since the preconditions are tautologies.
  % \begin{gather*}
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \xform{xdi}{\bForm[1/x]}{}
  %     \xform{xdd}{\bForm[1/x]}{right=of xdi}
  %     \xform{xid}{\bForm[1/x]}{right=of xdd}
  %     \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
  %     \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
  %     \xform{xii}{\bForm[1/x]}{right=of xid}
  %     \xo{a1}{xdi}
  %     \xo{a2}{xid}
  %     \xo{a1}{xdd}
  %     \xo{a2}{xdd}
  %     \po{a1}{a2}
  %   \end{tikzinline}}
  % \end{gather*}
\end{comment}

\begin{example}
  For read to write dependency, consider:
  \begin{align*}
    \begin{gathered}
      \PR{x}{r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{1{=}r\limplies\bForm}{}
          \xform{xi}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm}{right=.5em of xd}
          \eventl{\bEv}{a1}{\DR{x}{1}}{left=of xd}
          \xo{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm\noSUB{[r/y]}}{}
          \xform{xi}{\bForm\noSUB{[r/y]}}{right=.5em of xd}
          \eventl{\aEv}{a2}{r{=}1\mid\DW{y}{1}}{left=of xd}      
          \xo{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together without order,
  we calculate the precondition $\labelingForm(\aEv)$
  as $\aTr[1]{\cEvs}{\labelingForm_2(\aEv)}$, where $\cEvs$ is $\{\cEv\mid\cEv<\aEv\}$, which is $\emptyset$.
  Since $\aTr[1]{\emptyset}{\bForm}$ is $\bForm$, this gives that 
  $\labelingForm(\aEv)$ is $\labelingForm_2(\aEv)$, which is $\aReg{=}1$.
  This gives the pomsaet with predicate transformers:
  \begin{gather*}
    \PR{x}{r} \SEMI
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdd}{1{=}r\limplies\bForm\noSUB{[r/y]}}{}
        \xform{xdi}{1{=}r\limplies\bForm\noSUB{[r/y]}}{left=of xdd}
        \xform{xid}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xdd}
        \xform{xii}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xid}
        \eventl{\bEv}{a1}{\DR{x}{1}}{above=of xdi}
        \eventl{\aEv}{a2}{\noOR{(x{=}r\lor1{=}r)\limplies} r{=}1\mid\DW{y}{1}}{above=of xid}
        \xo{a1}{xdi}
        \xo{a2}{xid}
        \xo{a1}{xdd}
        \xo{a2}{xdd}
      \end{tikzinline}}
  \end{gather*}
  This pomset's preconditions depend on a bound register, so cannot contribute
  to a top-level pomset.
  
  Putting them together with order,
  we calculate the precondition $\labelingForm(\aEv)$
  as $\aTr[1]{\cEvs}{\labelingForm_2(\aEv)}$, where $\cEvs$ is $\{\cEv\mid\cEv<\aEv\}$, which is $\{\bEv\}$.
  Since $\aTr[1]{\{\bEv\}}{\bForm}$ is $(\aReg{=}1 \limplies \bForm)$, this gives that 
  $\labelingForm(\aEv)$ is $(\aReg{=}1 \limplies \labelingForm_2(\aEv))$, which is $(\aReg{=}1 \limplies \aReg{=}1)$.
  This gives the pomsaet with predicate transformers:
  \begin{gather*}
    \PR{x}{r} \SEMI
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdd}{1{=}r\limplies\bForm\noSUB{[r/y]}}{}
        \xform{xdi}{1{=}r\limplies\bForm\noSUB{[r/y]}}{left=of xdd}
        \xform{xid}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xdd}
        \xform{xii}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xid}
        \eventl{\bEv}{a1}{\DR{x}{1}}{above=of xdi}
        \eventl{\aEv}{a2}{r{=}1\limplies r{=}1\mid\DW{y}{1}}{above=of xid}
        \xo{a1}{xdi}
        \xo{a2}{xid}
        \xo{a1}{xdd}
        \xo{a2}{xdd}
        \wk{a1}{a2}
      \end{tikzinline}}
  \end{gather*}
  This pomset's preconditions do not depend on a bound register, so can contribute
  to a top-level pomset.
\end{example}

\begin{example}
  If the read and write choose different values:
  \begin{align*}
    \begin{gathered}
      \PR{x}{r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{1{=}r\limplies\bForm}{}
          \xform{xi}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm}{right=.5em of xd}
          \event{a1}{\DR{x}{1}}{left=of xd}
          \xo{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm\noSUB{[r/y]}}{}
          \xform{xi}{\bForm\noSUB{[r/y]}}{right=.5em of xd}
          \event{a2}{r{=}2\mid\DW{y}{2}}{left=of xd}      
          \xo{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together with order, we have the following, which cannot be
  part of a top-level pomset:
  \begin{gather*}
    \PR{x}{r} \SEMI
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdd}{1{=}r\limplies\bForm\noSUB{[r/y]}}{}
        \xform{xdi}{1{=}r\limplies\bForm\noSUB{[r/y]}}{left=of xdd}
        \xform{xid}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xdd}
        \xform{xii}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xid}
        \event{a1}{\DR{x}{1}}{above=of xdi}
        \event{a2}{1{=}r\limplies r{=}2\mid\DW{y}{2}}{above=of xid}
        \xo{a1}{xdi}
        \xo{a2}{xid}
        \xo{a1}{xdd}
        \xo{a2}{xdd}
        \wk{a1}{a2}
      \end{tikzinline}}
  \end{gather*}

  % The precondition of $\DWP{y}{2}$ is unsatisfiable if no further assumptions
  % can be made on $r$; that is the case here, since we assume each register
  % occurs at most once in source programs. If we choose a pomset that without
  % the order $\DRP{x}{1}\xpo\DWP{y}{2}$, the precondition of $\DWP{y}{1}$ is
  % strengthened to $(r{=}2)$, which is also unsatisfiable without further
  % assumptions on $r$; the predicate transformers are unchanged.
\end{example}

\subsection{Relaxed memory}

\begin{enumerate}
\item[\ref{L4})]
  $\aTr{\bEvs}{\bForm}$ implies $\bForm[\aVal/\aReg]$, 
% \item[\ref{L5})]
%   $\aTr{\emptyset}{\bForm}\;$ implies $\bForm[\aLoc/\aReg][\aVal/\aLoc]\land\bForm[\aLoc/\aReg]$,
\item[\ref{L5})]
  $\aTr{\emptyset}{\bForm}\;$ implies $(\forall\aReg)\bForm$.
\end{enumerate}

\begin{example}
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \SEMI \PW{x}{\BANG r} 
      \SEMI \PW{x}{r {\AND} s} 
      \SEMI \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
          \event{b}{\DW{x}{1}}{right=of a}
          \event{c}{\DW{x}{0}}{right=of b}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}  
\end{example}

The final semantic functions for load, store, and thread
initialization, given in Figure~\ref{fig:full}, are quite complex.  In
the remainder of the paper, we explain the definition by looking at
its constituent parts, building on \refdef{def:pomsets-trans}, which
models sequential composition, parallel composition, and conditionals.
In \textsection\ref{sec:q}, we add \emph{quiescence}, which encodes
coherence, release-acquire and SC access, and termination.  In
\textsection\ref{sec:arm}, we add peculiarities that are necessary for
efficient implementation on \armeight.  In
\textsection\ref{sec:complications}, we discuss
other features such as register recycling and address calculation.
\begin{figure*}
  \begin{center}
    \begin{minipage}{0.905\textwidth}
      \input{fig-full}
      % \input{fig-full-where}
      % \input{fig-full-noco}
    \end{minipage}
  \end{center}
  \caption{Full Semantics of Loads, Stores and Threads (See \refdef{def:QS}
    for $\QS{\aLoc}{\amode}$ and $\QL{\aLoc}{\amode}$ and \refdef{def:DS} for
    $\DL{\aLoc}{\amode}$ and $\DS{\aLoc}{\amode}$)}
  \label{fig:full}
\end{figure*}    

