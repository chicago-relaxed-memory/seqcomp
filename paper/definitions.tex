\section{The Basic Model}
\label{sec:model}

After some preliminaries, we define the basic model in \reffig{fig:sem}.  We
explain the model using examples and establish some basic properties.  We
encourage readers to skip to the examples, coming back as needed.

%% Batty suggest example where dependencies are added and also go away, perhaps
%% by store forwarding. Something like:
%% \texttt{(r=x; y=1); (s=y; z=s+r)}

% In this section, we present the mathematical preliminaries for the
% model (which can be skipped on first reading). We then present the
% model incrementally, starting with a model built using
% \emph{partially ordered multisets}
% (\emph{pomsets})~\cite{GISCHER1988199,Plotkin:1997:TSP:266557.266600},
% and then adding preconditions and finally predicate transformers.

% In later sections, we will discuss extensions to the logic, and to the
% semantics of load, store and thread initialization, in order to model
% relaxed memory more faithfully. We stress that these features do
% \emph{not} change any of the structures of the language: conditionals,
% parallel composition, and sequential composition are as defined in this section.

\subsection{Preliminaries}
\label{sec:prelim}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$.
\end{itemize}

\emph{Memory references} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory references, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.
%
We require that
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
\item expressions include at least registers and values, 
\item expressions do \emph{not} include references: $\aExp[\bExp/\aLoc]=\aExp$.
\end{itemize}

We model the following language.
\begin{gather*}
  \begin{aligned}
    \amode \BNFDEF& \mRLX
    \BNFSEP \mRA 
    \BNFSEP \mSC
    &\mkern100mu
    \fmode \BNFDEF& \fACQ 
    \BNFSEP \fREL
    \BNFSEP \fSC
  \end{aligned}
  \\
  \aCmd
  \BNFDEF \LET{\aReg}{\aExp}
  \BNFSEP \PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}
  \BNFSEP \PW[\amode]{\REF{\cExp}}[\ascope]{\aExp}
  \BNFSEP \PF[\ascope]{\fmode}
  \BNFSEP \SKIP
  \BNFSEP \aCmd_1 \SEMI \aCmd_2
  \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
  \BNFSEP \aCmd_1 \LPAR[\bThrd] \aCmd_2
  % \\[-.5ex]
  % \BNFSEP& \PCAS[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
  % \BNFSEP \PFADD[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  % \BNFSEP \PEXCHG[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
\end{gather*}

\emph{Memory modes}, $\amode$, are {relaxed} ($\mRLX$), {release-acquire}
($\mRA$), and {sequentially consistent} ($\mSC$).  Relaxed mode is the
default; we regularly elide it from examples.  $\mRA$/$\mSC$ accesses are
collectively known as \emph{synchronized accesses}.  

\emph{Fence modes}, $\bmode$, are {acquire} ($\fACQ$), {release} ($\fREL$), 
and {acquire-release} ($\fSC$).  

\emph{Commands}, aka \emph{statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs. Following
\cite{DBLP:conf/icfp/FerreiraHJ96}, $\LPAR$ denotes parallel composition,
preserving thread state on the left after a join.  In examples and
sublanguages without join, we use the symmetric $\PAR$ operator.

Throughout \textsection\ref{sec:model}--\ref{sec:arm} we 
require that
\begin{itemize}
\item each register is assigned at most once in a program.
  % \end{itemize}
  % In \textsection\ref{sec:complications} and following, we
  % require instead that
  % \begin{itemize}
  % \end{itemize}
\end{itemize}
In \textsection\ref{sec:complications}, we drop this restriction, requiring
instead that
\begin{itemize}
\item there are registers
  $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$, that do not
  appear in programs: $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$.
\end{itemize}
% In contexts that make no use of $\uRegs{\AllEvents}$, we make the first
% assumption.

The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, %$\dEv$,
  and subsets ranged over by $\aEvs$, $\bEvs$, $\cEvs$,  
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$,
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, $\bAct$.
\end{itemize}
%$\dEvs$.

We require that:
\begin{itemize}
\item formulae include $\TRUE$, $\FALSE$ and the equalities $(\aExp{=}\bExp)$ and $(\aLoc{=}\aExp)$,
\item formulae are closed under $\lnot$, $\land$, $\lor$, $\limplies$, and
  substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$,
\item there is a relation $\rimpliesdef$ between
  formulae, capturing entailment, %\subseteq(\Formulae\times\Formulae)$ %
\item $\rimpliesdef$ has the expected semantics for $=$, $\lnot$,
  $\land$, $\lor$, $\limplies$ and substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$,
\item there are three binary relations over $\Act\times\Act$:
  $\rmatchesdef$, $\rblocksdef$, and $\rdelaysdef$,
\item there are two subsets of $\Act$, distinguishing
  $\sreaddef$ and $\sreleasedef$ actions.
\end{itemize}

Logical formulae include equations over registers and memory references, such as
$(\aReg{=}\bReg{+}1)$ and $(\aLoc{=}1)$.
%For use in \textsection\ref{sec:tc1}, we also include equations over memory references, such as $(\aLoc{=}1)$.
% I would like to drop this, an be careful about program vs logical syntax
We use expressions as formulae, coercing $\aExp$ to $\aExp{\neq}0$.
% Equations have precedence over logical operators; thus
% $\aReg{=}\aVal\limplies\bReg{>}\bVal$ is read
% $(\aReg{=}\aVal)\limplies(\bReg{>}\bVal)$.  As usual, implication associates to the
% right; thus $\aForm\limplies\bForm\limplies\cForm$ is read
% $\aForm\limplies(\bForm\limplies\cForm)$.
As usual, implication associates to the right; thus
$\aReg{=}\aVal\limplies\bReg{>}\bVal\limplies\bForm$ is read
$(\aReg{=}\aVal)\limplies((\bReg{>}\bVal)\limplies\bForm)$.

% Formulae are subject to substitutions; % of the form $[\aExp/\aReg]$ and
% % $[\aExp/\aLoc]$;
% actions are not.

% \begin{definition}
%   \label{def:independent}
%   We say $\aForm$ is \emph{independent of $\aLoc$} if, for every
%   $\aVal$, $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$; it is
%   \emph{dependent} otherwise.
%   We say $\aForm$ is \emph{location independent} if it is independent of
%   every location.
%   We say
%   $\aForm$ \emph{implies} $\bForm$ if $\aForm\vDash\bForm$.
%   We say that
We say
$\aForm$ is a \emph{tautology} if $\TRUE \rimplies \aForm$.
% We say that
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm \rimplies \FALSE$.
% \end{definition}




\subsection{Actions in This Paper}

In this paper, we let actions be reads and writes and fences:
\begin{displaymath}
  \aAct,\bAct \BNFDEF \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DF[\ascope]{\fmode}[\aThrd]
\end{displaymath}
% % writes $\DWP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% reads $\DRP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% and fences $\DFP[\ascope]{\fmode}[\aThrd]$.

We use shorthand when referring to actions.  In definitions, we drop elements
of actions that are existentially quantified.  In examples, we drop elements
of actions, using defaults.
% We write $\DXP[\amode]{}[\ascope]{}[\aThrd]$ to
% stand for $\DWP[\amode]{}[\ascope]{}[\aThrd]$ or
% $\DRP[\amode]{}[\ascope]{}[\aThrd]$.
%
Let $\lemode$ be the least order over access and fence modes such that
$\mRLX\lemode\mRA\lemode\mSC$ and $\fREL\lemode\fSC$ and $\fACQ\lemode\fSC$.
We write $\DWP[\gemode\mRA]{}{}$ to stand for either $\DWP[\mRA]{}{}$ or
$\DWP[\mSC]{}{}$, and similarly for the other actions and modes.

% We also define shorthand for sets of
% actions using an order on access and fence modes:  
% \begin{align*}
%   \begin{tikzcenter}
%     \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
%     \node (ra)  at (1, 0) {$\mathstrut\mRA$};
%     \node (sc)  at (2, 0) {$\mathstrut\mSC$};
%     \draw[->](rlx)to(ra);
%     \draw[->](ra)to(sc);
%   \end{tikzcenter}
%   &&
%   \begin{tikzcenter}
%     \node (fsc) at (3, 0) {$\mathstrut\fSC$};
%     \node (rel) at (2, -0.2) {$\mathstrut\fREL$};
%     \node (acq) at (2,  0.2) {$\mathstrut\fACQ$};
%     \draw[->](rel)to(fsc);
%     \draw[->](acq)to(fsc);
%   \end{tikzcenter}
% \end{align*}
% We write $\amode\lemode\bmode$ for this order.
%Let $\amode\lubmode\bmode$ denote the least upper bound of $\amode$ and $\bmode$.

% or $\DFP[\ascope]{\amode}[\aThrd]$.
% We write $\DWP[\gemode\mREL]{}{}$ to stand for either
% $\DWP[\mREL]{}{}$ or $\DWP[\mSC]{}{}$, and similarly for other actions and
% modes.

\begin{definition}
  \label{def:actions}
  Actions $\DRP{}{}$ are $\sreaddef$ actions.
  Actions $\DWP[\gemode\mREL]{}{}$ and $\DFP{\gemode\fREL}$ are
  $\sreleasedef$ actions.

  We say $\aAct \rmatchesdef \bAct$ if $\aAct=\DWP{\aLoc}{\aVal}$ and $\bAct=\DRP{\aLoc}{\aVal}$.
  % We say $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.
  % Action $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.

  We say $\aAct \rblocksdef \bAct$ if $\aAct=\DWP{\aLoc}{}$ and $\bAct=\DRP{\aLoc}{}$, regardless of value.
  % We say $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.
  % Action $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.

  % Let two actions \emph{overlap} if they access the same location.
  % We say $\aAct \roverlapsdef \bAct$ if they access the same location.

  We say $\aAct \rdelaysdef \bAct$ if $\aAct\eqreorderco\bAct$ or $\aAct\reorderra\bAct$ or $\aAct\eqreordersc\bAct$.

  Let ${\eqreorderco}$ capture write-write, read-write coherence:
  \begin{math}
    {\eqreorderco}
    =
    \{(\DW{\aLoc}{}\Cb \DW{\aLoc}{})\C(\DR{\aLoc}{}\Cb \DW{\aLoc}{})\C(\DW{\aLoc}{}\Cb \DR{\aLoc}{})\}
  \end{math}.

  Let ${\reorderra}$ capture order due to synchronization:
  \begin{math}
    {\reorderra}
    =
    \{(\aAct\Cb             \DW[\gemode\mREL]{}{}     )\C
    (\aAct\Cb               \DF{\gemode\fREL}        )\C
    (\DR{}{}\Cb             \DF{\gemode\fACQ}        )\C
    (\DR{\aLoc}{}\Cb        \DR[\gemode\mACQ]{\aLoc}{})\C
    (\DR[\gemode\mACQ]{}{}\Cb\aAct                    )\C
    (\DF{\gemode\fACQ}\Cb   \aAct                    )\C
    (\DF{\gemode\fREL}\Cb   \DW{}{}                  )\C
    (\DW[\gemode\mREL]{\aLoc}{}\Cb\DW{\aLoc}{})\}
  \end{math}.

  Let ${\eqreordersc}$ capture order due to $\mSC$ access:
  \begin{math}
    {\eqreordersc}
    =
    %\{(\DX[\mSC]{}{}\Cb\DX[\mSC]{}{})\}
    \{(\DW[\mSC]{}{}\Cb \DW[\mSC]{}{})\C(\DR[\mSC]{}{}\Cb \DW[\mSC]{}{}) \C(\DW[\mSC]{}{}\Cb \DR[\mSC]{}{})\C(\DR[\mSC]{}{}\Cb \DR[\mSC]{}{})\}
  \end{math}.
\end{definition}

\subsection{Pomsets with Predicate Transformers}
\label{sec:pomsets-trans}

\emph{Predicate transformers} are functions on formulae which preserve
logical structure, providing a natural model of sequential composition.


\begin{definition}
  \label{def:trans}
  A \emph{predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{multicols}{2}
    \begin{enumerate}[,label=(\textsc{x}\arabic*),ref=\textsc{x}\arabic*]
    \item \label{tr-false}
      $\aTr{}{\FALSE}$ is $\FALSE$,    
    \item \label{tr-and}
      $\aTr{}{\bForm_1\land\bForm_2}$ is $\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$,    
    \item \label{tr-or}
      $\aTr{}{\bForm_1\lor\bForm_2}$ is $\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$, 
    \item \label{tr-implies}
      if $\aForm \rimplies \bForm$, then $\aTr{}{\aForm} \rimplies
      \aTr{}{\bForm}$.
    \end{enumerate}
  \end{multicols}
\end{definition}
\noindent
The definition follows \citet{DBLP:journals/cacm/Dijkstra75}.  Note that
substitutions ($\aTr{}{\psi}=\psi[\aExp/\aReg]$ and
$\aTr{}{\psi}=\psi[\aExp/\aLoc]$) and implications on the right
($\aTr{}{\psi}=\phi\limplies\psi$) are predicate transformers.

As discussed in \S\ref{sec:intro}, predicate transformers suffice for sequentially consistent
models, but not relaxed models, where dependency calculation is crucial.
For dependency calculation, we use a \emph{family} of predicate transformers,
indexed by sets of events. We use $\aTr{\bEvs}{}$ as the predicate transformer
applied to any event $\aEv$ where if $\bEv\in\bEvs$ then $\bEv<\aEv$.

\begin{definition}
  \label{def:family}
  A \emph{family of predicate transformers} for $\aEvs$ consists of a
  predicate transformer $\aTr{\bEvs}{}$ for each $\bEvs\subseteq\AllEvents$,
  such that if $\cEvs \cap \aEvs \subseteq \bEvs$ then $\aTr{\cEvs}{\bForm}
  \rimplies \aTr{\bEvs}{\bForm}$.

  We write $\aTr{}{}$ as an abbreviation of $\aTr{\aEvs}{}$.
\end{definition}

\begin{definition}
  \label{def:pomset}
  A \emph{pomset with predicate transformers} over $\Act$
  is a tuple $(\aEvs, \labeling, \labelingForm, \aTr{}{}, \aTerm, {\rrfx}, {\le})$ where
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
  \item \label{pom-E}
    $\Event\subseteq\AllEvents$ is a set of \emph{events},
  \item \label{pom-lambda}
    $\labeling: \Event \fun \Act$ defines a \emph{label} for each event,
  \item \label{pom-kappa}
    $\labelingForm:\aEvs\fun\Formulae$ defines a \emph{precondition} for each event,
  \item \label{pom-tau}
    $\aTr{}{}:2^{\AllEvents}\fun\Formulae \fun\Formulae$ is a \emph{family of
      predicate transformers} over $\aEvs$, %defines a \emph{predicate transformer} for each set of events,
  \item \label{pom-term}
    $\aTerm:\Formulae$ defines a \emph{termination condition},
  \item \label{pom-rf}
    ${\rrfx} : \Event\fun\Event$ is an injective relation capturing
    \emph{reads-from} such that 
    % \end{enumerate}
    % A pomset is a \emph{candidate} if there is an injective relation
    % ${\rrfx} : \Event\times\Event$, capturing \emph{reads-from}, such that
    \begin{enumerate}
      % \begin{enumerate}[,label=(\textsc{c}\arabic*),ref=\textsc{c}\arabic*]
      % \item \label{rf-injective}
      %   if $\bEv\xrfx\aEv$ and $\cEv\xrfx\aEv$ then $\bEv=\cEv$, that is, ${\rrfx}$ is injective,
    \item \label{rf-match}
      if $\bEv\xrfx\aEv$ then $\labeling(\bEv) \rmatches \labeling(\aEv)$,
      % \item \label{rf-block}
      %   if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\le\bEv$ or $\aEv\le\cEv$.
      % \item \label{rf-le}
      %   if $\bEv\xrfx\aEv$ then $\bEv\le\aEv$.
    \end{enumerate}
  \item \label{pom-le}
    ${\le} : \Event\times\Event$, is a partial order capturing
    \emph{causality}, such that
    \begin{enumerate}
      \item \label{rf-block}
        if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\le\bEv$ or $\aEv\le\cEv$.
    \end{enumerate}
  \end{enumerate}
  A pomset is \emph{top-level} if $\aTerm$ is a tautology and for every $\aEv\in\aEvs$,
  % $\labelingForm(\aEv)$ is a tautology and
  % if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$.
  %\begin{multicols}{2}
    \begin{enumerate}[label=(\textsc{t}\arabic*),ref=\textsc{t}\arabic*]
    \item \label{top-true}
      $\labelingForm(\aEv)$ is a tautology,    
    \item \label{top-rf}
      if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$.
    \end{enumerate}
  %\end{multicols}
\end{definition}

We give the semantics of programs in \reffig{fig:sem}.
\input{fig-sem.tex}

\begin{lemma}
  \label{lem:rf:implies:le}
  For any $\aPS$ in the range of $\sembase{}$, $\bEv\xrfx\aEv$ implies
  $\bEv\le\aEv$.

  \vspace{-.5\baselineskip}
  \begin{proof}
    Induction on the definition of $\sembase{}$.
  \end{proof}
\end{lemma}

The semantics to be closed with respect to \emph{augmentation}
Augments include more order and stronger formulae; in examples, we typically
consider pomsets that are augment-minimal.  One intuitive reading of augment
closure is that adding order can only cause preconditions to weaken.
\begin{definition}
  \label{def:augment}
  $\aPS_2$ is an \emph{augment} of $\aPS_1$ if
  \begin{multicols}{4}
    \begin{enumerate}
    \item $\aEvs_2=\aEvs_1$,
    \item $\labelingAct_2(\aEv)=\labelingAct_1(\aEv)$,
    \item $\labelingForm_2(\aEv) \rimplies \labelingForm_1(\aEv)$,
    \item $\aTr[2]{\bEvs}{\aEv} \rimplies \aTr[1]{\bEvs}{\aEv}$,
    \item $\aTerm[2] \rimplies \aTerm[1]$,
    \item ${\rrfx_2}={\rrfx_1}$,
    \item ${\le_2}\supseteq{\le_1}$.
    \end{enumerate}
  \end{multicols}
\end{definition}

\begin{lemma}
  % Suppose $\aPS_1\in\sembase{\aCmd}$.
  If $\aPS_1\in\sembase{\aCmd}$ and $\aPS_2$  augments $\aPS_1$ then $\aPS_2\in\sembase{\aCmd}$.
  % \item If $\aPS_2$ is a downset of $\aPS_1$ then $\aPS_2\in\sembase{\aCmd}$.
  % \end{lemma}

  \vspace{-.5\baselineskip}
  \begin{proof}
    Induction on the definition of $\sembase{}$.
  \end{proof}
\end{lemma}

\begin{lemma}
  $(\aPSS_1\SEMI\aPSS_2)\SEMI\aPSS_3=\aPSS_1\SEMI(\aPSS_2\SEMI\aPSS_3)$
  and    
  $\aPSS\SEMI\SKIP=\aPSS=\SKIP\SEMI\aPSS$.

  $(\aPSS_1\LPAR\aPSS_2)\LPAR\aPSS_3=\aPSS_1\LPAR(\aPSS_2\LPAR\aPSS_3)$
  and    
  $\aPSS\LPAR\SKIP=\aPSS$.  

  \vspace{-.5\baselineskip}
  \begin{proof}
    Straightforward calculation.  Associativity of $\SEMI\!$ requires
    disjunction closure \eqref{tr-or}.
  \end{proof}
\end{lemma}




% \begin{definition}
%   Suppose $\aRel_1:\aEvs_1\times\aEvs_1$ and $\aRel_2:\aEvs_2\times\aEvs_2$.
%   We say $\aRel \rextendsdef{\aRel_1}{\aRel_2}$ if
%   $\aRel\supseteq (\aRel_1\cup \aRel_2)$ and
%   $\aRel\cap(\aEvs_1\times \aEvs_1) = \aRel_1$ and
%   $\aRel\cap(\aEvs_2\times \aEvs_2) = \aRel_2$.
% \end{definition}
Note that $\aEvs_1$ and $\aEvs_2$ are not necessarily disjoint.
In $\sIFTHEN{}{}{}$, the definition of $\rextendsdef{}{}$ stops coalescing the $\rrfx$ in
\begin{displaymath}
  \IF{b}\THEN\PR{x}{r}\PAR\PW{x}{1}\ELSE\PR{x}{r}\SEMI\PW{x}{1}\FI
\end{displaymath}


We have given the semantics of $\sIF{}{}{}$ using 
disjunctive normal form. \citet{DBLP:journals/cacm/Dijkstra75} used
conjunctive normal form.  Note that 
\href{https://www.wolframalpha.com/input/?i=\%28a+and+b\%29+or+\%28not+a+and+c\%29}{$(\aForm\land\cForm_1)\lor(\neg\aForm\land\cForm_2)$}
is logically equivalent to
\href{https://www.wolframalpha.com/input/?i=\%28a+implies+b\%29+and+\%28\%28not+a\%29+implies+c\%29}{$(\aForm\limplies\cForm_1)\land(\neg\aForm\limplies\cForm_2)$}.

%We include empty sets as prep for adding while loops.


% In diagrams, we use different colors for arrows.  We distinguish
% $\rrfx$ edges that are included in order from those that are not.
% \begin{itemize}
% \item \makebox{$\aEv\xrf\bEv$} arises from $\rrfx$, where $\aEv\le\bEv$,
% \item \makebox{$\aEv\xrfint\bEv$} arises from $\rrfx$, where $\lnot(\aEv\le\bEv)$.
% \end{itemize}
% To help the reader understand why order is included, we also different colors
% for arrows induced by order.  We adopt the following conventions:
% \begin{itemize}  
%   % \item relaxed accesses are blue, with a single border,
%   % \item synchronized accesses are red, with a double border,
%   % \item \makebox{$\aEv\xrf\bEv$} arises from fulfillment, where $\aEv$ \emph{matches} $\bEv$,
%   % \item \makebox{$\aEv\xwk\bEv$} arises either from fulfillment, where $\aEv$
%   %   \emph{blocks} $\bEv$, or from prefixing, where $\aEv$ was prefixed before
%   %   $\bEv$ and their actions \emph{conflict},
% \item \makebox{$\aEv\xwk\bEv$} arises from \emph{fulfillment},
% \item \makebox{$\aEv\xpo\bEv$} arises from control/data/address \emph{dependency},
% \item \makebox{$\aEv\xsync\bEv$} arises from \emph{synchronized access}.
% \end{itemize}



