\section{The Basic Model}
\label{sec:model}

After some preliminaries (\textsection\ref{sec:prelim}--\ref{sec:actions}),
we define the basic model and establish some basic properties
(\textsection\ref{sec:pomsets} and \reffig{fig:sem}).  We then explain the
model using examples (\textsection\ref{sec:ex:pomset}--\ref{sec:ex:last}).
We encourage readers to skim the definitions and then skip to
\textsection\ref{sec:ex:pomset}, coming back as needed.

%% Batty suggest example where dependencies are added and also go away, perhaps
%% by store forwarding. Something like:
%% \texttt{(r=x; y=1); (s=y; z=s+r)}

% In this section, we present the mathematical preliminaries for the
% model (which can be skipped on first reading). We then present the
% model incrementally, starting with a model built using
% \emph{partially ordered multisets}
% (\emph{pomsets})~\cite{GISCHER1988199,Plotkin:1997:TSP:266557.266600},
% and then adding preconditions and finally predicate transformers.

% In later sections, we will discuss extensions to the logic, and to the
% semantics of load, store and thread initialization, in order to model
% relaxed memory more faithfully. We stress that these features do
% \emph{not} change any of the structures of the language: conditionals,
% parallel composition, and sequential composition are as defined in this section.

\subsection{Preliminaries}
\label{sec:prelim}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$.
\end{itemize}

\emph{Memory references} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory references, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.
% 
We require that
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
\item expressions include at least registers and values, 
\item expressions do \emph{not} include references: $\aExp[\bExp/\aLoc]=\aExp$.
\end{itemize}

We model the following language.
\begin{gather*}
  \begin{aligned}
    \amode,\bmode \BNFDEF& \mRLX
    \BNFSEP \mREL
    \BNFSEP \mACQ
    \BNFSEP \mSC
    % \amode \BNFDEF& \mRLX
    % \BNFSEP \mRA 
    % \BNFSEP \mSC
    % &\mkern100mu
    % \fmode \BNFDEF& \fACQ 
    % \BNFSEP \fREL
    % \BNFSEP \fSC
  \end{aligned}
  \\
  \aCmd
  \BNFDEF \LET{\aReg}{\aExp}
  \BNFSEP \PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}
  \BNFSEP \PW[\amode]{\REF{\cExp}}[\ascope]{\aExp}
  \BNFSEP \PF[\ascope]{\fmode}
  \BNFSEP \SKIP
  \BNFSEP \aCmd_1 \SEMI \aCmd_2
  \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
  \BNFSEP \aCmd_1 \LPAR[\bThrd] \aCmd_2
  % \\[-.5ex]
  % \BNFSEP& \PCAS[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
  % \BNFSEP \PFADD[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  % \BNFSEP \PEXCHG[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
\end{gather*}

% \emph{Memory modes}, $\amode$, are {relaxed} ($\mRLX$), {release-acquire}
% ($\mRA$), and {sequentially consistent} ($\mSC$).  Relaxed mode is the
% default; we regularly elide it from examples.  $\mRA$/$\mSC$ accesses are
% collectively known as \emph{synchronized accesses}.  

% \emph{Fence modes}, $\bmode$, are {acquire} ($\fACQ$), {release} ($\fREL$), 
% and {acquire-release} ($\fSC$).  

\emph{Access modes}, $\amode$, are {relaxed} ($\mRLX$),
{release} ($\mREL$), {acquire} ($\mACQ$), and
{sequentially consistent} ($\mSC$).
%
Let expressions ($\LET{\aReg}{\aExp}$) only affect thread-local state and
thus do not have a mode.
%
Reads ($\PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
%$\mWK$,
$\mRLX$,
%$\mREL$,
$\mACQ$,
%$\mRA$, 
$\mSC$. 
Writes ($\PW[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
%$\mWK$,
$\mRLX$,
$\mREL$,
%$\mACQ$,
%$\mRA$, 
$\mSC$. 
Fences ($\PF[\ascope]{\fmode}$) support
%$\mWK$,
%$\mRLX$,
$\mREL$,
$\mACQ$,
%$\mRA$,
$\mSC$.

\emph{Commands}, aka \emph{statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs. Following
\cite{DBLP:conf/icfp/FerreiraHJ96}, $\LPAR$ denotes parallel composition,
preserving thread state on the left after a join.  In examples and
sublanguages without join, we use the symmetric $\PAR$ operator.

We use common syntax sugar, such as \emph{extended expressions}, $\aEExp$,
which include memory locations.  For example, if $\aEExp$ includes a single
occurrence of $\aLoc$, then $\bLoc\GETS\aEExp\SEMI \aCmd$ is shorthand for
$\aReg\GETS\aLoc\SEMI\bLoc\GETS\aEExp[\aReg/\aLoc]\SEMI \aCmd$.  Each
occurrence of $\aLoc$ in an extended expression corresponds to an separate
read.  We also write $\IF{\aExp} \THEN \aCmd \FI$ as shorthand for
$\IF{\aExp} \THEN \aCmd\ELSE \SKIP\FI$.



Throughout \textsection\ref{sec:intro}--\ref{sec:arm} we 
require that
\begin{itemize}
\item each register is assigned at most once in a program.
  % \end{itemize}
  % In \textsection\ref{sec:complications} and following, we
  % require instead that
  % \begin{itemize}
  % \end{itemize}
\end{itemize}
In \textsection\ref{sec:additional}, we drop this restriction, requiring
instead that
\begin{itemize}
\item there are registers
  $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$, that do not
  appear in programs: $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$.
\end{itemize}
% In contexts that make no use of $\uRegs{\AllEvents}$, we make the first
% assumption.

The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, %$\dEv$,
  and subsets ranged over by $\aEvs$, $\bEvs$, $\cEvs$,  
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$,
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, $\bAct$.
\end{itemize}
% $\dEvs$.

We require that
\begin{itemize}
\item formulae include $\TRUE$, $\FALSE$ and the equalities $(\aExp{=}\bExp)$ and $(\aLoc{=}\aExp)$,
\item formulae are closed under $\lnot$, $\land$, $\lor$, $\limplies$, and
  substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$,
\item there is a relation $\rimpliesdef$ between
  formulae, capturing entailment, %\subseteq(\Formulae\times\Formulae)$ %
\item $\rimpliesdef$ has the expected semantics for $=$, $\lnot$,
  $\land$, $\lor$, $\limplies$ and substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$,
\item there are three binary relations over $\Act\times\Act$:
  $\rmatchesdef$, $\rblocksdef$, and $\rdelaysdef$,
\item there are two subsets of $\Act$, distinguishing
  $\sreaddef$ and $\sreleasedef$ actions.
\end{itemize}

Logical formulae include equations over registers and memory references, such as
$(\aReg{=}\bReg{+}1)$ and $(\aLoc{=}1)$.
% For use in \textsection\ref{sec:tc1}, we also include equations over memory references, such as $(\aLoc{=}1)$.
% I would like to drop this, an be careful about program vs logical syntax
We use expressions as formulae, coercing $\aExp$ to $\aExp{\neq}0$.
% Equations have precedence over logical operators; thus
% $\aReg{=}\aVal\limplies\bReg{>}\bVal$ is read
% $(\aReg{=}\aVal)\limplies(\bReg{>}\bVal)$.  As usual, implication associates to the
% right; thus $\aForm\limplies\bForm\limplies\cForm$ is read
% $\aForm\limplies(\bForm\limplies\cForm)$.
% As usual, implication associates to the right; thus
% $\aReg{=}\aVal\limplies\bReg{>}\bVal\limplies\bForm$ is read
% $(\aReg{=}\aVal)\limplies((\bReg{>}\bVal)\limplies\bForm)$.

% Formulae are subject to substitutions; % of the form $[\aExp/\aReg]$ and
% % $[\aExp/\aLoc]$;
% actions are not.

% \begin{definition}
%   \label{def:independent}
%   We say $\aForm$ is \emph{independent of $\aLoc$} if, for every
%   $\aVal$, $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$; it is
%   \emph{dependent} otherwise.
%   We say $\aForm$ is \emph{location independent} if it is independent of
%   every location.
%   We say
%   $\aForm$ \emph{implies} $\bForm$ if $\aForm\vDash\bForm$.
%   We say that
We write $\aForm\riff\bForm$ when $\aForm\rimplies\bForm$ and $\bForm\rimplies\aForm$.
We say
$\aForm$ is a \emph{tautology} if $\TRUE \rimplies \aForm$.
% We say that
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm \rimplies \FALSE$, and
\emph{satisfiable} otherwise.
% \end{definition}




\subsection{Actions in This Paper}
\label{sec:actions}
In this paper, we let actions be reads and writes and fences:
\begin{displaymath}
  \aAct,\bAct \BNFDEF \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DF[\ascope]{\fmode}[\aThrd]
\end{displaymath}
% % writes $\DWP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% reads $\DRP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% and fences $\DFP[\ascope]{\fmode}[\aThrd]$.

We use shorthand when referring to actions.  In definitions, we drop elements
of actions that are existentially quantified.  In examples, we drop elements
of actions, using defaults.
% We write $\DXP[\amode]{}[\ascope]{}[\aThrd]$ to
% stand for $\DWP[\amode]{}[\ascope]{}[\aThrd]$ or
% $\DRP[\amode]{}[\ascope]{}[\aThrd]$.
% 
Let $\lemode$ be the smallest order over access and fence modes such that
%$\mRLX\lemode\mRA\lemode\mSC$ and $\fREL\lemode\fSC$ and $\fACQ\lemode\fSC$.
$\mRLX\lemode\mREL\lemode\mSC$ and $\mRLX\lemode\mACQ\lemode\mSC$.
We write $\DWP[\gemode\mREL]{}{}$ to stand for either $\DWP[\mREL]{}{}$ or
$\DWP[\mSC]{}{}$, and similarly for the other actions and modes.

% We also define shorthand for sets of
% actions using an order on access and fence modes:  
% \begin{align*}
%   \begin{tikzcenter}
%     \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
%     \node (ra)  at (1, 0) {$\mathstrut\mRA$};
%     \node (sc)  at (2, 0) {$\mathstrut\mSC$};
%     \draw[->](rlx)to(ra);
%     \draw[->](ra)to(sc);
%   \end{tikzcenter}
%   &&
%   \begin{tikzcenter}
%     \node (fsc) at (3, 0) {$\mathstrut\fSC$};
%     \node (rel) at (2, -0.2) {$\mathstrut\fREL$};
%     \node (acq) at (2,  0.2) {$\mathstrut\fACQ$};
%     \draw[->](rel)to(fsc);
%     \draw[->](acq)to(fsc);
%   \end{tikzcenter}
% \end{align*}
% We write $\amode\lemode\bmode$ for this order.
% Let $\amode\lubmode\bmode$ denote the least upper bound of $\amode$ and $\bmode$.

% or $\DFP[\ascope]{\amode}[\aThrd]$.
% We write $\DWP[\gemode\mREL]{}{}$ to stand for either
% $\DWP[\mREL]{}{}$ or $\DWP[\mSC]{}{}$, and similarly for other actions and
% modes.

\begin{definition}
  \label{def:actions}
  Actions $\DRP{}{}$ are $\sreaddef$ actions.
  Actions $\DWP[\gemode\mREL]{}{}$ and $\DFP{\gemode\fREL}$ are
  $\sreleasedef$ actions.

  We say $\aAct \rmatchesdef \bAct$ if $\aAct=\DWP{\aLoc}{\aVal}$ and $\bAct=\DRP{\aLoc}{\aVal}$.
  % We say $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.
  % Action $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.

  We say $\aAct \rblocksdef \bAct$ if $\aAct=\DWP{\aLoc}{}$ and $\bAct=\DRP{\aLoc}{}$, regardless of value.
  % We say $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.
  % Action $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.

  % Let two actions \emph{overlap} if they access the same location.
  % We say $\aAct \roverlapsdef \bAct$ if they access the same location.

  Let ${\eqreorderco}$ capture write-write, read-write coherence:
  \begin{math}
    {\eqreorderco}
    =
    \{(\DW{\aLoc}{}\Cb \DW{\aLoc}{})\Cc(\DR{\aLoc}{}\Cb \DW{\aLoc}{})\Cc(\DW{\aLoc}{}\Cb \DR{\aLoc}{})\}
  \end{math}.

  Let ${\reorderra}$ capture conflict due to synchronization:
  \begin{math}
    {\reorderra}
    =
    \{(\aAct\Cb             \DW[\gemode\mREL]{}{}     )\Cc
    (\aAct\Cb               \DF{\gemode\fREL}        )\Cc
    (\DR{}{}\Cb             \DF{\gemode\fACQ}        )\Cc
    % (\DR{\aLoc}{}\Cb        \DR[\gemode\mACQ]{\aLoc}{})\Cc
    (\DR[\gemode\mACQ]{}{}\Cb\aAct                    )\Cc
    (\DF{\gemode\fACQ}\Cb   \aAct                    )\Cc
    (\DF{\gemode\fREL}\Cb   \DW{}{}                  )\Cc
    (\DW[\gemode\mREL]{\aLoc}{}\Cb\DW{\aLoc}{})\}
  \end{math}.

  Let ${\eqreordersc}$ capture conflict due to $\mSC$ access:
  \begin{math}
    {\eqreordersc}
    =
    % \{(\DX[\mSC]{}{}\Cb\DX[\mSC]{}{})\}
    \{(\DW[\mSC]{}{}\Cb \DW[\mSC]{}{})\Cc(\DR[\mSC]{}{}\Cb \DW[\mSC]{}{}) \Cc(\DW[\mSC]{}{}\Cb \DR[\mSC]{}{})\Cc(\DR[\mSC]{}{}\Cb \DR[\mSC]{}{})\}
  \end{math}.

  We say $\aAct \rdelaysdef \bAct$ if $\aAct\eqreorderco\bAct$ or $\aAct\reorderra\bAct$ or $\aAct\eqreordersc\bAct$.
\end{definition}

\subsection{The Semantic Domain} %: Pomsets with Predicate Transformers}
\label{sec:pomsets}

\emph{Predicate transformers} are functions on formulae that preserve
logical structure, providing a natural model of sequential composition.
The definition comes from \citet{DBLP:journals/cacm/Dijkstra75}:

\begin{definition}
  \label{def:trans}
  A \emph{predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{multicols}{2}
    \begin{enumerate}[,label=(\textsc{x}\arabic*),ref=\textsc{x}\arabic*]
    \item \label{tr-false}
      $\aTr{}{\FALSE}$ is $\FALSE$,    
    \item \label{tr-and}
      $\aTr{}{\bForm_1\land\bForm_2}$ is $\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$,    
    \item \label{tr-or}
      $\aTr{}{\bForm_1\lor\bForm_2}$ is $\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$, 
    \item \label{tr-implies}
      if $\aForm \rimplies \bForm$, then $\aTr{}{\aForm} \rimplies
      \aTr{}{\bForm}$.
    \end{enumerate}
  \end{multicols}
\end{definition}
\noindent
We consistently use $\bForm$ as the parameter of predicate transformers.
Note that substitutions ($\bForm[\aExp/\aReg]$ and $\bForm[\aExp/\aLoc]$) and
implications on the right ($\aForm\limplies\bForm$) are predicate
transformers.

As discussed in \S\ref{sec:intro}, predicate transformers suffice for
sequentially consistent models, but not relaxed models, where dependency
calculation is crucial.  For dependency calculation, we use a \emph{family}
of predicate transformers, indexed by sets of events. In sequential
composition, we will use $\aTr{\Cdown{\aEv}}{}$ as the predicate transformer
applied to event $\aEv$ where $\bEv\in(\Cdown{\aEv})$ if $\bEv<\aEv$.

\begin{definition}
  \label{def:family}
  A \emph{family of predicate transformers} over $\aEvs$ consists of a
  predicate transformer $\aTr{\bEvs}{}$ for each $\bEvs\subseteq\AllEvents$,
  such that if $\cEvs \cap \aEvs \subseteq \bEvs$ then $\aTr{\cEvs}{\bForm}
  \rimplies \aTr{\bEvs}{\bForm}$.

  We write $\aTr{}{\bForm}$ as an abbreviation of $\aTr{\aEvs}{\bForm}$.
\end{definition}

\begin{definition}
  \label{def:pomset}
  A \emph{pomset with predicate transformers} over $\Act$
  is a tuple $(\aEvs, \labeling, \labelingForm, \aTr{}{}, \aTerm, {\rrfx}, {\le})$ where
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
    \makecounter{BE}
  \item \label{pom-E} \makecounter{E}
    $\aEvs\subseteq\AllEvents$ is a set of \emph{events},
    \makecounter{Blambda}
  \item \label{pom-lambda} \makecounter{lambda}
    $\labeling: \aEvs \fun \Act$ defines a \emph{label} for each event,
    \makecounter{Bkappa}
  \item \label{pom-kappa} \makecounter{kappa}
    $\labelingForm:\aEvs\fun\Formulae$ defines a \emph{precondition} for each event, such that
    \begin{enumerate}
    \item \label{pom-kappa-sat}
      $\labelingForm(\aEv)$ is satisfiable,
    \end{enumerate}
    \makecounter{Btau}
  \item \label{pom-tau} \makecounter{tau}
    $\aTr{}{}:2^{\AllEvents}\fun\Formulae \fun\Formulae$ is a \emph{family of predicate transformers} over $\aEvs$, 
    \makecounter{Bterm}
  \item \label{pom-term} \makecounter{term}
    $\aTerm:\Formulae$ is a \emph{termination condition}, such that 
    \begin{enumerate}
    \item \label{pom-term-tau}
      $\aTerm\rimplies\aTr{}{\TRUE}$,
    \end{enumerate}
    \makecounter{Brf}
  \item \label{pom-rf} \makecounter{rf}
    ${\rrfx} \subseteq \aEvs\times\aEvs$ is an injective relation capturing
    \emph{reads-from}, such that 
    % \end{enumerate}
    % A pomset is a \emph{candidate} if there is an injective relation
    % ${\rrfx} : \aEvs\times\aEvs$, capturing \emph{reads-from}, such that
    \begin{enumerate}
      % \begin{enumerate}[,label=(\textsc{i}\arabic*),ref=\textsc{i}\arabic*]
      % \item \label{rf-injective}
      %   if $\bEv\xrfx\aEv$ and $\cEv\xrfx\aEv$ then $\bEv=\cEv$, that is, ${\rrfx}$ is injective,
    \item \label{pom-rf-match}
      if $\bEv\xrfx\aEv$ then $\labeling(\bEv) \rmatches \labeling(\aEv)$,
      % \item \label{rf-block}
      %   if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\le\bEv$ or $\aEv\le\cEv$.
      % \item \label{rf-le}
      %   if $\bEv\xrfx\aEv$ then $\bEv\le\aEv$.
    \end{enumerate}
    \makecounter{Ble}
  \item \label{pom-le} \makecounter{le}
    ${\le} \subseteq \aEvs\times\aEvs$, is a partial order capturing
    \emph{causality}, such that
    \begin{enumerate}
    \item \label{pom-le-match}
      if $\bEv\xrfx\aEv$ then either $\bEv\le\aEv$ or $\aEv\le\bEv$,
    \item \label{pom-le-block}
      if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\le\bEv$ or $\aEv\le\cEv$.
    \end{enumerate}
  \end{enumerate}
  A pomset is \emph{complete} if
  % \begin{multicols}{2}
  \begin{enumerate}[,label=(\textsc{c}\arabic*),ref=\textsc{c}\arabic*]
    \setcounter{enumi}{\value{Blambda}}
  \item \label{top-rf}
    if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$,
    \setcounter{enumi}{\value{Bkappa}}
  \item \label{top-kappa}
    $\labelingForm(\aEv)$ is a tautology (for every $\aEv\in\aEvs$),
    \setcounter{enumi}{\value{Bterm}}
  \item \label{top-term}
    $\aTerm$ is a tautology.
  \end{enumerate}
  % \end{multicols}
  % \labeltext[\textsc{t}1]{(\textsc{t}1)}{top-term} $\aTerm$ is a tautology and \labeltext[\textsc{t}2]{(\textsc{t}2)}{top-ev} for every $\aEv\in\aEvs$,
  % % $\labelingForm(\aEv)$ is a tautology and
  % % if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$.
  % % \begin{multicols}{2}
  % \begin{enumerate}[label=(\textsc{t}\arabic*),ref=\textsc{t}\arabic*]
  %   \setcounter{enumi}{2}
  % \item[]
  %   \begin{enumerate}[leftmargin=0pt]
  %   \item \label{top-kappa}
  %     $\labelingForm(\aEv)$ is a tautology,    
  %   \item \label{top-rf}
  %     if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$.
  %   \end{enumerate}
  % \end{enumerate}
  % % \end{multicols}
\end{definition}
\input{fig-seq.tex}
\input{fig-sem.tex}

We give the semantics of programs $\sembase{}$ in \reffig{fig:sem}.

Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.
% Let $\Pom$ be the set of all pomsets.

The model has seven components, which can be daunting at first glance.  To
aid the reader, we use consistent numbering throughout. For example, item $7$
always refers to the order relation.

The core of the model is a pomset, which includes a set of events
\eqref{pom-E}, a labeling \eqref{pom-lambda}, and an order \eqref{pom-le}.
We also include the \emph{reads-from} relation explicitly in the model
\eqref{pom-rf}.

On top of this basic structure, \ref{pom-kappa}--\ref{pom-term} add a layer
of logic.  For each pomset, \ref{pom-term} provides a termination condition.
For each event in a pomset, \ref{pom-kappa} provides a precondition.  For
each set of events in a pomset, \ref{pom-tau} provides a predicate
transformer.  Sequential dependency is calculated by $\labelingForm'_2$ in
the semantics of sequential composition.

Before discussing the details of the model, we note that the semantics
satisfies the expected monoid laws and is closed with respect to
\emph{augmentation}.  Augments include more order and stronger formulae; in
examples, we typically consider pomsets that are augment-minimal.  One
intuitive reading of augment closure is that adding order can only cause
preconditions to weaken.
\begin{lemma}
  \label{lem:monoid}
  \begin{enumerate*}[label=(\alph*),ref=\alph*]
  \item \label{monoid:unit}
    \begin{math}
      \aPSS
      =
      \xLPARP{\aPSS}{\sSKIP}
      =
      \xSEMIP{\aPSS}{\sSKIP}
      =
      \xSEMIP{\sSKIP}{\aPSS}.
    \end{math}

  \\\item \label{monoid:par}
    \begin{math}
      \xLPAR{\xLPARP{\aPSS_1}{\aPSS_2}}{\aPSS_3}
      =
      \xLPAR{\aPSS_1}{\xLPARP{\aPSS_2}{\aPSS_3}}.
    \end{math}

  \\\item \label{monoid:seq}
    \begin{math}
      \xSEMI{\xSEMIP{\aPSS_1}{\aPSS_2}}{\aPSS_3}
      =
      \xSEMI{\aPSS_1}{\xSEMIP{\aPSS_2}{\aPSS_3}}.
    \end{math}

  \\\item
    \begin{math} \label{monoid:ifelse:if:if}
      \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
      =
      \xSEMI{
        \xIFTHEN{\aForm}{\aPSS_1}{}
      }{
        \xIFTHEN{\lnot\aForm}{\aPSS_2}{}
      }
      =
      \xSEMI{
        \xIFTHEN{\lnot\aForm}{\aPSS_2}{}
      }{
        \xIFTHEN{\aForm}{\aPSS_1}{}
      }.
    \end{math}

  \\\item \label{monoid:if:dead}
    \begin{math}
      \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
      =
      \aPSS_1
    \end{math}
    if $\aForm$ is a tautology.

  \\\item \label{monoid:if:if}
    \begin{math}
      \xIFTHEN{\aForm}{
        \xIFTHEN{\bForm}{\aPSS}{}
      }{}
      =
      \xIFTHEN{\aForm\land\bForm}{\aPSS}{}.
    \end{math}

  \\\item \label{monoid:if:seq}
    \begin{math}
      \xIFTHEN{\aForm}{
        \xSEMI{\aPSS_1}{\aPSS_3}
      }{
        \xSEMI{\aPSS_2}{\aPSS_3}
      }
      \supseteq
      \xSEMI{
        \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
      }{
        \aPSS_3
      }.
    \end{math}

  \\\item \label{monoid:seq:if}
    \begin{math}
      \xIFTHEN{\aForm}{
        \xSEMI{\aPSS_1}{\aPSS_2}
      }{
        \xSEMI{\aPSS_1}{\aPSS_3}
      }
      \supseteq
      \xSEMI{
        \aPSS_1
      }{
        \xIFTHEN{\aForm}{\aPSS_2}{\aPSS_3}
      }.
    \end{math}

  \\\item \label{monoid:if:elim}
    \begin{math}
      \xIFTHEN{\aForm}{\aPSS}{\aPSS}
      \supseteq
      \aPSS.
    \end{math}
  \end{enumerate*}      
  \vspace{-.5\baselineskip}
  \begin{proof}
    Straightforward calculation.
    \eqref{monoid:unit} requires \ref{pom-term-tau} for
    the termination condition in $\xSEMIP{\aPSS}{\sSKIP}$.

    \eqref{monoid:seq} requires both
    conjunction closure (\ref{tr-and}, for the termination condition) and disjunction
    closure (\ref{tr-or}, for the predicate transformers themselves).

    \eqref{monoid:ifelse:if:if} requires \ref{seq-le-delays} not impose order
    when $\labelingForm_1(\bEv) \land \labelingForm_2(\aEv)$ is
    unsatisfiable, which in turn requires that $\labelingForm$ calculates
    \emph{weakest} preconditions, rather than simple preconditions (see
    \textsection\ref{sec:if:seq}).

    \eqref{monoid:if:dead} requires \ref{pom-kappa-sat}.

    In \textsection\ref{sec:semca}, we refine the semantics to validate the
    reverse inclusions for \eqref{monoid:if:seq}, \eqref{monoid:seq:if}, and
    \eqref{monoid:if:elim}.
  \end{proof}
\end{lemma}
\begin{definition}
  \label{def:augment}
  $\aPS_2$ is an \emph{augment} of $\aPS_1$ if
  \begin{multicols}{4}
    \begin{enumerate}
    \item $\aEvs_2=\aEvs_1$,
    \item $\labelingAct_2(\aEv)=\labelingAct_1(\aEv)$,
    \item $\labelingForm_2(\aEv) \riff \labelingForm_1(\aEv)$,
    \item $\aTr[2]{\bEvs}{\bForm}\riff \aTr[1]{\bEvs}{\bForm}$,
    \item $\aTerm[2] \riff \aTerm[1]$,
    \item ${\rrfx_2}\supseteq{\rrfx_1}$,
    \item ${\le_2}\supseteq{\le_1}$.
    \end{enumerate}
  \end{multicols}
\end{definition}
\begin{lemma}
  % Suppose $\aPS_1\in\sembase{\aCmd}$.
  If $\aPS_1\in\sembase{\aCmd}$ and $\aPS_2$  augments $\aPS_1$ then $\aPS_2\in\sembase{\aCmd}$.
  % \item If $\aPS_2$ is a downset of $\aPS_1$ then $\aPS_2\in\sembase{\aCmd}$.
  % \end{lemma}

  \vspace{-.5\baselineskip}
  \begin{proof}
    Induction on the definition of $\sembase{}$.
  \end{proof}
\end{lemma}





% \begin{definition}
%   Suppose $\aRel_1:\aEvs_1\times\aEvs_1$ and $\aRel_2:\aEvs_2\times\aEvs_2$.
%   We say $\aRel \rextendsdef{\aRel_1}{\aRel_2}$ if
%   $\aRel\supseteq (\aRel_1\cup \aRel_2)$ and
%   $\aRel\cap(\aEvs_1\times \aEvs_1) = \aRel_1$ and
%   $\aRel\cap(\aEvs_2\times \aEvs_2) = \aRel_2$.
% \end{definition}

% We include empty sets as prep for adding while loops.


% In diagrams, we use different colors for arrows.  We distinguish
% $\rrfx$ edges that are included in order from those that are not.
% \begin{itemize}
% \item \makebox{$\aEv\xrf\bEv$} arises from $\rrfx$, where $\aEv\le\bEv$,
% \item \makebox{$\aEv\xrfint\bEv$} arises from $\rrfx$, where $\lnot(\aEv\le\bEv)$.
% \end{itemize}
% To help the reader understand why order is included, we also different colors
% for arrows induced by order.  We adopt the following conventions:
% \begin{itemize}  
%   % \item relaxed accesses are blue, with a single border,
%   % \item synchronized accesses are red, with a double border,
%   % \item \makebox{$\aEv\xrf\bEv$} arises from fulfillment, where $\aEv$ \emph{matches} $\bEv$,
%   % \item \makebox{$\aEv\xwk\bEv$} arises either from fulfillment, where $\aEv$
%   %   \emph{blocks} $\bEv$, or from prefixing, where $\aEv$ was prefixed before
%   %   $\bEv$ and their actions \emph{conflict},
% \item \makebox{$\aEv\xwk\bEv$} arises from \emph{fulfillment},
% \item \makebox{$\aEv\xpo\bEv$} arises from control/data/address \emph{dependency},
% \item \makebox{$\aEv\xsync\bEv$} arises from \emph{synchronized access}.
% \end{itemize}



\subsection{Pomsets}
\label{sec:ex:pomset}

We first explain the core of model, ignoring the logic (rules 3--5).
%We defer the discussion of $\sLET{}{}$ to \textsection\ref{sec:ex:data}.
We defer discussion of $\sIF{}$ to \textsection\ref{sec:ex:control}.

Reads, writes, and fences map to pomsets with at most one event.  $\SKIP$
maps to the empty pomset.  Ignoring the logic, the definitions are
straightforward.  Note only that $\sembase{\PW{x}{1}}$ can write any value
$\aVal$; the fact that $\aVal$ must be $1$ is captured in the logic (see
\textsection\ref{sec:ex:term}).

The structural rules combine pomsets:  Parallel composition is disjoint
union, inheriting labeling, order and $\rrfx$ from the two sides.  Any
$\rrfx$ edges added between the two sides must also be added to the order
(\ref{par-le-rf1} and \ref{par-le-rf2}).
% 
Sequential composition is similar, with two changes: \ref{seq-E} does not
require disjointness (see \textsection\ref{sec:ex:term}), and
\ref{seq-le-delays} may require order (see example \ref{pub}, below).

Note that reads-from implies order.
\begin{lemma}
  \label{lem:rf:implies:le}
  For any $\aPS$ in the range of $\sembase{}$, $\bEv\xrfx\aEv$ implies
  $\bEv\le\aEv$.

  \vspace{-.5\baselineskip}
  \begin{proof}
    Induction on the definition of $\sembase{}$, using \ref{par-le-rf1}, \ref{par-le-rf2}, and \ref{seq-le-rf}.
  \end{proof}
\end{lemma}
In top-level pomsets, every read must have a matching write in $\rrfx$
\eqref{top-rf}.  Together with \ref{pom-le-match} and \ref{pom-le-block}, the lemma
guarantees that reads are \emph{fulfilled} at top-level, as in
\cite[\textsection 2.7]{DBLP:journals/pacmpl/JagadeesanJR20}.\footnote{The
  basic model would be the same if we move $\rrfx$ from the model itself to
  be existentially quantified in the definition of top-level pomset, along
  with \ref{pom-le-match} and \ref{pom-le-block}.  This was the approach of
  \citeauthor{DBLP:journals/pacmpl/JagadeesanJR20} We include $\rrfx$
  explicitly for use in \textsection\ref{sec:arm2}, where we introduce a
  variant semantics $\frf{\semrr{}}$ for which \reflem{lem:rf:implies:le}
  fails.}

From \refdef{def:actions}, recall that $\aAct \rdelaysdef \bAct$ if
$\aAct\eqreorderco\bAct$ or $\aAct\reorderra\bAct$ or
$\aAct\eqreordersc\bAct$.  \ref{seq-le-delays} guarantees that sequential
order is enforced between conflicting accesses of the same location
($\eqreorderco$), into a release and out of an acquire ($\reorderra$), and
between SC accesses ($\eqreordersc$).  Combined with the fulfillment
requirements (\ref{pom-le-match}, \ref{pom-le-block} and \reflem{lem:rf:implies:le}),
these ensure coherence, publication, subscription and other idioms.  For
example, consider the following:\footnote{We use different colors for arrows representing order:
  \begin{itemize}  
  \item \makebox{$\bEv\xpo\aEv$} arises from control/data/address \emph{dependency} (\ref{seq-kappa}, definition of $\labelingForm'_2(\bEv)$),
  \item \makebox{$\bEv\xsync\aEv$} arises from $\reorderra$ or $\eqreordersc$ \eqref{seq-le-delays},
  \item \makebox{$\bEv\xwki\aEv$} arises from $\eqreorderco$ \eqref{seq-le-delays},
  \item \makebox{$\bEv\xrf\aEv$} arises from \emph{reads-from} \eqref{pom-le-match},
  %\item \makebox{$\bEv\xsyncsc\aEv$} arises from \emph{strong fencing} \eqref{cand-lesync-sc},
  \item \makebox{$\bEv\xwk\aEv$} arises from \emph{blocking} \eqref{pom-le-block}.
  \end{itemize}
  In \textsection\ref{sec:arm2}, it is possible for $\rrf$ to contradict
  $\le$.  In this case, we use a dotted arrow for $\rrf$: $\bEv\xrfint\aEv$
  indicates that $\aEv\le\bEv$.}
\begin{gather*}
  \taglabel{pub}
  \begin{gathered}    
    \PW{x}{0}\SEMI 
    \PW{x}{1}\SEMI \PW[\mREL]{y}{1} \PAR \PR[\mACQ]{y}{r}\SEMI \PR{x}{s}
    \\[-.4ex]
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wx0}{\DW{x}{0}}{}
        \event{wx1}{\DW{x}{1}}{right=of wx0}
        \event{wy1}{\DW[\mREL]{y}{1}}{right=of wx1}
        \event{ry1}{\DR[\mACQ]{y}{1}}{right=2.5em of wy1}
        \event{rx0}{\DR{x}{0}}{right=of ry1}
        \sync{wx1}{wy1}
        \sync{ry1}{rx0}
        \rf{wy1}{ry1}
        \wk[out=170,in=10]{rx0}{wx1}
        \wki{wx0}{wx1}
      \end{tikzinline}}
  \end{gathered}
\end{gather*}
The execution is disallowed due to the cycle.  All of the order shown is
required at top-level: The intra-thread order comes from \ref{seq-le-delays}:
$\DWP{x}{0}\xwki \DWP{x}{1}$ is required by $\eqreorderco$.
$\DWP{x}{1}\xsync \DWP[\mREL]{y}{1}$ and $\DRP[\mACQ]{y}{1}\xsync \DRP{x}{0}$ are
required by $\reorderra$.  The cross-thread order is required by fulfillment:
\ref{top-rf} requires that all top-level reads are in the image of $\xrfx$.
\ref{pom-le-match} ensures that $\DWP[\mREL]{y}{1}\xrfx \DRP[\mACQ]{y}{1}$, and
\reflem{lem:rf:implies:le} subsequently ensures that
$\DWP[\mREL]{y}{1}\le \DRP[\mACQ]{y}{1}$.  The \emph{antidependency}
$\DRP{x}{0}\xwk \DWP{x}{1}$ is required by \ref{pom-le-block}.  (Alternatively,
we could have $\DWP{x}{1}\xwk \DWP{x}{0}$, again resulting in a cycle.)

The semantics gives the expected results for store buffering and load buffering,
as well as litmus tests involving fences and SC access.  The model of
coherence is weaker than C11, in order to support common subexpression
elimination, and stronger than Java, in order to support local reasoning
about data races.  See
\cite[\textsection3.1]{DBLP:journals/pacmpl/JagadeesanJR20} for a discussion.

In the structural rules $\sSEMI{}{}$ and $\sIF{}$, we say that
$\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ \emph{coalesce} if $\bEv=\aEv$.

\ref{seq-E} allows \emph{mumbling} \cite{DBLP:journals/iandc/Brookes96} by
coalescing events.  For example
\begin{math}
  \sembase{\PW{x}{1} \SEMI \PW{x}{1}}
\end{math}
includes the singleton pomset
\begin{tikzinlinesmall}[node distance=.5em and 1.5em]
  \event{a1}{\DW{x}{1}}{}
\end{tikzinlinesmall}.  From this it is easy to see that
\begin{math}
  \sembase{\PW{x}{1}\SEMI\PW{x}{1}}
  \supseteq
  \sembase{\PW{x}{1}}
\end{math}
is a valid refinement.  It is equally obvious that
\begin{math}
  \sem{\PW{\aLoc}{1}} 
  \not\supseteq
  \sem{\PW{\aLoc}{1} \SEMI \PW{\aLoc}{1}}
\end{math}
is not a valid refinement, since the latter includes a two-element pomset,
but the former does not.\footnote{These are distinguished by the context:
  \begin{math}
    \hole{} \PAR
    \PR{x}{r} \SEMI
    \PW{x}{2} \SEMI
    \PR{x}{s}\SEMI
    \IF{\aReg {=} \bReg} \THEN \PW{\cLoc}{1} \FI.
  \end{math}}


\subsection{Termination}
\label{sec:ex:term}

In top-level pomsets, \ref{top-term} requires that $\aTerm$ is a tautology,
capturing termination.  Terminated pomsets are often called \emph{complete},
whereas nonterminated pomsets are \emph{incomplete}.

Ignoring predicate transformers, the structural rules, \ref{par-term} and
\ref{seq-term}, take $\aTerm$ to be $\aTerm_1\land\aTerm_2$.  This is as
expected: the program terminates if both subprograms terminate.

The interesting rules are $\sLOAD{}{}$, $\sFENCE{}$, and $\sSTORE{}{}$.


In $\sLOAD{}{}$, there is no restriction on $\aTerm$ for relaxed reads.  From
this, it is easy to see that
\begin{math}
  \sembase{\PR{x}{r}}
  \supseteq
  \sembase{\SKIP}
\end{math}
is a valid refinement (where the default mode is $\mRLX$).

In $\sFENCE{}$, instead, \ref{fence-term} ensures that all fences are included at
top-level.  This also ensures
$\sembase{\PF{\amode}}\not\supseteq\sembase{\IF{\aExp}\THEN\PF{\amode}\FI}$,
since $\sembase{\IF{\aExp}\THEN\PF{\amode}\FI}$ includes the empty set with
termination condition $\lnot\aExp$, but $\sembase{\PF{\amode}}$ can only
include the empty set with termination condition $\FALSE$.

In $\sSTORE{}{}$, \ref{write-term-empty} is similar.  In addition,
\ref{write-term-nonempty} ensures that top-level pomsets do not include bogus
writes.  Suppose $\aPS\in\sembase{\PW{x}{1}}$.  As we noted above, $\aPS$ can
include $(1{=}\aVal\mid\DW{x}{\aVal})$, for any value $\aVal$.  At top-level,
however, \ref{write-term-nonempty} requires that $\aTerm$ implies
$1{=}\aVal$.  In this case, \ref{pom-kappa-sat} would filter the pomset,
since preconditions must be satisfiable.  However, unsatisfiable writes can be become satisfiable via
merging:
% Nonetheless, it is important that
% \ref{write-term-nonempty} specifies $\aTerm\riff\aExp{=}\aVal$ rather than
% $\aTerm\riff\TRUE$, since 
\begin{align*}
  \begin{gathered}
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a}{\DW{x}{1}}{}      
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{b}{2{=}3\mid\DW{x}{3}}{}      
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \IF{\aExp}\THEN\PW{x}{3}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{c}{\aExp\mid\DW{x}{3}}{}      
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
By merging, the semantics allows the following:
\begin{align*}
  \begin{gathered}
    \PW{x}{1}
    \SEMI
    \PW{x}{2}
    \SEMI
    \IF{\aExp}\THEN\PW{x}{3}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a}{\DW{x}{1}}{}      
        \event{c}{\aExp\mid\DW{x}{3}}{right=of a}
        \wki{a}{c}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
This pomset is incomplete, however, since $\aTerm\riff2{=}3$.

\subsection{Data Dependencies, Preconditions, and Predicate Transformers}
\label{sec:ex:data}

% Predicate transformers affect preconditions in the definition of
% $\labelingForm'_2$, which is used in \ref{seq-kappa2} and \ref{seq-kappa12}
% to calculate dependencies.  In this subsection we ignore predicate
% transformers, taking $\labelingForm'_2=\labelingForm_2$.

In top-level pomsets, \ref{top-kappa} requires that every precondition
$\labelingForm(\aEv)$ is a tautology.

Preconditions are discharged during sequential composition by applying
predicate transformers $\aTr[1]{}{}$ from the left to preconditions
$\labelingForm_2(\aEv)$ on the right.  The specific rules are
\ref{seq-kappa2} and \ref{seq-kappa12}, which use the transformed predicate
$\labelingForm'_2(\aEv)=\aTr[1]{\Cdown{\aEv}}{\labelingForm_2(\aEv})$, where
$\Cdown{\aEv}=\{ \cEv \mid \cEv \lt \aEv \}$ is the set of events that
precede $\aEv$ in causal order.  We call $\Cdown{\aEv}$ the \emph{dependent
  set} for $\aEv$.  Then $\aEvs\setminus(\Cdown{\aEv})$ is the
\emph{independent set}. % for $\aEv$.

% Sequential composition uses the usual rule for composition of predicate
% transformers (but preserving the indexing set). For the pomset, we take the
% union of their events, preserving actions, but crucially in
% cases~\ref{seq-kappa2} and~\ref{seq-kappa12} we apply a predicate transformer
% $\aTr[1]{\cEvs}{}$ from the left-hand side to a precondition
% $\labelingForm_2(\aEv)$ from the right-hand side to build the precondition
% $\labelingForm'_2(\aEv)$.  The indexing set $\cEvs$ for the predicate
% transformer is $\{ \cEv\mid \cEv<\aEv \}$, so can depend on the causal order.


Before looking at the details, it is useful to have a high-level view of how
nontrivial preconditions and predicate transformers are introduced.  (We
discuss address dependencies in \textsection\ref{sec:addr}.)
\begin{multicols}{2}
  Preconditions are introduced in: 
  \begin{itemize}
  \item[\eqref{seq-kappa-release}] for release actions,
  \item[\eqref{if-kappa}] for control dependencies, 
  \item[\eqref{write-kappa}] for data dependencies on writes.
  \end{itemize}

  Predicate transformers are introduced in:
  \begin{itemize}
  \item[\eqref{read-tau-dep}] for reads in the dependent set,
  \item[\eqref{read-tau-ind}] for reads in the independent set,
  \item[\eqref{write-tau}] for writes.
  \end{itemize}
  % \item These are glued together in \ref{seq-kappa}.
  %   \begin{itemize}
  %   \item \ref{seq-kappa2}  handles non-coalescing events,
  %   \item \ref{seq-kappa12} handles coalescing events.
  %   \end{itemize}
\end{multicols}


The rules track dependencies.  We discuss data dependencies \eqref{write-kappa}
here and control dependencies \eqref{if-kappa} in
\textsection\ref{sec:ex:control}.  Unless otherwise noted, we assume pomsets
are \emph{complete} and \emph{augment-minimal}.  We do not discuss
\ref{seq-kappa-release} further.  It simply ensures that all writes are
present before a release, even for incomplete pomsets (see
\textsection\ref{sec:ex:term}).

A simple example of a data dependency is a pomset
$\aPS\in\sem{\PR{x}{r}\SEMI \PW{y}{r}}$.  If $\aPS$ is complete, it must have
two events. Then $\sSEMI{}{}$ requires that there are %$\aVal,\bVal\in\Val$ and
$\aPS_1\in \sem{\PR{x}{r}}$ and $\aPS_2\in \sem{\PW{y}{r}}$ of the form:
\begin{align*}
  \tag{$\ddagger$}\label{eq2}
  \begin{gathered}
    \PR{x}{r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aVal{=}r\limplies\bForm}{}
        \eventr{\bEv}{a1}{\DR{x}{\aVal}}{left=of xd}
        \xform{xi}{(x{=}r\lor\aVal{=}r)\limplies\bForm}{left=.5em of a1}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\bForm[r/y]}{}
        \eventr{\aEv}{a2}{r{=}\bVal\mid\DW{y}{\bVal}}{left=of xd}      
        \xform{xi}{\bForm[r/y]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
First we consider the case that $\aVal=\bVal$.  For example if $\aVal=\bVal=1$, we have:
\begin{align*}
  \begin{gathered}
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{1{=}r\limplies\bForm}{}
        \eventr{\bEv}{a1}{\DR{x}{1}}{left=of xd}
        \xform{xi}{(x{=}r\lor1{=}r)\limplies\bForm}{left=.5em of a1}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\bForm[r/y]}{}
        \eventr{\aEv}{a2}{r{=}1\mid\DW{y}{1}}{left=of xd}      
        \xform{xi}{\bForm[r/y]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
For the read, the dependent transformer $\smash{\aTr[1]{\{\bEv\}}{}}$ is
$1{=}r\limplies\bForm$; the independent transformer $\aTr[1]{\emptyset}{}$ is
$(x{=}r\lor1{=}r)\limplies\bForm$.  These are determined by
\ref{read-tau-dep} and \ref{read-tau-ind}, respectively.  For the write, both
% the dependent transformer
$\smash{\aTr[2]{\{\aEv\}}{}}$ and
% the independent transformer
$\aTr[2]{\emptyset}{}$ are $\bForm[r/y]$, as are determined by
\ref{write-tau}.
%
Combining these into a single pomset, we have:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{1{=}r\limplies\bForm[r/y]}{}
        \eventr{\bEv}{a1}{\DR{x}{1}}{left=of xd}
        \xform{xi}{(x{=}r\lor1{=}r)\limplies\bForm[r/y]}{left=.5em of a1}
        \eventr{\aEv}{a2}{\aForm\mid\DW{y}{1}}{right=of xd}      
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
By \ref{seq-tau}, predicate transformers are determined by composition; thus
$\aTr{\bEvs}{\bForm}$ is $\aTr[1]{\bEvs}{\aTr[2]{\bEvs}{\bForm}}$.  Since the
transformer does not depend on whether the write is included, we do not draw
dependencies for the write in the diagram.

Turning to the precondition $\aForm$ on the write, recall that in order for
$\aEv$ to participate in a top-level pomset, the precondition $\aForm$ must
be a tautology at top-level.  There are two possibilities.
\begin{itemize}
\item If $\bEv\le\aEv$ then we apply the dependent transformer and
  $\aForm=(1{=}r\limplies r{=}1)$, a tautology.
\item If $\bEv\not\le\aEv$ then we apply the independent transformer and
  $\aForm=((x{=}r\lor1{=}r)\limplies r{=}1)$.  Under the assumption that $r$
  is bound, this is logically equivalent to $(x{=}1)$. (We make this more
  precise in \textsection\ref{sec:semreg}.)
\end{itemize}
Eliding transformers, the two outcomes are:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{x{=}1\mid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
The independent case on the right can only participate in a top-level pomset
if the precondition $(x{=}1)$ is discharged.  To do so, we must prepend a
pomset $\aPS_0$ that writes $1$ to $x$:
\begin{align*}
  \begin{gathered}
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\bForm[1/x]}{}
        \eventr{\cEv}{a2}{1{=}1\mid\DW{x}{1}}{left=of xd}      
        \xform{xi}{\bForm[1/x]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PW{x}{1}\SEMI \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\cEv}{a0}{1{=}1\mid\DW{x}{1}}{}
        \eventr{\bEv}{a1}{\DR{x}{1}}{right=of a0}
        \eventr{\aEv}{a2}{1{=}1\mid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Here we apply the predicate transformer $\aTr[0]{\emptyset}{}$ to $(x{=}1)$,
resulting in the tautology $(1{=}1)$.


Now suppose that $\aVal\neq\bVal$ in \eqref{eq2}.  Again there are two
possibilities, where we take $\aVal=0$ and $\bVal=1$:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{0}}{}
        \eventr{\aEv}{a2}{0{=}r\limplies r{=}1\mid\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{0}}{}
        \eventr{\aEv}{a2}{(x{=}r\lor0{=}r)\limplies r{=}1\mid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Assuming that $r$ is bound, both preconditions on $\aEv$ are unsatisfiable.

If a write is independent of a read, then clearly no order is imposed between
them.  For example, the precondition of $\aEv$ is a tautology in:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \PW{y}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{0{=}r\limplies\bForm[r/y]}{}
        \eventr{\bEv}{a1}{\DR{x}{0}}{left=of xd}
        \xform{xi}{(x{=}r\lor0{=}r)\limplies\bForm[r/y]}{left=.5em of a1}
        \eventr {\aEv}{a2}{(x{=}r\lor0{=}r)\limplies 1{=}1\mid\DW{y}{1}}{right=of xd}      
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
% \begin{gather*}
%   \PR{x}{r}\SEMI \PW{y}{1}
%   \\
%   \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
%       \event{rx0}{\DR{x}{0}}{}
%       \event{wy1}{1{=}1 \mid \DW{y}{1}}{right=of rx0}
%     \end{tikzinline}}
% \end{gather*}


\subsection{Control Dependencies}
\label{sec:ex:control}

In $\sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$, the predicate transformer
\eqref{if-tau} is
$(\aForm\land\aTr[1]{\bEvs}{\bForm})\lor(\neg\aForm\land\aTr[2]{\bEvs}{\bForm})$,
%$\aTerm \rimplies (\aForm\land\aTerm[1])\lor(\neg\aForm\land\aTerm[2])$,
which is the disjunctive equivalent of \citeauthor{DBLP:journals/cacm/Dijkstra75}'s
conjunctive formulation: $(\aForm\limplies\aTr[1]{\bEvs}{\bForm})\land(\neg\aForm\limplies\aTr[2]{\bEvs}{\bForm})$.
% $\aTerm \rimplies (\aForm\limplies\aTerm[1])\land(\neg\aForm\limplies\aTerm[2])$.
%  \citet{DBLP:journals/cacm/Dijkstra75} used conjunctive normal form.
%  Recall that
%  \href{https://www.wolframalpha.com/input/?i=\%28a+and+b\%29+or+\%28not+a+and+c\%29}{$(\aForm\land\cForm_1)\lor(\neg\aForm\land\cForm_2)$}
%  is logically equivalent to
%  \href{https://www.wolframalpha.com/input/?i=\%28a+implies+b\%29+and+\%28\%28not+a\%29+implies+c\%29}{$(\aForm\limplies\cForm_1)\land(\neg\aForm\limplies\cForm_2)$}. 

This semantics validates dead code elimination:
if $\aExp{\neq}0$ is a tautology then
\begin{math}
  \sem{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} \supseteq
  \sem{\aCmd_1}.
\end{math}
The reverse inclusion does not hold.

For events from $\aEvs_1$, \ref{if-kappa1} requires
$\aForm\land\labelingForm_1(\aEv)$. For events from $\aEvs_2$,
\ref{if-kappa2} requires $\lnot\aForm\land\labelingForm_2(\aEv)$.  For
coalescing events in $\aEvs_1\cap\aEvs_2$, \ref{if-kappa12} requires
$(\aForm\land\labelingForm_1(\aEv)) \lor
(\lnot\aForm\land\labelingForm_2(\aEv))$.  This semantics allows common code
to be lifted out of a conditional, validating the transformation
\begin{math}
  \sem{\IF{\aExp}\THEN\aCmd\ELSE\aCmd\FI} \supseteq
  \sem{\aCmd}.
\end{math}
%
The use of $\rextendsdef{}{}$ in \ref{if-le-extends} and \ref{if-rf-extends}
ensures that no new order is introduced between events in
$\aEvs_1\cap\aEvs_2$ when coalescing; see \textsection\ref{sec:arm2}.



By allowing events to coalesce, \ref{if-kappa12} ensures that control
dependencies are calculated semantically.  For example, consider
$\aPS\in\sem{\IF {r{=}1} \THEN \PW{y}{r} \ELSE \PW{y}{1}\FI}$, which is build
from $\aPS_1\in\sem{\PW{y}{r}}$ and $\aPS_2\in\sem{\PW{y}{1}}$ such as:
\begin{align*}
  \begin{gathered}
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventr{e}{wy1}{r{=}1 \mid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \PW{y}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventr{e}{wy1}{1{=}1 \mid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r{=}1} \THEN \PW{y}{r} \ELSE \PW{y}{1}\FI
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \eventr{e}{wy1}{(r{=}1 \limplies r{=}1) \land (r{\ne}1 \limplies 1{=}1) \mid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}  
\end{align*}
Here, the precondition in the combined pomset is a tautology, independent of $r$.


Control dependencies are eliminated in the same way as data dependencies.
For example:
\begin{align*}
  \begin{gathered}
    \PR{x}{r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{\aVal{=}r\limplies\bForm}{}
        \eventr{\bEv}{a1}{\DR{x}{\aVal}}{left=of xd}
        \xform{xi}{(x{=}r\lor\aVal{=}r)\limplies\bForm}{left=.5em of a1}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r{=}1}\THEN\PW{y}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xd}{r{=}1\limplies\bForm[1/y]}{}
        \eventr{\aEv}{a2}{r{=}1\mid\DW{y}{\bVal}}{left=of xd}      
        \xform{xi}{r{=}1\limplies\bForm[1/y]}{left=.5em of a2}
        \xo{a2}{xd}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Reasoning as we did for \eqref{eq2} in \textsection\ref{sec:ex:data}, there are two possibilities:
\begin{align*}
  \begin{gathered}
    \PR{x}{r}\SEMI \IF{r{=}1}\THEN\PW{y}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}
    \PR{x}{r}\SEMI \IF{r{=}1}\THEN\PW{y}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \eventr{\bEv}{a1}{\DR{x}{1}}{}
        \eventr{\aEv}{a2}{x{=}1\mid\DW{y}{1}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}

As another example, consider JMM causality test case 1 \cite{PughWebsite}:
\begin{gather*}
  \begin{gathered}
    \PW{x}{0} \SEMI
    (\PR{x}{r}\SEMI\IF{r{\geq}0}\THEN \PW{y}{1} \FI
    \PAR
    \PW{x}{y})
    \\[-1ex]
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wx0}{\DW{x}{0}}{}
        \event{rx1}{\DR{x}{1}}{right=3em of wx0}
        \event{wy1}{\aForm\mid\DW{y}{1}}{right=of rx1}
        \event{ry1}{\DR{y}{1}}{right=3em of wy1}
        \event{wx1}{\DW{x}{1}}{right=of ry1}
        \po{ry1}{wx1}
        \rf[out=-168,in=-12]{wx1}{rx1}
        \rf{wy1}{ry1}
        \wk[out=10,in=170]{wx0}{wx1}
        \wki{wx0}{rx1}
      \end{tikzinline}}
    % \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
    %   \event{wy1}{0\geq0\mid\DW{y}{1}}{}
    %   \event{rx1}{\DR{x}{1}}{left=of wy1}
    %   \event{wx0}{\DW{x}{0}}{below left=-.2em and 2em of rx1}
    %   \event{ry1}{\DR{y}{1}}{below=of rx1}
    %   \event{wx1}{\DW{x}{1}}{right=of ry1}
    %   \po{ry1}{wx1}
    %   \rf[out=140,in=-20]{wx1}{rx1}
    %   \rf{wy1}{ry1}
    %   \wk[out=10,in=155]{wx0}{wx1}
    %   \wk{wx0}{rx1}
    % \end{tikzinline}}
  \end{gathered}
\end{gather*}
The precondition $\aForm$ is
\begin{math}
  \PBR{(1{=}r \lor x{=}r) \limplies r{\geq}0}[0/x]
\end{math}
which is 
\begin{math}
  \PBR{(1{=}r \lor 0{=}r) \limplies r{\geq}0}
\end{math}
which is a tautology.



\subsection{Reordering Transformations}
\label{sec:ex:valid}

% When $\sem{\aCmd} \supseteq \sem{\aCmd'}$, we say that $\aCmd'$ is a
% \emph{valid transformation} of $\aCmd$.
% In this subsection, we show the
% validity of specific optimizations.  

The semantics validates many peephole optimizations.  Most apply only to
relaxed access.
\begin{align*}
  %\taglabel{RR}
  \sembase{\PR{\aLoc}{\aReg} \SEMI \PR{\bLoc}{\bReg}} &=
  \sembase{\PR{\bLoc}{\bReg}\SEMI \PR{\aLoc}{\aReg}} &&\text{if } \aReg\neq\bReg
  \\
  %\taglabel{WW}
  \sembase{\aLoc \GETS \aExp \SEMI \bLoc  \GETS \bExp} &=
  \sembase{\bLoc  \GETS \bExp\SEMI \aLoc \GETS \aExp} &&\text{if } \aLoc\neq\bLoc
  \\
  %\taglabel{RW}
  \sembase{\aLoc \GETS \aExp  \SEMI \PR{\bLoc}{\bReg}} &=
  \sembase{\PR{\bLoc}{\bReg} \SEMI\aLoc \GETS \aExp} &&\text{if }
  \aLoc\neq\bLoc \textand \bReg\not\in\free(\aExp)%\disjoint{{\free(\aLoc \GETS \aExp)}}{{\free(\PR{\bLoc}{\bReg})}}
\end{align*}
% \ref{WW}, \ref{RW} and \ref{RR} require that two sides of the semicolon
% have disjoint ids; for example, \ref{RW} requires $\disjoint{{\free(\aReg
% \GETS \aLoc)}}{{\free(\bLoc \GETS \bExp)}}$. 
% \ref{RR} requires either $\aReg\neq\bReg$ or
% $\aLoc=\bLoc$.  \ref{WW} and \ref{RW} require that two sides of the
% semicolon have disjoint ids; for example, \ref{RW} requires
% $\disjoint{{\free(\PR{\aLoc}{\aReg})}}{{\free(\bLoc \GETS \bExp)}}$.
%\ref{5} imposes no order between events in \ref{RR}--\ref{RW}.  %Note that \ref{RR} allows aliasing.
Here $\free(\aCmd)$ is the set of locations and registers that occur in $\aCmd$.
Using augmentation closure, the semantics also validates roach-motel reorderings \cite{SevcikThesis}.  For
example, on read/write pairs:
  \begin{align*}
    %\tag{\textsc{roach1}}\label{AcqW}
    \sembase{x^\amode \GETS \aExp \SEMI\PR{y}{\bReg}} &\supseteq
    \sembase{\PR{y}{\bReg}  \SEMI x^\amode\GETS \aExp} 
    &&\text{if }
    \aLoc\neq\bLoc \textand \bReg\not\in\free(\aExp)%\disjoint{{\free(\aLoc \GETS \aExp)}}{{\free(\PR{\bLoc}{\bReg})}}
    \\
    %\tag{\textsc{roach2}}\label{RelW}
    \sembase{x \GETS \aExp \SEMI\PR[\amode]{y}{\bReg}} &\supseteq
    \sembase{\PR[\amode]{y}{\bReg}  \SEMI x\GETS \aExp} 
    &&\text{if }
    \aLoc\neq\bLoc \textand \bReg\not\in\free(\aExp)%\disjoint{{\free(\aLoc \GETS \aExp)}}{{\free(\PR{\bLoc}{\bReg})}}
  \end{align*}


% As expected, %sequential and
% parallel composition commutes with conditionals and declarations, and
% conditionals and declarations commute with each other.  For example,
% we have \emph{scope extrusion}~\cite{Milner:1999:CMS:329902}:
% \begin{align*}
%   \taglabel{SE}
%   \sem{\aCmd\PAR \VAR\aLoc\SEMI\bCmd} &=
%   \sem{\VAR\aLoc\SEMI(\aCmd\PAR\bCmd)}
%   &&\text{if } \aLoc\not\in\free(\aCmd)
% \end{align*}

\subsection{Conditional and Coherence}
\label{sec:if:seq}

[This is out of date.]

\begin{lemma}
  \label{lem:if:seq}
  \begin{math}
    \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
    \supseteq
    \xSEMI{
      \xIFTHEN{\aForm}{\aPSS_1}{}
    }{
      \xIFTHEN{\lnot\aForm}{\aPSS_2}{}
    }
  \end{math}

  \begin{math}
    \xIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}
    \supseteq
    \xSEMI{
      \xIFTHEN{\lnot\aForm}{\aPSS_2}{}
    }{
      \xIFTHEN{\aForm}{\aPSS_1}{}
    }
  \end{math}
\end{lemma}

Reverse direction does not hold, due to \ref{seq-le-delays}.
\begin{enumerate}
\item[\eqref{seq-le-delays}] if
  $\labeling_1(\bEv) \rdelays \labeling_2(\aEv)$ then $\bEv\le\aEv$.  
\end{enumerate}
 An alternate phrasing might be attractive:
\begin{enumerate}
\item[{\labeltext[\textsc{s}7c$'$]{(\textsc{s}7c$'$)}{seq-le-delays'}}] if
  $\labeling_1(\bEv) \rdelays \labeling_2(\aEv)$ and
  $\labelingForm(\bEv)\land\labelingForm(\aEv)$ is satisfiable then
  $\bEv\le\aEv$.
\end{enumerate}
But \ref{seq-le-delays'} is incompatible with the ability to strengthen
preconditions using augment closure.  Consider the following.
\begin{align*}
  \begin{gathered}[t]
    \IF{r}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{r{\neq}0\mid\DW{x}{2}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a2}{            \DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a3}{            \DW{x}{2}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a4}{r{=}0   \mid\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
% \begin{align*}
%   \begin{gathered}[t]
%     \IF{r}\THEN\PW{x}{2}\FI
%     \SEQ
%     \PW{x}{1}
%     \SEQ
%     \PW{x}{2}
%     \SEQ
%     \IF{\BANG r}\THEN\PW{x}{1}\FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%         \event{a1}{r{\neq}0\mid\DW{x}{2}}{}
%         \event{a2}{            \DW{x}{1}}{right=of a1}
%         \event{a3}{            \DW{x}{2}}{right=of a2}
%         \event{a4}{r{=}0   \mid\DW{x}{1}}{right=of a3}
%       \end{tikzinline}}    
%   \end{gathered}
% \end{align*}
Augmenting the middle preconditions and then using sequential composition, we have:
\begin{align*}
  \begin{gathered}[t]
    \IF{r}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{r{\neq}0\mid\DW{x}{2}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{1}
    \SEQ
    \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a2}{r{\neq}0\mid\DW{x}{1}}{}
        \event{a3}{r{=}0   \mid\DW{x}{2}}{right=of a1}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a4}{r{=}0   \mid\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Note that \ref{seq-le-delays'} does not require any order between the two
writes of the middle pomset.
% \begin{align*}
%   \begin{gathered}[t]
%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
%         \event{a1}{r{\neq}0\mid\DW{x}{2}}{}
%         \event{a2}{r{=}0   \mid\DW{x}{1}}{right=of a1}
%         \event{a3}{r{\neq}0\mid\DW{x}{2}}{right=of a2}
%         \event{a4}{r{=}0   \mid\DW{x}{1}}{right=of a3}
%       \end{tikzinline}}    
%   \end{gathered}
% \end{align*}
Merging left and right, we have:
\begin{align*}
  \begin{gathered}[t]
    \IF{r}\THEN\PW{x}{2}\FI
    \SEQ
    \PW{x}{1}
    \SEQ
    \PW{x}{2}
    \SEQ
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{2}}{}
        \event{a4}{\DW{x}{1}}{right=of a1}
        \wki{a1}{a4}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
As shown by the following single-threaded code, allowing this outcome would violate \drfsc{}.
\begin{align*}
  \begin{gathered}[t]
    \PW{y}{1}
    \SEQ
    \PR{y}{r}
    \SEQ
    \IF{r}\THEN\PW{x}{2}\FI
    \SEQ
    \PW{x}{1}
    \SEQ
    \PW{x}{2}
    \SEQ
    \IF{\BANG r}\THEN\PW{x}{1}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{2}}{}
        \event{a4}{\DW{x}{1}}{right=of a1}
        \wki{a1}{a4}
        \event{b2}{\DR{y}{1}}{left=of a1}
        \event{b1}{\DW{y}{1}}{left=of b2}
        \rf{b1}{b2}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}

To validate the reverse direction of \reflem{lem:if:seq}, it may be tempting
to define the semantics using \emph{weakest} preconditions, rather than
preconditions.  But in this case the notion of program refinement could not be
simple set inclusion---for example, in general we would \emph{not} have
\begin{math}
  \aPSS_1
  \supseteq
  \xIFTHEN{\aForm}{\aPSS_1}{}.
\end{math}

As a result, we leave \reflem{lem:if:seq} as an inequation.  The equational
form may be valid using some notion of \emph{observational} or
\emph{contextual} refinement, but we do not pursue that here.

\subsection{Associativity and Skolemization}
\label{sec:ex:assoc}

The predicate transformers we have chosen for \ref{read-tau-dep} and
\ref{read-tau-ind} are different from the ones used traditionally, which are
written using substitution \jjr{}.  Attempting to write \ref{read-tau-dep} in
this style we would have:
\begin{enumerate}[topsep=0pt]
\item[{\labeltext[\textsc{r}4a$'$]{(\textsc{r}4a$'$)}{read-tau-dep-p}}]
  if $(\aEvs\cap\bEvs)\neq\emptyset$ then
  \begin{math}
    \aTr{\bEvs}{\bForm} \riff    
    \bForm[\aVal/\aReg]
  \end{math},    
\end{enumerate}
Recall that \ref{read-tau-empty} says that $\bForm$ must be independent of
$\aReg$ in order to appear in a top-level pomset: if $\aEvs=\emptyset$ then
\begin{math}
  \aTr{\bEvs}{\bForm} \riff
  % \PBR{\aVal{=}\aReg \lor \aLoc{=}\aReg} \limplies
  \bForm.
\end{math}
This choice for \ref{read-tau-empty} is forced by \refdef{def:family}, which
states that the predicate transformer for a small subset of $\aEvs$ must
imply the transformer for a larger subset.

Sadly, this definition fails associativity.

Consider the following, eliding transformers for the writes (``$\BANG$''
represents logical negation):
\begin{align*}
  \begin{gathered}[t]
    \PR{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{a}{\DR{y}{1}}{}
        \xform{xd}{1{=}r\limplies\bForm}{right=of a}
        \xform{xi}{(y{=}r\lor1{=}r)\limplies\bForm}{left=.5em of a}
        \xo{a1}{xd}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{\BANG r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{b}{r{=}0\mid\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{\BANG\BANG r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{b}{r{\neq}0\mid\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{0} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{b}{\DW{x}{0}}{}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
Coalescing the writes and associating to the right,
we have the following, since $(r{=}0 \lor r{\neq}0)\riff\TRUE$:
\begin{align*}
  \begin{gathered}[t]
    \PR{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{a}{\DR{y}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{\BANG r} 
    \SEMI \PW{x}{\BANG\BANG r} 
    \SEMI \PW{x}{0} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{b}{\DW{x}{1}}{}
        \event{c}{\DW{x}{0}}{right=of b}
        \wki{b}{c}
      \end{tikzinline}}    
  \end{gathered}
  &&
% \end{align*}  
% The precondition of $\DWP{x}{1}$ is a tautology, thus we have:
% \begin{align*}
  \begin{gathered}[t]
    \PR{y}{r}
    \SEMI (\PW{x}{\BANG r} 
    \SEMI \PW{x}{\BANG\BANG r} 
    \SEMI \PW{x}{0} )
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{a}{\DR{y}{1}}{}
        \event{b}{\DW{x}{1}}{right=of a}
        \event{c}{\DW{x}{0}}{right=of b}
        \wki{b}{c}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
The precondition of $\DWP{x}{1}$ is a tautology.
Associating to the left and the coalescing, instead:
\begin{align*}
  \begin{gathered}[t]
    \PR{y}{r}
    \SEMI \PW{x}{\BANG r} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{a}{\DR{y}{1}}{}
        \event{b}{(y{=}r\lor1{=}r)\limplies r{=}0\mid\DW{x}{1}}{right=of a}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \PW{x}{\BANG\BANG r} 
    \SEMI \PW{x}{0} 
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{b}{r{\neq}0\mid\DW{x}{1}}{}
        \event{c}{\DW{x}{0}}{right=of b}
        \wki{b}{c}
      \end{tikzinline}}    
  \end{gathered}
  &&
% \end{align*}  
% Sequencing and merging:
% \begin{align*}
  \begin{gathered}[t]
    (\PR{y}{r}
    \SEMI \PW{x}{\BANG r} )
    \SEMI (\PW{x}{\BANG\BANG r} 
    \SEMI \PW{x}{0} )
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1em]
        \event{a}{\DR{y}{1}}{}
        \event{b}{\aForm\mid\DW{x}{1}}{right=of a}
        \event{c}{\DW{x}{0}}{right=of b}
        \wki{b}{c}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
where $\aForm=((y{=}r\lor1{=}r)\limplies r{=}0)\lor (r{\neq}0)$.  The
precondition $\aForm$ is not a tautology.  In a top-level pomset, this forces
dependency order from $\DRP{y}{1}$ to $\DWP{x}{1}$.

Our solution is to Skolemize, replacing 
uses of $\bForm[\aVal/\aReg]$
by $(\aReg{=}\aVal)\limplies\bForm$,
for uniquely chosen $\aReg$.
%  We have proven associativity of
%  \refdef{def:pomsets-trans} in Agda.
The proof of associativity requires that predicate
transformers distribute through disjunction (\refdef{def:trans}).  The
attempt to define predicate transformers using substitution fails for
\ref{read-tau-empty} because the predicate transformer
$\aTr{}{\bForm}=(\forall\aReg)\bForm$ does not distribute through
disjunction:
\begin{math}
  \aTr{}{\bForm_1\lor \bForm_2}=
  (\forall r)(\bForm_1\lor \bForm_2)
  \neq
  ((\forall r)(\bForm_1)) \lor ((\forall r)(\bForm_2))
  = \aTr{}{\bForm_1} \lor \aTr{}{\bForm_2}
\end{math}.  Since $\aTr{}\bForm=(\forall\aReg)\bForm$ does not distribute
through disjunction, we use $\aTr{}\bForm=\bForm$ instead (which trivially
distributes through disjunction).  This change means we cannot use
substitution, since $\bForm$ does not imply $\bForm[\aVal/\aReg]$.
Fortunately, Skolemizing solves this problem, since $\bForm$ implies
$(\aReg{=}\aVal)\limplies\bForm$.


\subsection{Comparison with Weakest Preconditions}

We compare traditional transformers to the dependent-case transformers of
\reffig{fig:sem}. %; thus we consider only totally ordered executions.
% Because
% we only consider the dependent case, we drop the superscript $\aEvs$ on
% $\aTr{\aEvs}{}$ throughout this section.  We also assume that each register
% appears at most once in a program, as we did throughout
% \textsection\ref{sec:model}--\ref{sec:arm}.

Because of augment closure, we are not interested in isolating the
\emph{weakest} precondition.  Thus we think of transformers as Hoare triples.
In addition, all programs in our language are strongly normalizing, so we
need not distinguish strong and weak correctness.  In this setting, the Hoare
triple $\hoare{\aForm}{\aCmd}{\bForm}$ holds exactly when
$\aForm \limplies \fwp{\aCmd}{\bForm}$.

Hoare triples do not distinguish thread-local variables from shared
variables.  Thus, the assignment rule applies to all types of storage. The
rules can be written as on the left below:
\begin{align*}
\begin{aligned}
  \fwp{\PW{\aLoc}{\aExp}}{\bForm} &= \bForm[\aExp/\aLoc]
  \\
  \fwp{\LET{\aReg}{\aExp}}{\bForm} &= \bForm[\aExp/\aReg]
  \\
  \fwp{\PR{\aLoc}{\aReg}}{\bForm} &= \aLoc{=}\aReg\limplies\bForm
\end{aligned}
&&
\begin{aligned}
  \trd{\PW{\aLoc}{\aExp}}{\bForm} &= \bForm[\aExp/\aLoc]
  \\
  \trd{\LET{\aReg}{\aExp}}{\bForm} &= \bForm[\aExp/\aReg]
  \\
  \trd{\PR{\aLoc}{\aReg}}{\bForm} &= \aVal{=}\aReg\limplies\bForm &&
  \textwhere \labelingAct(\aEv)=\DR{\aLoc}{\aVal}
\end{aligned}
\end{align*}
Here we have chosen an alternative formulation for the read rule, which is
equivalent to the more traditional $\bForm[\aLoc/\aReg]$, as long as registers
are assigned at most once in a program.  Our predicate transformers for the
dependent case are shown on the right above.  Only the read rule differs from
the traditional one.

For programs where every register is bound and every read is fulfilled, our
dependent transformers are the same as the traditional ones.  Thus, when
comparing to weakest preconditions, let us only consider totally-ordered
executions of our semantics where every read could be fulfilled by prepending
some writes.  For example, we ignore pomsets of $\PW{x}{2}\SEMI\PR{x}{r}$
that read $1$ for $x$.

For example, let $\aCmd_i$ be defined:
% as follows.
\begin{align*}
  \aCmd_1&=\PR{x}{s}\SEMI\PW{x}{s{+}r}
  &  
  \aCmd_2&=\PW{x}{t}\SEMI\aCmd_1
  &  
  \aCmd_3&=\LET{t}{2}\SEMI\LET{r}{5}\SEMI\aCmd_2
\end{align*}
% \begin{itemize}
% \item
%   \begin{math}
%     \fwp{\LET{\aReg}{\aExp}}{\bForm} = \bForm[\aExp/\aReg]
%   \end{math}
% \item
%   \begin{math}
%     \fwp{\PR{\aLoc}{\aReg}\;\,}{\bForm} = %\bForm[x/r]
%     %     (\forall\bReg)
%     %     \aLoc{=}\bReg\limplies\bForm [\bReg/\aLoc]
%     \aLoc{=}\aReg\limplies\bForm
%   \end{math}
% \item
%   \begin{math}
%     \fwp{\PW{\aLoc}{\aExp}}{\bForm} = \bForm[\aExp/\aLoc]
%   \end{math}
% \end{itemize}
% General relation between Hoare triples and $\fwp{}{}$:
% \begin{itemize}
% \item $\hoare{\fwp{\aCmd}{\bForm}}{\aCmd}{\bForm}$,
% \item If $\hoare{\aForm}{\aCmd}{\bForm}$ and $\aCmd$ terminates when starting
%   in any state satisfying $\aForm$, then $\aForm \limplies \fwp{\aCmd}{\bForm}$.
% \end{itemize}
The following pomset appears in the semantics of $\aCmd_2$.  A pomset for
$\aCmd_3$ can be derived by substituting $[2/t,\allowbreak5/r]$.  A pomset
for $\aCmd_1$ can be derived by eliminating the initial write.
\begin{gather*}
  % \begin{gathered}[t]
  %   \PW{x}{3}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{c}{\DW{x}{3}}{}
  %     \xform{xd}{\bForm}{below=of c}
  %     \xo[xright]{c}{xd}
  %   \end{tikzinline}}
  % \end{gathered}
  % \qquad\quad
  % \begin{gathered}[t]
  %   \PR{x}{s}\SEMI\PW{x}{s{+}r}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{a}{\DR{x}{2}}{}
  %     \event{b}{2{=}s\limplies(s{+}r){=}7\mid\DW{x}{7}}{right=of a}%6.5em of a}
  %     \po{a}{b}
  %     \xform{xdd}{2{=}s \limplies \bForm[s{+}r/x]}{below right=.5em and -1em of a}
  %       %     \xform{xdd}{2{=}s \limplies \bForm[s{+}r/x]}{above=of a}
  %       %     \xform{xdi}{2{=}s \limplies \bForm[s{+}r/x]}{below=of a}
  %       %     \xform{xii}{(2{=}s\lor x{=}s)\limplies\bForm[s{+}r/x]}{above=of b}
  %       %     \xform{xid}{(2{=}s\lor x{=}s)\limplies\bForm[s{+}r/x]}{below=of b}
  %       %     \xo[xright]{a}{xdi}
  %       %     \xo[xright]{b}{xid}
  %     \xo[xright]{a}{xdd}
  %     \xo[xright]{b}{xdd}
  %   \end{tikzinline}}
  % \end{gathered}
  % \\[1ex]
  \begin{gathered}[t]
    % \LET{t}{2}\SEMI
    % \LET{r}{5}\SEMI
    \PW{x}{t}\SEMI
    \PR{x}{s}\SEMI\PW{x}{s{+}r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a}{\DR{x}{2}}{}
        \event{b}{2{=}s\limplies(s{+}r){=}7\mid\DW{x}{7}}{right=of a}
        \event{c}{t{=}2\mid\DW{x}{2}}{left=of a}
        \xform{xdd}{2{=}s \limplies \bForm[s{+}r/x]}{right=of b}%below right=.5em and -1em of a}
        %\xo{a}{xdd}
        \xo{b}{xdd}
        % \xo{c}{xdd}
        \po{a}{b}
        \rf{c}{a}
      \end{tikzinline}}
  \end{gathered}
\end{gather*}
The predicate transformers are:
% \begin{align*}
%   \fwp{\aCmd_1}{\bForm} &= x{=}s\limplies\bForm[s{+}r/x] 
%   \\
%   \fwp{\aCmd_2}{\bForm} &= t\,{=}s\limplies\bForm[s{+}r/x] 
%   \\
%   \fwp{\aCmd_3}{\bForm} &= 2{=}s\limplies\bForm[s{+}5/x] 
%   \\
%   \trd{\aCmd_1}{\bForm} = \trd{\aCmd_2}{\bForm} &= 2{=}s\limplies\bForm[s{+}r/x] 
%   \\
%   \trd{\aCmd_3}{\bForm} &= 2{=}s\limplies\bForm[s{+}5/x] 
% \end{align*}
\begin{scope}
  \small
  \begin{align*}
    \fwp{\aCmd_1}{\bForm} &= x{=}s\limplies\bForm[s{+}r/x] 
    &
    \trd{\aCmd_1}{\bForm} &= 2{=}s\limplies\bForm[s{+}r/x] 
    \\
    \fwp{\aCmd_2}{\bForm} &= t\,{=}s\limplies\bForm[s{+}r/x] 
    &
    \trd{\aCmd_2}{\bForm} &= 2{=}s\limplies\bForm[s{+}r/x] 
    \\
    \fwp{\aCmd_3}{\bForm} &= 2{=}s\limplies\bForm[s{+}5/x] 
    &
    \trd{\aCmd_3}{\bForm} &= 2{=}s\limplies\bForm[s{+}5/x] 
  \end{align*}
\end{scope}

% % Let $\rho:\Reg\fun\Val$ and $\chi:\Loc\fun\Val$ be substitutions.
% Let $\aState$ and $\rho$ range over substitutions $(\Reg\cup\Loc)\fun\Val$.
% Treating substitutions as states, the big-step operational semantics of
% programs can be defined as a relation $\bigstep{\aState}{\aCmd}{\bState}$.
% % Ie, $\aForm\aState$ implies $\bForm\bState$.
% \begin{align}
%   \label{wp1}
%   \bigstep{[5/r,2/x]}{\aCmd_1&}{[5/r,2/s,7/x]}
%   \\
%   \label{wp2}
%   \bigstep{[\NEG5/r,2/x]}{\aCmd_1&}{[\NEG5/r,2/s,\NEG3/x]}
% \end{align}

% Then the semantics of Hoare triples guarantees that if
% $\aForm\limplies\fwp{\aCmd}{\bForm}$, $\bigstep{\aState}{\aCmd}{\rho}$ and
% $\aForm\aState$ is a tautology then $\bForm\bState$ is a tautology.
% \begin{align*}
%   \fwp{\aCmd_1}{x{>}0} &= (x{+}r{>}0) 
% \end{align*}
% In \eqref{wp1}, the pre- and post-conditions are satisfied.
% In \eqref{wp2}, they are not.


% \begin{itemize}  
% \item Suppose $\bigstep{\aState}{\aCmd}{\rho}$ and $\aForm\limplies\fwp{\aCmd}{\bForm}$.\\
%   If $\aForm\aState$ is a tautology then $\bForm\bState$ is a tautology.\\
%   Ie, $\aForm\aState$ implies $\bForm\bState$.
% \item Suppose $\bigstep{\aState}{\aCmd}{\rho}$ and $\hoare{\aForm}{\aCmd}{\bForm}$.\\
%   If $\aForm\aState$ is a tautology then $\bForm\bState$ is a tautology.\\
%   Ie, $\aForm\aState$ implies $\bForm\bState$.
% \item Suppose $\bigstep{\aState}{\aCmd}{\rho}$ and $\aForm=\fwp{\aCmd}{\bForm}$.\\
%   $\aForm\aState$ is a tautology if and only if $\bForm\bState$ is a tautology.\\
%   Ie, $\aForm\aState$ iff $\bForm\bState$.
% % \item Weakest: If $\aForm'\aState$ is a tautology, then $\aForm$ implies $\aForm'$.
% \end{itemize}
% Weakest preconditions are \emph{sound} in that if $\aForm$ holds in the
% initial state $\aState$, then $\bForm$ holds in the final state $\bState$.
% Formally, 


\begin{comment}
  If $\aPS\in\sem{\aCmd}$ is top-level and quiescent then 
  $\aTr{\aEvs}{\bForm}$ implies $\fwp{\aCmd}{\bForm}$.

  For any substitution $\aSub=[{v_1/r_1},\ldots, {v_n/r_n}]$ there is some
  $\aPS\in\sem{\aCmd}$ %that is top-level and quiescent
  such that all preconditions in $\aPS\aSub$ are tautologies then 
  $\fwp{\aCmd}{\bForm}\aSub$
\end{comment}


% For a language where all programs are
% terminating, we have for any statement $\aCmd$:
% \begin{align*}
%   \hoare{\aForm}{\aCmd}{\bForm} 
%   \;\;\Leftrightarrow\;\;
%   \aForm \textimplies \fwp{\aCmd}{\bForm}
% \end{align*}
% Interpretation is that if $\aState\models\fwp{\aCmd}{\bForm}$ and
% $\bigstep{\aState}{\aCmd}{\rho}$
% then $\bState\models\bForm$.

% Let $\aCmd_0$ be
% \begin{math}
%   \PW{\aLoc_1}{\aVal_1}\SEMI\cdots\SEMI \PW{\aLoc_n}{\aVal_n}, 
% \end{math}
% such that $\fwp{\aCmd_0}{\aForm}$ is a tautology, and $\aLoc_i=\aLoc_j$
% implies $i=j$.

% Let $\aSub_\aPS=[{\aVal_1/\aLoc_1},\ldots, {\aVal_n/\aLoc_n}]$ be the final
% state of $\aPS$.

% Let $\aState$ and $\rho$ range over substitutions $\Loc\fun\Exp$.
% If we leave the registers free, we have:
% \begin{align}
%   \label{wp1x}
%   \bigstep{[2/x]}{\aCmd&}{[6/x]}
% \end{align}

% Using \refdef{def:pomsets-trans}:
% \begin{align*}
%   \begin{gathered}[t]
%     %     \PR{x}{s}\SEMI\PW{x}{s{+}r}
%     \PR{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%       \event{a}{\DR{x}{2}}{}
%       \xform{xi}{\bForm}{above=of a}
%       \xform{xd}{2{=}s \limplies \bForm}{below=of a}
%       \xo[xright]{a}{xd}
%     \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}[t]
%     \PW{x}{s{+}r}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%       \event{a}{(s{+}r){=}7\mid\DW{x}{7}}{}
%       \xform{xi}{\bForm}{above=of a}
%       \xform{xd}{\bForm}{below=of a}
%       \xo[xright]{a}{xd}
%     \end{tikzinline}}
%   \end{gathered}
% \end{align*}
% Composing
% \begin{align*}
%   \begin{gathered}[t]
%     \PR{x}{s}\SEMI\PW{x}{s{+}r}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%       \event{a}{\DR{x}{2}}{}
%       \event{b}{(s{+}r){=}7\mid\DW{x}{7}}{right=of a}
%       \xform{xdd}{2{=}s \limplies \bForm}{above=of a}
%       \xform{xdi}{2{=}s \limplies \bForm}{below=of a}
%       \xform{xii}{\bForm}{above=of b}
%       \xform{xid}{\bForm}{below=of b}
%       \xo[xright]{a}{xdi}
%       \xo[xright]{b}{xid}
%       \xo[xright]{a}{xdd}
%       \xo[xright]{b}{xdd}
%     \end{tikzinline}}
%   \end{gathered}
% \end{align*}

% Using \refdef{def:pomsets-lir}:
% \begin{align*}
%   \begin{gathered}[t]
%     %     \PR{x}{s}\SEMI\PW{x}{s{+}r}
%     \PR{x}{s}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%       \event{a}{\DR{x}{2}}{}
%       \xform{xi}{(2{=}s\lor x{=}s)\limplies \bForm}{above=of a}
%       \xform{xd}{2{=}s \limplies \bForm}{below=of a}
%       \xo[xright]{a}{xd}
%     \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}[t]
%     \PW{x}{s{+}r}
%     \\
%     \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%       \event{a}{(s{+}r){=}7\mid\DW{x}{7}}{}
%       \xform{xi}{\bForm[s{+}r/x]}{above=of a}
%       \xform{xd}{\bForm[s{+}r/x]}{below=of a}
%       \xo[xright]{a}{xd}
%     \end{tikzinline}}
%   \end{gathered}
% \end{align*}
% Composing

% For example, let $\aCmd_1=\PR{x}{r}$ and $\aCmd_2=\PW{x}{r{+}1}$ and
% $\aCmd=\aCmd_1\SEMI \aCmd_2$.
% \begin{align*}
%   \fwp{\aCmd_2}{x{>}1}&=(r{+}1{>}1) = (r{>}0)
%   \\
%   \fwp{\aCmd_1}{r{>}0}=\fwp{\aCmd_0}{x{>}1}&=(x{>}0)
% \end{align*}
% Let $\aPS_i\in\sem{\aCmd_i}$.
% \begin{align*}
%   \aTr[2]{\aEvs_2}{x{>}1}&=(r{+}1{>}1) = (r{>}0)
%   \\
%   \aTr[0]{\aEvs_0}{x{>}1}&=(0{=}\aReg \limplies r{>}0)
%   \\
%   \aTr[0]{\aEvs_0}{x{>}1}&=(1{=}\aReg \limplies r{>}0)
%   \\
%   \aTr[0]{\aEvs_0}{x{>}1}&=(2{=}\aReg \limplies r{>}0)
% \end{align*}

% \begin{proposition}
%   If $\aPS\in\sem{\aCmd}$ is top-level and quiescent then 
%   $\aTr{\aEvs}{\aForm}$ implies $\fwp{\aCmd}{\aForm}$.

%   For any substitution $\aSub=[{\aVal_1/\aReg_1},\ldots, {\aVal_n/\aReg_n}]$ there is some
%   $\aPS\in\sem{\aCmd}$ %that is top-level and quiescent
%   such that all preconditions in $\aPS\aSub$ are tautologies then 
%   $\fwp{\aCmd}{\aForm}\aSub$
% \end{proposition}

% \subsection{Fences}
% \label{sec:fences}


\subsection{Substitutions}
\label{sec:substitutions}

In $\sLOAD{}{}$, it is also possible to collapse $\aLoc$ and $\aReg$ via substitution:
\begin{enumerate}
\item[{\labeltext[\textsc{r}4a$'$]{(\textsc{r}4a$'$)}{read-tau-dep-sub}}]
  if $(\aEvs\cap\bEvs)\neq\emptyset$ then
  \begin{math}
    \aTr{\bEvs}{\bForm} \riff
    \aVal{=}\aReg
    \limplies \bForm[\aReg/\aLoc]
  \end{math},    
\item[{\labeltext[\textsc{r}4b$'$]{(\textsc{r}4b$'$)}{read-tau-ind-sub}}]
  if $\aEvs\neq\emptyset$ and $(\aEvs\cap\bEvs)=\emptyset$ then
  \begin{math}
    \aTr{\bEvs}{\bForm} \riff
    \PBR{\aVal{=}\aReg \lor \aLoc{=}\aReg} \limplies
    \bForm[\aReg/\aLoc],
  \end{math}
\item[{\labeltext[\textsc{r}4c$'$]{(\textsc{r}4c$'$)}{read-tau-empty-sub}}]
  if $\aEvs=\emptyset$ then
  \begin{math}
    \aTr{\bEvs}{\bForm} \riff
    % \PBR{\aVal{=}\aReg \lor \aLoc{=}\aReg} \limplies
    \bForm[\aReg/\aLoc],
  \end{math}
\end{enumerate}
Perhaps surprisingly, this semantics is incomparable with that of
\reffig{fig:sem}.  Consider the following:
\begin{gather*}
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a3}{r\land s\;\mathsf{even}\mid\DW{y}{1}}{}
      \event{a4}{r\land s\mid\DW{z}{1}}{right=of a3}
    \end{tikzinline}}
\end{gather*}
Prepending $\PRP{x}{s}$, we get the same result regardless of whether we
substitute $[s/x]$, since $x$ does not occur in either precondition.  Here
we show the independent case:
\begin{gather*}
  \PR{x}{s}\SEMI
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a2}{\DR{x}{2}}{}
      \event{a3}{(2{=}s\lor x{=}s)\limplies (r\land s\;\mathsf{even})\mid\DW{y}{1}}{right=of a2}
      \event{a4}{(2{=}s\lor x{=}s)\limplies (r\land s)\mid\DW{z}{1}}{right=of a3}
    \end{tikzinline}}
\end{gather*}
Since the preconditions mention $x$, prepending $\PRP{x}{r}$, we now get
different results depending on whether we perform the substitution.  Without
any substitution, we have:
\begin{gather*}
  \PR{x}{r}\SEMI
  \PR{x}{s}\SEMI
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\[-2ex]
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DR{x}{2}}{right=of a1}
      \event{a3}{1{=}r\limplies  (2{=}s\lor x{=}s)\limplies (r\land s\;\mathsf{even})\mid\DW{y}{1}}{right=of a2}
      \event{a4}{1{=}r\limplies  (2{=}s\lor x{=}s)\limplies (r\land s)\mid\DW{z}{1}}{right=of a3}
      \po[out=12,in=168]{a1}{a3}
      \po[out=10,in=170]{a1}{a4}
    \end{tikzinline}}
\end{gather*}
Prepending $\PWP{x}{0}$, which substitutes $[0/x]$, the precondition of
$\DWP{y}{1}$ becomes
$(1{=}r\limplies (2{=}s\lor0{=}s)\limplies (r\land s\;\mathsf{even}))$, which
is a tautology, whereas the precondition of $\DW{z}{1}$ becomes
$(1{=}r\limplies(2{=}s\lor0{=}s)\limplies (r\land s))$, which is not.  In
order to be top-level, $\DWP{z}{1}$ must be dependency ordered after
$\DRP{x}{2}$; in this case the precondition becomes
$(1{=}r\limplies2{=}s\limplies (r\land s))$, which is a tautology.
\begin{gather*}
  % \PW{x}{0}\SEMI
  % \PR{x}{r}\SEMI
  % \PR{x}{s}\SEMI
  % \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  % \IF{r\land s}\THEN \PW{z}{1}\FI
  % \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a0}{\DW{x}{0}}{}
      \event{a1}{\DR{x}{1}}{right=of a0}
      \event{a2}{\DR{x}{2}}{right=of a1}
      \event{a3}{\DW{y}{1}}{right=of a2}
      \event{a4}{\DW{z}{1}}{right=of a3}
      % \wk{a0}{a1}
      % \wk[out=-20,in=-160]{a0}{a2}
      \po[out=20,in=160]{a1}{a3}
      \po[out=20,in=160]{a1}{a4}
      \po[out=-20,in=-160]{a2}{a4}
    \end{tikzinline}}
\end{gather*}
The situation reverses with the substitution $[r/x]$:
\begin{gather*}
  \PR{x}{r}\SEMI
  \PR{x}{s}\SEMI
  \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  \IF{r\land s}\THEN \PW{z}{1}\FI
  \\[-2ex]
  \hbox{\begin{tikzinline}[node distance=0.5em and 1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DR{x}{2}}{right=of a1}
      \event{a3}{1{=}r\limplies  (2{=}s\lor r{=}s)\limplies (r\land s\;\mathsf{even})\mid\DW{y}{1}}{right=of a2}
      \event{a4}{1{=}r\limplies  (2{=}s\lor r{=}s)\limplies (r\land s)\mid\DW{z}{1}}{right=of a3}
      \po[out=12,in=168]{a1}{a3}
      \po[out=10,in=170]{a1}{a4}
    \end{tikzinline}}
\end{gather*}
Prepending $\PWP{x}{0}$:
%\vspace{-.5\baselineskip}
\begin{gather*}
  % \PW{x}{0}\SEMI
  % \PR{x}{r}\SEMI
  % \PR{x}{s}\SEMI
  % \IF{r\land s\;\mathsf{even}}\THEN \PW{y}{1}\FI\SEMI
  % \IF{r\land s}\THEN \PW{z}{1}\FI
  % \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a0}{\DW{x}{0}}{}
      \event{a1}{\DR{x}{1}}{right=of a0}
      \event{a2}{\DR{x}{2}}{right=of a1}
      \event{a3}{\DW{y}{1}}{right=of a2}
      \event{a4}{\DW{z}{1}}{right=of a3}
      % \wk{a0}{a1}
      % \wk[out=-20,in=-160]{a0}{a2}
      \po[out=20,in=160]{a1}{a3}
      \po[out=20,in=160]{a1}{a4}
      \po{a2}{a3}
    \end{tikzinline}}
\end{gather*}
The dependency has changed from $\DRP{x}{2}\xpo\DWP{z}{1}$ to
$\DRP{x}{2}\xpo\DWP{y}{1}$.  The resulting sets of pomsets are
incomparable.


Thinking in terms of hardware, the difference is whether reads update the
cache, thus clobbering preceding writes.  With $[r/x]$, reads clobber the
cache, whereas without the substitution, they do not.  Since most caches work
this way, the model with $[r/x]$ is likely preferred for modeling hardware.
However, this substitution only makes sense in a model with read-read
coherence and read-read dependencies, which we will see is not the case for Arm.  By
leaving out the substitution, we also ensure that downgraded reads are
fulfilled by preceding writes, not reads.



\label{sec:ex:last}
