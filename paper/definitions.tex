\section{Model}
\label{sec:model}

Batty suggest example where dependencies are added and also go away, perhaps
by store forwarding. Something like:
\texttt{(r=x; y=1); (s=y; z=s+r)}

\subsection{Preliminaries}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$.
\end{itemize}

\emph{Memory locations} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory locations, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.

We require that
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
  % \item for any set $\aEvs$ there are registers $\uRegs{\aEvs}=\{\uReg{\aEv}\mid\aEv\in\aEvs\}$,
\item expressions include at least registers and values, 
\item expressions do \emph{not} include memory locations.
  % or registers in
  % $\uRegs{\aEvs}$, for any set $\aEvs$.
\end{itemize}

We model the following language.
\begin{align*}
  \amode \BNFDEF& \mRLX
  \BNFSEP \mRA 
  \BNFSEP \mSC
  \\
  \aCmd
  \BNFDEF& \ABORT
  \BNFSEP \SKIP
  \BNFSEP \LET{\aReg}{\aExp}
  % \BNFSEP \PR[\amode]{\aLoc}{\aReg}
  % \BNFSEP \PW[\amode]{\aLoc}{\aExp}
  \BNFSEP \PRREF[\amode]{\cExp}{\aReg}
  \BNFSEP \PWREF[\amode]{\cExp}{\aExp}
  % \BNFSEP \PA{\aLoc}{\aExp} 
  \\[-.5ex]
  \BNFSEP& \FORK{\aGrp}
  \BNFSEP \aCmd_1 \SEMI \aCmd_2
  \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
  \\
  \aGrp 
  \BNFDEF& \NIL
  \BNFSEP\THREAD{\aCmd}
  \BNFSEP\aGrp_1 \PAR \aGrp_2
\end{align*}
\emph{Memory modes}, $\amode$, are {relaxed} ($\mRLX$), {release-acquire}
($\mRA$), and {sequentially consistent} ($\mSC$).  Relaxed is the default.
% 
\emph{Commands}, aka \emph{statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs.
% 
\emph{Thread groups}, $\aGrp$, include commands and $\NIL$, which denotes
inaction. %, or deadlock.
% 
The $\FORK{}$ command spawns a thread group.  % We often drop the words
% $\FORK{}$ and $\THREAD{}$.

The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, $\dEv$, 
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, 
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$.
\end{itemize}
Subsets of $\AllEvents$ are ranged over by $\aEvs$, $\bEvs$, $\cEvs$,
$\dEvs$.

We require that:
\begin{itemize}
\item actions include writes $\DWP{\aLoc}{\aVal}$ and reads $\DRP{\aLoc}{\aVal}$,
\item formulae include equalities $(\aExp{=}\bExp)$ and $(\aExp{=}\aLoc)$,
\item formulae include symbols $\RW$, % for all $\aLoc$,
  % \item formulae include the symbols
  $\Q{\mSC}$, $\Q{\mRA}$, $\Qx{\aLoc}$, 
  $\Qw{\aLoc}$, $\Dx{\aLoc}$, % for all $\aLoc$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitutions $[\aExp/\aReg]$ and $[\aExp/\aLoc]$, 
\item there is an entailment relation $\vDash$ between formulae,
\item $\vDash$ has the expected semantics for $=$, $\lnot$, $\land$, $\lor$,
  $\limplies$,
\item $\Q{\mSC}\vDash\Q{\mRA}\vDash\Qx{\aLoc}\vDash\Qw{\bLoc}$ when $\aLoc=\bLoc$.  
\end{itemize}


% Action $\DWP{\aLoc}{\aVal}$ models a write of $\aVal$ to $\aLoc$, and
% $\DRP{\aLoc}{\aVal}$ models a read of $\aVal$ from $\aLoc$.
% We use $\DAP{\aLoc}{\aVal}$ to indicate a generic access, which could be
% either a read or a write.

Logical formulae include equations over locations and registers, such
$(\aLoc{=}1)$ and $(\aReg{=}\bReg{+}1)$.
We use expressions as formulae, coercing $\aExp$ to $\aExp{\neq}0$.
Formulae are subject to substitutions of the form $[\aExp/\aReg]$ and $[\aExp/\aLoc]$; actions are not.

% \begin{definition}
%   \label{def:independent}
%   We say $\aForm$ is \emph{independent of $\aLoc$} if, for every
%   $\aVal$, $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$; it is
%   \emph{dependent} otherwise.
%   We say $\aForm$ is \emph{location independent} if it is independent of
%   every location.
We say
$\aForm$ \emph{implies} $\bForm$ if $\aForm\vDash\bForm$.
% We say that
We say
$\aForm$ is a \emph{tautology} if $\TRUE\vDash\aForm$.
% We say that
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm\vDash\FALSE$.
% \end{definition}


We additionally assume that either:
% In \textsection\ref{sec:model}--\ref{sec:arm} we 
% additionally require that
\begin{itemize}
\item each register appears at most once in a program, or
% \end{itemize}
% In \textsection\ref{sec:complications} and following, we
% require instead that
% \begin{itemize}
\item there are registers
  $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$ that do not
  appear in programs.
\end{itemize}
In contexts that make no use of $\uRegs{\AllEvents}$, we make the first
assumption.

\subsection{Pomsets}

We first consider a fragment of our language that can be modeled using simple
pomsets.
\begin{definition}
  A \emph{pomset} over $\Act$ is a tuple
  $(\Event, {\le}, \labeling)$ where
  \begin{itemize}
  \item $\Event\subset\AllEvents$ is a set of \emph{events},
  \item
    ${\le} \subseteq (\Event\times\Event)$ is the \emph{causality} partial order, 
  \item
    $\labeling: \Event \fun \Act$ is a \emph{labeling}.
  \end{itemize}
\end{definition}
Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.

We lift terminology from actions to events.  For example, we say that $\aEv$
writes $\aLoc$ if $\labeling(\aEv)$ writes $\aLoc$.  We also drop quantifiers
when clear from context, such as
$(\forall\aEv\in\Event)(\forall\aLoc\in\Loc)$.

\begin{definition}
  Action $\DWP{\aLoc}{\aVal}$ \emph{matches} $\DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.
  Action $\DWP{\aLoc}{\aVal}$ \emph{blocks} $\DRP{\aLoc}{\bVal}$, for any
  $\aVal$, $\bVal$.
  
  % A pomset $\aPS$ is \emph{closed} if for every $\aEv$ which can be
  % fulfilled, there is a $\bEv\le\aEv$ which fulfills it, and for any $\cEv$
  % which can block $\aEv$, either $\cEv\le\bEv$ or $\aEv\le\cEv$.

  Event $\aEv$ is \emph{fulfilled} if there is a $\bEv\le\aEv$ which
  matches it and, for any $\cEv$ which can block $\aEv$, either $\cEv\le\bEv$
  or $\aEv\le\cEv$.

  Pomset $\aPS$ is \emph{fulfilled} if every read in $\aPS$ is fulfilled.
\end{definition}

\begin{definition}
  Actions $\aAct$ and $\bAct$ are \emph{independent} (notation
  $\aAct\reorder\bAct$) if either both are reads or they are accesses to
  different locations.  Formally
  \begin{math}
    {\reorder} = \{(\DR{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \}
    \cup\{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}.
  \end{math}
  %\emph{Independency} (${\reorder}\subseteq\Act\times\Act$), is defined:
  \begin{comment}
    % {\reorderSC} &= \emptyset
    % \\
    % {\reorderRLX} &=
    \reorder &=
    \{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}
    \\[-.5ex]&\mkern2mu\cup\mkern2mu
    \{(\DR{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \}
    % \\[-.5ex]&\mkern2mu\cup\mkern2mu
    % \{(\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc \lor \aVal=\bVal\}
    % \\[-.5ex]&\mkern2mu\cup\mkern2mu
    % \{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}
  \end{comment}
\end{definition}

% Definition \ref{def:pomsets} describes operators over sets of pomsets
% sufficient to give the semantics for the following fragment of our language:
\begin{definition} %$\phantom{\;}$\par
  \label{def:pomsets}

  \noindent
  If $\aPS\in\sNIL$ then $\aEvs = \emptyset$.

  \noindent
  If $\aPS \in (\aPSS_1\sPAR\aPSS_2)$ then  
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
  \item \label{par-E}
    $\aEvs = (\aEvs_1\cup\aEvs_2)$,
  \item \label{par-lambda1}
    if $\aEv\in\aEvs_1$ then $\labeling(\aEv) = \labeling_1(\aEv)$, 
  \item \label{par-lambda2}
    if $\aEv\in\aEvs_2$ then $\labeling(\aEv) = \labeling_2(\aEv)$,
  \item \label{par-le1}
    if $\bEv\le_1\aEv$ then $\bEv\le\aEv$, 
  \item \label{par-le2}
    if $\bEv\le_2\aEv$ then $\bEv\le\aEv$, 
    \newcounter{pomsetParCount}
    \setcounter{pomsetParCount}{\value{enumi}}
  \item \label{par-disjoint}
    $\aEvs_1$ and $\aEvs_2$ are disjoint.
    \newcounter{pomsetParDisjointCount}
    \setcounter{pomsetParDisjointCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS \in (\aAct\sPREFIX\aPSS_2)$ then
  $(\exists\aPS_2\in\aPSS_2)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}
  \item \label{pre-E}
    $\aEvs=(\aEvs_1 \cup \aEvs_2)$,
  \item \label{pre-unique}
    if $\bEv,\aEv\in\aEvs_1$ then $\bEv=\aEv$,
  \item \label{pre-lambda1}
    if $\aEv\in\aEvs_1$ then $\labelingAct(\aEv) = \aAct$,
  \item \label{pre-lambda2}
    if $\aEv\in\aEvs_2$ then $\labelingAct(\aEv) = \labelingAct_2(\aEv)$,
  \item \label{pre-le2}
    if $\bEv\le_2\aEv$ then $\bEv\le\aEv$, 
    % \newcounter{pomsetPrefixCount}
    % \setcounter{pomsetPrefixCount}{\value{enumi}}
  \item
    \label{pre-reorder}
    if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ then either $\bEv\leq\aEv$ or $a\reorder\labeling_2(\aEv)$.
    \newcounter{pomsetPrefixOrderCount}
    \setcounter{pomsetPrefixOrderCount}{\value{enumi}}
  \end{enumerate}
\end{definition}
\begin{definition}
  \noindent
  For a language fragment, the semantics is:
  \begin{align*}
    \sem{\PW{\aLoc}{\aVal}\SEMI \aCmd} &= \textstyle\DWP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
    &
    \sem{\SKIP} &= \sem{\NIL} = \sNIL 
    \\
    \sem{\PR{\aLoc}{\aReg}\SEMI \aCmd} &= \textstyle\bigcup_{\aVal}\DRP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
    &
    \sem{\aGrp_1 \PAR \aGrp_2} &= \sem{\aGrp_1}\sPAR\sem{\aGrp_2}
    % \\
    % \sem{\PA{\aLoc}{\aVal}\SEMI \aCmd} &= \textstyle\DRP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
  \end{align*}
  % Let $\aPSS$ range over sets of pomsets.

\end{definition}

If we take ${\reorder} = \emptyset$, then we have sequentially consistent
execution.

[Do Examples.]

[Do examples with coherence.]

[Note that this allows mumbling.]

[Use refinement (that is subset order) as notion of compiler optimization.]

[Talk about Mazurkiewicz traces.]

\subsection{Pomsets with Preconditions}
\label{sec:pomsets-pre}

[Problem with previous section is that notion of dependency is impoverished]

The model described here is essentially the model of
\cite{DBLP:journals/pacmpl/JagadeesanJR20}, restricting attention
to relaxed access.  We discuss the differences in the appendix.

\begin{definition}
  A \emph{pomset with preconditions} is
  a pomset together with $\labelingForm:\aEvs\fun\Formulae$.
\end{definition}

\begin{definition}
  A pomset with preconditions is \emph{top level} if it is fulfilled and
  every precondition is a tautology.
\end{definition}

% \begin{definition}
%   Let $\aSub$ be a substitution.  If $\aPS\in(\aPSS\aSub)$ then
%   $(\exists\aPS\in\aPSS)$ $\Event = \Event'$, ${\le} = {\le'}$,
%   $\labelingAct = \labelingAct'$, and
%   $\labelingForm(\aEv) = \labelingForm'(\aEv)\aSub$.
% \end{definition}

% Definition \ref{def:pomsets-pre}, describes operators 
% sufficient to give the semantics to a larger fragment of our language:
\begin{definition}%$\phantom{\;}$\par
  \label{def:pomsets-pre}
  
  \noindent
  If $\aPS\in\sNIL$ then $\aEvs = \emptyset$.

  \noindent
  If $\aPS \in (\aPSS_1\sPAR\aPSS_2)$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetParDisjointCount}}
  \item[\ref{par-E}--\ref{par-disjoint})]
    as for $\sPAR$ in Def.~\ref{def:pomsets},
  \item \label{par-kappa1}
    if $\aEv\in\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$,
  \item \label{par-kappa2}
    if $\aEv\in\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$.
    \newcounter{pomsetPreParCount}
    \setcounter{pomsetPreParCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS \in \sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[\ref{par-E}--\ref{par-le2})] 
    as for $\sPAR$  in Def.~\ref{def:pomsets} (ignoring disjointness),
  \item \label{if-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\aForm\land\labelingForm_1(\aEv)$,
  \item \label{if-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\neg\aForm\land\labelingForm_2(\aEv)$, 
  \item \label{if-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then\\
    $\labelingForm(\aEv)$ implies $(\aForm\limplies\labelingForm_1(\aEv))\land(\neg\aForm\limplies\labelingForm_2(\aEv))$.
    % $\labelingForm(\aEv)$ implies $(\aForm\land\labelingForm_1(\aEv))\lor(\neg\aForm\land\labelingForm_2(\aEv))$.
    \newcounter{pomsetPreIfCount}
    \setcounter{pomsetPreIfCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS \in \sSTOREPRE{\aLoc}{\aExp}{\aPSS_2}$ then
  $(\exists\aPS_2\in\aPSS_2)$
  $(\exists\aVal\in\Val)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPrefixOrderCount}}
  \item[\ref{pre-E}--\ref{pre-reorder})]
    as for $\DWP{\aLoc}{\aVal}\sPREFIX\aPSS_2$ in Def.~\ref{def:pomsets}, % (ignoring \thepomsetPrefixOrderCount),
  \item \label{storepre-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\aExp{=}\aVal$,
  \item \label{storepre-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$,
  \item \label{storepre-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm(\aEv)$ implies $\aExp{=}\aVal \lor \labelingForm_2(\aEv)$.
    % \item if $\aEv\in\aEvs_2$ then either
    %   $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$ or\\
    %   $\aEv\in\aEvs_1$ and $\labelingForm(\aEv)$ implies $(\aExp{=}\aVal)\lor \labelingForm_2(\aEv)$.
  \end{enumerate}

  \noindent
  If $\aPS \in \sLOADPRE{\aReg}{\aLoc}{\aPSS_2}$ then
  $(\exists\aPS_2\in\aPSS_2)$
  $(\exists\aVal\in\Val)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPrefixOrderCount}}
  \item[\ref{pre-E}--\ref{pre-reorder})]
    as for $\DRP{\aLoc}{\aVal}\sPREFIX\aPSS_2$ in Def.~\ref{def:pomsets}, % (ignoring \thepomsetPrefixOrderCount),
  \item \label{loadpre-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then either \\
    $\labelingForm(\aEv)$ implies $\aReg{=}\aVal\limplies\labelingForm_2(\aEv)$ and $(\exists\bEv\in\aEvs_1)\;\bEv<\aEv$, or \\
    $\labelingForm(\aEv)$ implies $(\aReg{=}\aVal\lor\aReg{=}\aLoc)\limplies\labelingForm_2(\aEv)$.
    % \\ \mbox{$\quad$} for some $\bEv\in\aEvs_1$.
  \end{enumerate}  
\end{definition}
\begin{definition}
  \noindent
  For a language fragment, the semantics is:
  \begin{gather*}
    \sem{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} = \sIF{\aExp{\neq}0}\sTHEN\sem{\aCmd_1}\sELSE\sem{\aCmd_2}\sFI
    \\
    \begin{aligned}
      \sem{\PW{\aLoc}{\aExp}\SEMI \aCmd} &=
      \sSTOREPRE{\aLoc}{\aExp}{\sem{\aCmd}}
      &
      \sem{\SKIP} &= \sem{\NIL} = \sNIL 
      \\
      \sem{\PR{\aLoc}{\aReg}\SEMI \aCmd} &=
      \sLOADPRE{\aReg}{\aLoc}{\sem{\aCmd}}
      &
      \makebox[3.5em][r]{$\sem{\aGrp_1 \PAR \aGrp_2}$} &= \sem{\aGrp_1}\sPAR\sem{\aGrp_2}
    \end{aligned}
  \end{gather*}
\end{definition}
Following our convention for subscripts, in the final clause of
$\sLOADPRE{}{}{}$, $<$ refers to the order of $\aPS$.  Also note that
$\sLOADPRE{}{}{}$ does not constrain $\labelingForm(\aEv)$ if
$\aEv\in\aEvs_1$.




[Stuff about conditionals and merging events.]


\subsection{Pomsets with Predicate Transformers}

[The problem with the previous section is that there's no story for
sequential composition.]

The final semantic functions for load and store, given in
Figure~\ref{fig:full}, are quite complex.  We explain the definition by
looking at its constituent parts, starting with
Def.~\ref{def:pomsets-trans}, below, which captures dependency.  In
\textsection\ref{sec:q}, we add \emph{quiescence}, which encodes coherence,
release-acquire and SC access, and termination.  In
\textsection\ref{sec:arm}, we add peculiarities that are necessary for
efficient implementation on \armeight.  In
\textsection\ref{sec:complications}, we discuss the complications required
to validate if-closure and to allow address calculation.
\begin{figure*}
  \begin{center}
    \begin{minipage}{0.905\textwidth}
      \input{fig-full}
      % \input{fig-full-where}
      % \input{fig-full-noco}
    \end{minipage}
  \end{center}
  \caption{Full Semantics of Loads, Stores and Threads (See Def.~\ref{def:QS}
    for $\QS{}{}$/$\QL{}{}$ and Def.~\ref{def:DS} for $\DS{}{}$/$\DL{}{}$)}
  \label{fig:full}
\end{figure*}    


\begin{definition}
  A \emph{predicate transformer} is a monotone function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  $\aTr{}{\FALSE}$ is $\FALSE$,
  $\aTr{}{\bForm_1\land\bForm_2}$ is $\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$, and
  $\aTr{}{\bForm_1\lor\bForm_2}$ is $\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$.
\end{definition}

\begin{definition}
  A \emph{family of predicate transformers} for $\aEvs$ consists of a
  predicate transformer $\aTr{\bEvs}{}$ for each $\bEvs\subseteq\AllEvents$,
  such that if $\cEvs \cap \aEvs \subseteq \bEvs$ then $\aTr{\cEvs}{\bForm}$
  implies $\aTr{\bEvs}{\bForm}$.
\end{definition}

[Predicates with smaller subsets of $\aEvs$ are stronger.]

\begin{definition}
  A pomset with predicate tansformers is a pomset with preconditions,
  together with a family of predicate transformers for $\aEvs$.
\end{definition}

% \begin{definition}
%   For pomset $\aPS$ and $\aEv\in\aEvs$, let
%   $\downclose[0]{\aEv} = \{ \bEv\in\aEvs \mid \bEv < \aEv \}$.
% \end{definition}

$\sTHREAD{}$ converts a pomset with predicate transformers into a pomset
with preconditions by dropping the predicate transformer.  For the
reverse embedding, $\sFORK{}$ adopts the identity transformer.

\begin{definition}
  \label{def:pomsets-group}
  \noindent
  If $\aPS \in \sTHREAD{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}
  \item[{\labeltext[T1]{T1)}{T1}}] % \label{thread-E}
    $\aEvs=\aEvs_1$,
  \item[{\labeltext[T2]{T2)}{T2}}] % \label{thread-lambda}
    $\labelingAct(\aEv) = \labelingAct_1(\aEv)$,
  \item[{\labeltext[T3]{T3)}{T3}}] % \label{thread-kappa}
    $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$.
    \newcounter{pomsetXThreadCount}
    \setcounter{pomsetXThreadCount}{\value{enumi}}
  \end{enumerate}  

  \noindent
  If $\aPS \in \sFORK{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}
  \item \label{fork-E}
    $\aEvs=\aEvs_1$,
  \item \label{fork-lambda}
    $\labelingAct(\aEv) = \labelingAct_1(\aEv)$,
  \item \label{fork-kappa} 
    $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$, 
  \item \label{fork-tau} 
    $\aTr{\bEvs}{\bForm}$ implies $\bForm$.
    \newcounter{pomsetXForkCount}
    \setcounter{pomsetXForkCount}{\value{enumi}}
  \end{enumerate}  
\end{definition}
\begin{definition}
  \noindent
  Adopting $\sNIL$ and $\sPAR$ from Def.~\ref{def:pomsets-pre},
  the semantics of thread groups is:
  \begin{align*}
    \sem{\THREAD{\aCmd}} &= \sTHREAD{}\sem{\aCmd}
    &
    \sem{\aGrp_1 \PAR \aGrp_2} &= \sem{\aGrp_1}\sPAR\sem{\aGrp_2}      
    &
    \sem{\NIL} &= \sNIL     
  \end{align*}
  % , and
  % $\sTHREAD{}$ is as follows.
\end{definition}


\begin{definition}
  \label{def:pomsets-trans}

  \noindent
  If $\aPS\in\sABORT$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm}$ implies $\FALSE$.
  \end{itemize}

  \noindent
  If $\aPS\in\sSKIP$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm}$ implies $\bForm$.
  \end{itemize}

  \noindent
  If $\aPS\in\sLET{\aReg}{\aExp}$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm}$ implies $\bForm[\aExp/\aReg]$.
  \end{itemize}

  \noindent
  If $\aPS \in \sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetPreIfCount}}
  \item[1--\ref{if-kappa12})] as for $\sIF{}$ in Def.~\ref{def:pomsets-pre},
  \item \label{if-tau}
    $\aTr{\bEvs}{\bForm}$ implies
    $(\aForm\limplies\aTr[1]{\bEvs}{\bForm})\land(\neg\aForm\limplies\aTr[2]{\bEvs}{\bForm})$.
    % $(\aForm\land\aTr[1]{\bEvs%\cap\aEvs_1
    % }{\bForm})\lor(\neg\aForm\land\aTr[2]{\bEvs%\cap\aEvs_2
    % }{\bForm})$.
  \end{enumerate}

  \noindent
  If $\aPS \in (\aPSS_1\sSEMI\aPSS_2)$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$,
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  % let $\labelingForm'_2(\aEv)=\aTr[1]{{\downclose[0]{\aEv}}}{\labelingForm_2(\aEv)}$  
  % let $\labelingForm'_2(\aEv)=\aTr[1]{\{ \bEv \mid \bEv < \aEv \}}{\labelingForm_2(\aEv})$  
  \begin{enumerate}
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[1--\ref{par-le2})]
    as for $\sPAR$  in Def.~\ref{def:pomsets} (ignoring disjointness),
  \item \label{seq-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$,
  \item \label{seq-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm'_2(\aEv)$,
  \item \label{seq-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)\lor\labelingForm'_2(\aEv)$,
    \\ where $\labelingForm'_2(\aEv)=\aTr[1]{\cEvs%\cap\aEvs_1
    }{\labelingForm_2(\aEv})$, where $\cEvs=\{ \cEv \mid \cEv < \aEv \}$,
  \item \label{seq-tau}
    $\aTr{\bEvs}{\bForm}$ implies $\aTr[1]{\bEvs}{\aTr[2]{\bEvs}{\bForm}}$.
    \newcounter{pomsetXSemiCount}
    \setcounter{pomsetXSemiCount}{\value{enumi}}
    % \item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ either $\bEv<\aEv$ or $a\reorder\labeling_2(\aEv)$.
  \end{enumerate}
  % where we define $\labelingForm'_2(\aEv)$ to be $\aTr[1]{\{ \bEv \mid \bEv < \aEv \}}{\labelingForm_2(\aEv})$.

  \noindent
  If $\aPS \in \sSTORE[\amode]{\aLoc}{\aExp}$ then
  $(\exists\aVal\in\Val)$
  % $(\forall\bEvs\neq\emptyset)$
  \begin{enumerate}
  \item[{\labeltext[S1]{S1)}{S1}}]
    if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item[{\labeltext[S2]{S2)}{S2}}]
    $\labelingAct(\aEv) = \DW{\aLoc}{\aVal}$,
  \item[{\labeltext[S3]{S3)}{S3}}]
    $\labelingForm(\aEv)$ implies $\aExp{=}\aVal$,
  \item[{\labeltext[S4]{S4)}{S4}}]
    $\aTr{\bEvs}{\bForm}$ implies $\bForm[\aExp/\aLoc]$, % \land (\Q{}\limplies\aExp{=}\aVal)$,
  \item[{\labeltext[S5]{S5)}{S5}}]
    $\aTr{\cEvs}{\bForm}$ implies $\bForm[\aExp/\aLoc]$, % \land % \lnot\Q{}$.
    \\ where $\bEvs\cap\aEvs\neq\emptyset$ and $\cEvs\cap\aEvs=\emptyset$.
    % \item %if $\bEvs\neq\emptyset$ then
    %   $\aTr{\bEvs}{\bForm}$ implies $(\aExp{=}\aVal) \land \bForm[\aExp/\aLoc]$, if $\bEvs\neq\emptyset$,
    %   \newcounter{pomsetXStoreCount}
    %   \setcounter{pomsetXStoreCount}{\value{enumi}}
  \end{enumerate}

  % \noindent
  % If $\aPS \in \sLOAD[\amode]{\aReg}{\aLoc}$ then
  % $(\exists\aVal\in\Val)$
  % $(\forall\bEvs\neq\emptyset)$
  % \begin{enumerate}
  % \item[{\labeltext[L1]{L1)}{L1}}] 
  %   if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  % \item[{\labeltext[L2]{L2)}{L2}}]
  %   $\labelingAct(\aEv) = \DRP{\aLoc}{\aVal}$,
  % \item[{\labeltext[L3]{L3)}{L3}}]
  %   $\labelingForm(\aEv)$ implies $\TRUE$,
  % \item[{\labeltext[L4]{L4)}{L4}}]
  %   %   if $\bEvs\neq\emptyset$ then
  %   $\aTr{\bEvs}{\bForm}$ implies %$\phantom{(\aLoc{=}\aReg\lor{}}
  %   $\aVal{=}\aReg\limplies\bForm$, 
  % \item[{\labeltext[L5]{L5)}{L5}}]
  %   %   if $\bEvs=\emptyset$ then
  %   $\aTr{\emptyset}{\bForm}\;$ implies $((\aLoc{=}\aReg\lor\aVal{=}\aReg)\limplies\bForm) \land \lnot\Q{}$.
  % \item[{\labeltext[L6]{L6)}{L6}}]
  %   if $\aEvs=\emptyset$ then
  %   $\aTr{\emptyset}{\bForm}\;$ implies $\bForm \land \lnot\Q{}$.
  % \end{enumerate}

  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}{\aLoc}$ then either
  $\aEvs\neq\emptyset$ and
  $(\exists\aVal\in\Val)$
  % $(\forall\bEvs{\neq}\emptyset)$
  \begin{enumerate}
  \item[{\labeltext[L1]{L1)}{L1}}] 
    if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item[{\labeltext[L2]{L2)}{L2}}]
    $\labelingAct(\aEv) = \DR{\aLoc}{\aVal}$,
  \item[{\labeltext[L3]{L3)}{L3}}]
    $\labelingForm(\aEv)$ implies $\TRUE$,
  \item[{\labeltext[L4]{L4)}{L4}}]
    $\aTr{\bEvs}{\bForm}$ implies $\aVal{=}\aReg\limplies\bForm$, 
  \item[{\labeltext[L5]{L5)}{L5}}]
    $\aTr{\cEvs}{\bForm}$ implies $(\aVal{=}\aReg\lor\aLoc{=}\aReg)\limplies\bForm$, % \land \lnot\Q{}$,
    \\ where $\bEvs\cap\aEvs\neq\emptyset$ and $\cEvs\cap\aEvs=\emptyset$,
  \end{enumerate}
  or
  $\aEvs=\emptyset$ and 
  \begin{enumerate}
  \item[{\labeltext[L6]{L6)}{L6}}] 
    $\aTr{\dEvs}{\bForm}\;$ implies $\bForm$. % \land \lnot\Q{}$.
  \end{enumerate}
\end{definition}
\begin{definition}
  \noindent
  The semantics of commands is:
  \begin{scope}
    \allowdisplaybreaks
    \begin{gather*}
      \sem{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} = \sIF{\aExp{\neq}0}\sTHEN\sem{\aCmd_1}\sELSE\sem{\aCmd_2}\sFI
      \\
      \begin{aligned}
        \sem{\PW[\amode]{\aLoc}{\aExp}} &= \sSTORE[\amode]{\aLoc}{\aExp}
        &
        \makebox[0em][r]{$\sem{\ABORT}$} &= \sABORT 
        \\
        \sem{\PR[\amode]{\aLoc}{\aReg}} &= \sLOAD[\amode]{\aReg}{\aLoc}
        &
        \sem{\SKIP} &= \sSKIP 
        \\
        \sem{\LET{\aReg}{\aExp}} &= \sLET{\aReg}{\aExp}
        &
        \sem{\FORK{\aGrp}} &= \sFORK{}\sem{\aGrp}      
        \\
        \sem{\aCmd_1 \SEMI \aCmd_2} &= \sem{\aCmd_1}\sSEMI\sem{\aCmd_2}
      \end{aligned}
    \end{gather*}
  \end{scope}

\end{definition}


% Recall that $\uRegs{\bEvs}=\{\uReg{\bEv}\mid\bEv\in\bEvs\}$.



% [Note that we could change the premise of $\aTr{\emptyset}{}$ in $\sLOAD{}{}$
% from $(\aVal{=}\aReg\lor\aLoc{=}\aReg)$ to $(\aLoc{=}\aReg)$. The
% requirements of a family of predicate transforms effectively adds the
% additional requirement.]


% \aCmd if P is top-level and quiescent then predicate transformer may be wp(\aCmd,phi).
% Only thing is we are substituting v/r, rather than x/r.


% \aCmd any substitution/valuation sigma giving values for register, can find a
% pomset P such that when you apply the substitution to all the preconditions
% are tautologies and if the substitution validates the wp, then the
% substitution validates the $tau_E$

% substitution validates the wp: wp(\aCmd,phi)sigma is a tautology





\begin{comment} Consider the following executions.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{1{=}1\mid\DW{x}{1}}{}
          \xform{x1d}{\bForm[1/x]}{right=of a1}
          \xform{x1i}{\bForm[1/x]}{below=of x1d}
          \xo{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{2{=}1\mid\DW{x}{1}}{}
          \xform{x1d}{\bForm[2/x]}{right=of a1}
          \xform{x1i}{\bForm[2/x]}{below=of x1d}
          \xo{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  % Simplifying:
  % \begin{align*}
  %   \begin{gathered}
  %   %     \PW{x}{1}
  %   %     \\
  %     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %       \event{a1}{\DW{x}{1}}{}
  %       \xform{x1d}{\bForm[1/x]}{right=of a1}
  %       \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %       \xo{a1}{x1d}
  %     \end{tikzinline}}
  %   \end{gathered}
  %   &&
  %   \begin{gathered}
  %   %     \PW{x}{2}
  %   %     \\
  %     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %       \event{a1}{\FALSE\mid\DW{x}{1}}{}
  %       \xform{x1d}{\FALSE}{right=of a1}
  %       \xform{x1i}{\bForm[2/x]}{right=of x1d}
  %       \xo{a1}{x1d}
  %     \end{tikzinline}}
  %   \end{gathered}
  % \end{align*}
  Merging the actions, we have:
  % \begin{gather*}
  %   \PW{x}{1}\SEMI \PW{x}{2}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
  %     \xform{x1d}{(\bForm[1/x])[2/x]}{below=of a1}
  %     \xform{x1i}{(\bForm[1/x])[2/x]}{below=of x1d}
  %     \xo{a1}{x1d}
  %   \end{tikzinline}}
  % \end{gather*}
  % which simplifies to
  % \begin{gather*}
  %   %   \PW{x}{1}\SEMI \PW{x}{2}
  %   %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{a1}{\DW{x}{1}}{}
  %     \xform{x1d}{\bForm[1/x] }{right=of a1}
  %     \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %     \xo{a1}{x1d}
  %   \end{tikzinline}}
  % \end{gather*}
  % which simplifies to
  \begin{gather*}
    \PW{x}{1}\SEMI \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
        \xform{x1d}{(\bForm[2/x])[1/x]}{right=of a1}
        \xform{x1i}{(\bForm[2/x])[1/x]}{right=of x1d}
        \xo{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
  which simplifies to
  \begin{gather*}
    % \PW{x}{1}\SEMI \PW{x}{2}
    % \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{1}}{}
        \xform{x1d}{\bForm[2/x]}{right=of a1}
        \xform{x1i}{\bForm[2/x]}{right=of x1d}
        \xo{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
  % \end{example}
  % \begin{example} Merging right.
  %   \begin{align*}
  %     \begin{gathered}
  %       \PW{x}{1}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{1{=}2\mid\DW{x}{1}}{}
  %         \xform{x1d}{\bForm[1/x]}{right=of a1}
  %         \xform{x1i}{\bForm[1/x]}{below=of x1d}
  %         \xo{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %     &&
  %     \begin{gathered}
  %       \PW{x}{2}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{2{=}2\mid\DW{x}{1}}{}
  %         \xform{x1d}{\bForm[2/x]}{right=of a1}
  %         \xform{x1i}{\bForm[2/x]}{below=of x1d}
  %         \xo{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %   \end{align*}
  %   Simplifying:
  %   \begin{align*}
  %     \begin{gathered}
  %       \PW{x}{1}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{\FALSE\mid\DW{x}{2}}{}
  %         \xform{x1d}{\FALSE}{right=of a1}
  %         \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %         \xo{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %     &&
  %     \begin{gathered}
  %       \PW{x}{2}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{\DW{x}{2}}{}
  %         \xform{x1d}{\bForm[2/x]}{right=of a1}
  %         \xform{x1i}{\bForm[2/x]}{right=of x1d}
  %         \xo{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %   \end{align*}
  %   Merging the actions, we have:
  The programs are also capable of writing 2.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{1{=}2\mid\DW{x}{2}}{}
          \xform{x1d}{\bForm[1/x]}{right=of a1}
          \xform{x1i}{\bForm[1/x]}{below=of x1d}
          \xo{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{2{=}2\mid\DW{x}{2}}{}
          \xform{x1d}{\bForm[2/x]}{right=of a1}
          \xform{x1i}{\bForm[2/x]}{below=of x1d}
          \xo{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  Merging right.
  \begin{gather*}
    % \PW{x}{1}\SEMI \PW{x}{2}
    % \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{2}}{}
        \xform{x1d}{\bForm[2/x]}{right=of a1}
        \xform{x1i}{\bForm[2/x]}{right=of x1d}
        \xo{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
\end{comment}

\begin{comment}
  Separate actions:
  \begin{align*}
    \begin{gathered}
      \PW{x}{1} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[1/x]}{}
          \xform{xi}{\bForm[1/x]}{below=of xd}
          \event{a1}{1{=}1\mid\DW{x}{1}}{left=of xd}
          \xo{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[2/x]}{}
          \xform{xi}{\bForm[2/x]}{below=of xd}
          \event{a2}{2{=}2\mid\DW{x}{2}}{left=of xd}      
          \xo{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Simplifying:
  \begin{align*}
    \begin{gathered}
      % \PW{x}{1} 
      % \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[1/x]}{}
          \xform{xi}{\bForm[1/x]}{right=of xd}
          \event{a1}{\DW{x}{1}}{left=of xd}
          \xo{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      % \PW{x}{2}
      % \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[2/x]}{}
          \xform{xi}{\bForm[2/x]}{right=of xd}
          \event{a2}{\DW{x}{2}}{left=of xd}      
          \xo{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together unordered:
  \begin{gather*}
    \PW{x}{1}\SEMI \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdi}{\bForm[2/x]}{}
        \xform{xdd}{\bForm[2/x]}{right=of xdi}
        \xform{xid}{\bForm[2/x]}{right=of xdd}
        \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
        \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
        \xform{xii}{\bForm[2/x]}{right=of xid}
        \xo{a1}{xdi}
        \xo{a2}{xid}
        \xo{a1}{xdd}
        \xo{a2}{xdd}
      \end{tikzinline}}
  \end{gather*}
  Adding order does nothing since the preconditions are tautologies.
  % \begin{gather*}
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \xform{xdi}{\bForm[1/x]}{}
  %     \xform{xdd}{\bForm[1/x]}{right=of xdi}
  %     \xform{xid}{\bForm[1/x]}{right=of xdd}
  %     \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
  %     \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
  %     \xform{xii}{\bForm[1/x]}{right=of xid}
  %     \xo{a1}{xdi}
  %     \xo{a2}{xid}
  %     \xo{a1}{xdd}
  %     \xo{a2}{xdd}
  %     \po{a1}{a2}
  %   \end{tikzinline}}
  % \end{gather*}
\end{comment}

\begin{example}
  Read to write dependency, first separately:
  \begin{align*}
    \begin{gathered}
      \PR{x}{r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{(1{=}r)\limplies\bForm}{}
          \xform{xi}{(x{=}r\lor1{=}r)\limplies\bForm}{below=of xd}
          \event{a1}{\DR{x}{1}}{above=of xd}
          \xo{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[r/y]}{}
          \xform{xi}{\bForm[r/y]}{below=of xd}
          \event{a2}{r{=}1\mid\DW{y}{1}}{above=of xd}      
          \xo{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together without order:
  % \begin{gather*}
  %   \PR{x}{r} \SEMI
  %   \PW{y}{r}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \xform{xdi}{((1{=}r)\limplies\bForm)[r/y]}{}
  %     \xform{xid}{(((x{=}r\lor1{=}r)\limplies\bForm))[r/y]\land r{=}1}{right=of xdi}
  %     \event{a1}{\DR{x}{1}}{above=of xdi}
  %     \event{a2}{((x{=}r\lor1{=}r)\limplies r{=}1)\mid\DW{y}{1}}{right=of a1}
  %     \xform{xdd}{((1{=}r)\limplies\bForm)[r/y]\land r{=}1}{above right=.5em and -1em of a1}
  %     \xform{xii}{(((x{=}r\lor1{=}r)\limplies\bForm))[r/y]}{below=2.7em of a2}
  %     \xo{a1}{xdi}
  %     \xo{a2}{xid}
  %     \xo{a1}{xdd}
  %     \xo{a2}{xdd}
  %   \end{tikzinline}}
  % \end{gather*}
  % simplifying:
  \begin{gather*}
    \PR{x}{r} \SEMI
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdi}{(1{=}r)\limplies\bForm[r/y]}{}
        \xform{xid}{(x{=}r\lor1{=}r)\limplies\bForm[r/y]}{right=of xdi}
        \event{a1}{\DR{x}{1}}{above=of xdi}
        \event{a2}{(x{=}r\lor1{=}r)\limplies r{=}1\mid\DW{y}{1}}{right=of a1}
        \xform{xdd}{1{=}r\limplies\bForm[r/y]}{above right=.5em and -1em of a1}
        \xform{xii}{(x{=}r\lor1{=}r)\limplies\bForm[r/y]}{below=2.7em of a2}
        \xo{a1}{xdi}
        \xo{a2}{xid}
        \xo{a1}{xdd}
        \xo{a2}{xdd}
      \end{tikzinline}}
  \end{gather*}
  If the read is ordered before the write, then the precondition of the write
  can be weakened: % to
  % \begin{math}
  %   1{=}r\limplies r{=}1.
  % \end{math}
  \begin{gather*}
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DR{x}{1}}{}
        \event{a2}{1{=}r\limplies r{=}1\mid\DW{y}{1}}{right=of a1}
        \po{a1}{a2}
      \end{tikzinline}}
  \end{gather*}
\end{example}


