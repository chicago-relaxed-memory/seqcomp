\section{Model}
\label{sec:model}

%% Batty suggest example where dependencies are added and also go away, perhaps
%% by store forwarding. Something like:
%% \texttt{(r=x; y=1); (s=y; z=s+r)}

In this section, we present the mathematical preliminaries for the
model (which can be skipped on first reading). We then present the
model incrementally, starting with a model built using
\emph{partially ordered multisets}
(\emph{pomsets})~\cite{GISCHER1988199,Plotkin:1997:TSP:266557.266600},
and then adding preconditions and finally predicate transformers.

In later sections, we will discuss extensions to the logic, and to the
semantics of load, store and thread initialization, in order to model
relaxed memory more faithfully. We stress that these features do
\emph{not} change any of the structures of the language: conditionals,
parallel composition, and sequential composition are as defined in this section.

\subsection{Preliminaries}
\label{sec:prelim}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$.
\end{itemize}

\emph{Memory references} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory references, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.

We require that
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
\item expressions include at least registers and values, 
\item expressions do \emph{not} include references: $\aExp[\bExp/\aLoc]=\aExp$.
\end{itemize}

We model the following language.
\begin{gather*}
  \begin{aligned}
    \amode \BNFDEF& \mRLX
    \BNFSEP \mRA 
    \BNFSEP \mSC
    &\mkern100mu
    \fmode \BNFDEF& \fACQ 
    \BNFSEP \fREL
    \BNFSEP \fSC
  \end{aligned}
  \\
  \aCmd
  \BNFDEF \LET{\aReg}{\aExp}
  \BNFSEP \PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}
  \BNFSEP \PW[\amode]{\REF{\cExp}}[\ascope]{\aExp}
  \BNFSEP \PF[\ascope]{\fmode}
  \BNFSEP \SKIP
  \BNFSEP \aCmd_1 \SEMI \aCmd_2
  \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
  \BNFSEP \aCmd_1 \LPAR[\bThrd] \aCmd_2
  % \\[-.5ex]
  % \BNFSEP& \PCAS[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
  % \BNFSEP \PFADD[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  % \BNFSEP \PEXCHG[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
\end{gather*}

\emph{Memory modes}, $\amode$, are {relaxed} ($\mRLX$), {release-acquire}
($\mRA$), and {sequentially consistent} ($\mSC$).  Relaxed mode is the
default; we regularly elide it from examples.  $\mRA$/$\mSC$ accesses are
collectively known as \emph{synchronized accesses}.  

\emph{Fence modes}, $\bmode$, are {acquire} ($\fACQ$), {release} ($\fREL$), 
and {acquire-release} ($\fSC$).  

\emph{Commands}, aka \emph{statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs. Following
\cite{DBLP:conf/icfp/FerreiraHJ96}, $\LPAR$ denotes parallel composition,
preserving thread state on the left after a join.  In examples and
sublanguages without join, we use the symmetric $\PAR$ operator.

The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, $\dEv$, 
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$,
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, 
\end{itemize}
Subsets of $\AllEvents$ are ranged over by $\aEvs$, $\bEvs$, $\cEvs$,
$\dEvs$.

We require that:
\begin{itemize}
\item formulae include $\TRUE$, $\FALSE$ and the equalities $(\aExp{=}\bExp)$ and $(\aLoc{=}\aExp)$,
\item formulae are closed under $\lnot$, $\land$, $\lor$, $\limplies$, and
  substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$,
\item there is a relation $\rimpliesdef$ between
  formulae, capturing entailment, %\subseteq(\Formulae\times\Formulae)$ %
\item $\rimpliesdef$ has the expected semantics for $=$, $\lnot$,
  $\land$, $\lor$, $\limplies$ and substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$,
\item there are three binary relations over $\Act\times\Act$:
  $\rmatchesdef$, $\rblocksdef$, and $\rdelaysdef$,
\item there are two subsets of $\Act$, distinguishing
  $\sreaddef$ and $\sreleasedef$ actions.
\end{itemize}

Logical formulae include equations over registers, such as
$(\aReg{=}\bReg{+}1)$.
For use in \textsection\ref{sec:tc1}, we also include equations over memory references, such as $(\aLoc{=}1)$.
% I would like to drop this, an be careful about program vs logical syntax
Formulae are subject to substitutions; % of the form $[\aExp/\aReg]$ and
% $[\aExp/\aLoc]$;
actions are not.
We use expressions as formulae, coercing $\aExp$ to $\aExp{\neq}0$.
Equations have precedence over logical operators; thus
$\aReg{=}\aVal\limplies\bReg{>}\bVal$ is read
$(\aReg{=}\aVal)\limplies(\bReg{>}\bVal)$.  As usual, implication associates to the
right; thus $\aForm\limplies\bForm\limplies\cForm$ is read
$\aForm\limplies(\bForm\limplies\cForm)$.

% \begin{definition}
%   \label{def:independent}
%   We say $\aForm$ is \emph{independent of $\aLoc$} if, for every
%   $\aVal$, $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$; it is
%   \emph{dependent} otherwise.
%   We say $\aForm$ is \emph{location independent} if it is independent of
%   every location.
%   We say
%   $\aForm$ \emph{implies} $\bForm$ if $\aForm\vDash\bForm$.
%   We say that
We say
$\aForm$ is a \emph{tautology} if $\TRUE \rimplies \aForm$.
% We say that
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm \rimplies \FALSE$.
% \end{definition}


Throughout \textsection\ref{sec:model}--\ref{sec:arm} we 
additionally require that
\begin{itemize}
\item each register is assigned at most once in a program.
  % \end{itemize}
  % In \textsection\ref{sec:complications} and following, we
  % require instead that
  % \begin{itemize}
  % \end{itemize}
\end{itemize}
In \textsection\ref{sec:complications}, we drop this restriction, requiring
instead that
\begin{itemize}
\item there are registers
  $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$,
\item registers $\uRegs{\AllEvents}$ do not appear in programs: $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$.
\end{itemize}
% In contexts that make no use of $\uRegs{\AllEvents}$, we make the first
% assumption.


\subsection{Actions in This Paper}

In this paper, we let actions be reads and writes and fences:
\begin{displaymath}
  \aAct,\bAct \BNFDEF \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DF[\ascope]{\fmode}[\aThrd]
\end{displaymath}
% % writes $\DWP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% reads $\DRP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% and fences $\DFP[\ascope]{\fmode}[\aThrd]$.

We use shorthand when referring to actions.  In definitions, we drop elements
of actions that are existentially quantified.  In examples, we drop elements
of actions, using defaults.
% We write $\DXP[\amode]{}[\ascope]{}[\aThrd]$ to
% stand for $\DWP[\amode]{}[\ascope]{}[\aThrd]$ or
% $\DRP[\amode]{}[\ascope]{}[\aThrd]$.
%
Let $\lemode$ be the least order over access and fence modes such that
$\mRLX\lemode\mRA\lemode\mSC$ and $\fREL\lemode\fSC$ and $\fACQ\lemode\fSC$.
We write $\DWP[\gemode\mRA]{}{}$ to stand for either $\DWP[\mRA]{}{}$ or
$\DWP[\mSC]{}{}$, and similarly for the other actions and modes.

% We also define shorthand for sets of
% actions using an order on access and fence modes:  
% \begin{align*}
%   \begin{tikzcenter}
%     \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
%     \node (ra)  at (1, 0) {$\mathstrut\mRA$};
%     \node (sc)  at (2, 0) {$\mathstrut\mSC$};
%     \draw[->](rlx)to(ra);
%     \draw[->](ra)to(sc);
%   \end{tikzcenter}
%   &&
%   \begin{tikzcenter}
%     \node (fsc) at (3, 0) {$\mathstrut\fSC$};
%     \node (rel) at (2, -0.2) {$\mathstrut\fREL$};
%     \node (acq) at (2,  0.2) {$\mathstrut\fACQ$};
%     \draw[->](rel)to(fsc);
%     \draw[->](acq)to(fsc);
%   \end{tikzcenter}
% \end{align*}
% We write $\amode\lemode\bmode$ for this order.
%Let $\amode\lubmode\bmode$ denote the least upper bound of $\amode$ and $\bmode$.

% or $\DFP[\ascope]{\amode}[\aThrd]$.
% We write $\DWP[\gemode\mREL]{}{}$ to stand for either
% $\DWP[\mREL]{}{}$ or $\DWP[\mSC]{}{}$, and similarly for other actions and
% modes.

\begin{definition}
  \label{def:actions}
  Actions $\DRP{}{}$ are $\sreaddef$ actions.
  Actions $\DWP[\gemode\mREL]{}{}$ and $\DFP{\gemode\fREL}$ are
  $\sreleasedef$ actions.

  We say $\aAct \rmatchesdef \bAct$ if $\aAct=\DWP{\aLoc}{\aVal}$ and $\bAct=\DRP{\aLoc}{\aVal}$.
  % We say $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.
  % Action $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.

  We say $\aAct \rblocksdef \bAct$ if $\aAct=\DWP{\aLoc}{}$ and $\bAct=\DRP{\aLoc}{}$, regardless of value.
  % We say $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.
  % Action $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.

  % Let two actions \emph{overlap} if they access the same location.
  % We say $\aAct \roverlapsdef \bAct$ if they access the same location.

  We say $\aAct \rdelaysdef \bAct$ if $\aAct\eqreorderco\bAct$ or $\aAct\reorderra\bAct$ or $\aAct\eqreordersc\bAct$.

  Let ${\eqreorderco}$ capture write-write, read-write coherence:
  \begin{math}
    {\eqreorderco}
    =
    \{(\DW{\aLoc}{}\Cb \DW{\aLoc}{})\C(\DR{\aLoc}{}\Cb \DW{\aLoc}{})\C(\DW{\aLoc}{}\Cb \DR{\aLoc}{})\}
  \end{math}.

  Let ${\reorderra}$ capture order due to synchronization:
  \begin{math}
    {\reorderra}
    =
    \{(\aAct\Cb             \DW[\gemode\mREL]{}{}     )\C
    (\aAct\Cb               \DF{\gemode\fREL}        )\C
    (\DR{}{}\Cb             \DF{\gemode\fACQ}        )\C
    (\DR{\aLoc}{}\Cb        \DR[\gemode\mACQ]{\aLoc}{})\C
    (\DR[\gemode\mACQ]{}{}\Cb\aAct                    )\C
    (\DF{\gemode\fACQ}\Cb   \aAct                    )\C
    (\DF{\gemode\fREL}\Cb   \DW{}{}                  )\C
    (\DW[\gemode\mREL]{\aLoc}{}\Cb\DW{\aLoc}{})\}
  \end{math}.

  Let ${\eqreordersc}$ capture order due to $\mSC$ access:
  \begin{math}
    {\eqreordersc}
    =
    %\{(\DX[\mSC]{}{}\Cb\DX[\mSC]{}{})\}
    \{(\DW[\mSC]{}{}\Cb \DW[\mSC]{}{})\C(\DR[\mSC]{}{}\Cb \DW[\mSC]{}{}) \C(\DW[\mSC]{}{}\Cb \DR[\mSC]{}{})\C(\DR[\mSC]{}{}\Cb \DR[\mSC]{}{})\}
  \end{math}.
\end{definition}

\subsection{Model}

\begin{definition}
  \label{def:pomset}
  A \emph{pomset with predicate transformers} over $\Act$
  is a tuple $(\aEvs, \labeling, \labelingForm, \aTr{}{}, \aTerm, {\rrfx}, {\le})$ where
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
  \item \label{pom-E}
    $\Event\subseteq\AllEvents$ is a set of \emph{events},
  \item \label{pom-lambda}
    $\labeling: \Event \fun \Act$ defines a \emph{label} for each event,
  \item \label{pom-kappa}
    $\labelingForm:\aEvs\fun\Formulae$ defines a \emph{precondition} for each event,
  \item \label{pom-tau}
    $\aTr{}{}:2^{\AllEvents}\fun\Formulae \fun\Formulae$ is a \emph{family of
      predicate transformers} over $\aEvs$, %defines a \emph{predicate transformer} for each set of events,
  \item \label{pom-term}
    $\aTerm:\Formulae$ defines a \emph{termination condition},
  \item \label{pom-rf}
    ${\rrfx} : \Event\fun\Event$ is an injective relation capturing
    \emph{reads-from} such that 
    % \end{enumerate}
    % A pomset is a \emph{candidate} if there is an injective relation
    % ${\rrfx} : \Event\times\Event$, capturing \emph{reads-from}, such that
    \begin{enumerate}
      % \begin{enumerate}[,label=(\textsc{c}\arabic*),ref=\textsc{c}\arabic*]
      % \item \label{rf-injective}
      %   if $\bEv\xrfx\aEv$ and $\cEv\xrfx\aEv$ then $\bEv=\cEv$, that is, ${\rrfx}$ is injective,
    \item \label{rf-match}
      if $\bEv\xrfx\aEv$ then $\labeling(\bEv) \rmatches \labeling(\aEv)$,
      % \item \label{rf-block}
      %   if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\le\bEv$ or $\aEv\le\cEv$.
      % \item \label{rf-le}
      %   if $\bEv\xrfx\aEv$ then $\bEv\le\aEv$.
    \end{enumerate}
  \item \label{pom-le}
    ${\le} : \Event\times\Event$, is a partial order capturing
    \emph{causality}, such that
    \begin{enumerate}
      \item \label{rf-block}
        if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\le\bEv$ or $\aEv\le\cEv$.
    \end{enumerate}
  \end{enumerate}
  A pomset is \emph{top-level} if for every $\aEv\in\aEvs$,
  % $\labelingForm(\aEv)$ is a tautology and
  % if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$.
  \begin{enumerate}[resume,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
  \item \label{top-true}
    $\labelingForm(\aEv)$ is a tautology,    
  \item \label{top-rf}
    if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$.
  \end{enumerate}
\end{definition}

We give the semantics of programs in \reffig{fig:sem}.
\input{fig-sem.tex}
\begin{lemma}
  \label{lem:rf:implies:le}
  For any $\aPS$ in the range of $\sem{}$, $\bEv\xrfx\aEv$ implies
  $\bEv\le\aEv$.

  \vspace{-.5\baselineskip}
  \begin{proof}
    Induction on the definition of $\sem{}$.
  \end{proof}
\end{lemma}

The semantics to be closed with respect to \emph{augmentation}
Augments include more order and stronger formulae; in examples, we typically
consider pomsets that are augment-minimal.  One intuitive reading of augment
closure is that adding order can only cause preconditions to weaken.
\begin{definition}
  \label{def:augment}
  $\aPS_2$ is an \emph{augment} of $\aPS_1$ if
  \begin{multicols}{4}
    \begin{enumerate}
    \item $\aEvs_2=\aEvs_1$,
    \item $\labelingAct_2(\aEv)=\labelingAct_1(\aEv)$,
    \item $\labelingForm_2(\aEv) \rimplies \labelingForm_1(\aEv)$,
    \item $\aTr[2]{\bEvs}{\aEv} \rimplies \aTr[1]{\bEvs}{\aEv}$,
    \item $\aTerm[2] \rimplies \aTerm[1]$,
    \item ${\rrfx_2}={\rrfx_1}$,
    \item ${\le_2}\supseteq{\le_1}$.
    \end{enumerate}
  \end{multicols}
\end{definition}

\begin{lemma}
  % Suppose $\aPS_1\in\sem{\aCmd}$.
  If $\aPS_1\in\sem{\aCmd}$ and $\aPS_2$  augments $\aPS_1$ then $\aPS_2\in\sem{\aCmd}$.
  % \item If $\aPS_2$ is a downset of $\aPS_1$ then $\aPS_2\in\sem{\aCmd}$.
  % \end{lemma}

  \vspace{-.5\baselineskip}
  \begin{proof}
    Induction on the definition of $\sem{}$.
  \end{proof}
\end{lemma}



% \begin{definition}
%   Suppose $\aRel_1:\aEvs_1\times\aEvs_1$ and $\aRel_2:\aEvs_2\times\aEvs_2$.
%   We say $\aRel \rextendsdef{\aRel_1}{\aRel_2}$ if
%   $\aRel\supseteq (\aRel_1\cup \aRel_2)$ and
%   $\aRel\cap(\aEvs_1\times \aEvs_1) = \aRel_1$ and
%   $\aRel\cap(\aEvs_2\times \aEvs_2) = \aRel_2$.
% \end{definition}
Note that $\aEvs_1$ and $\aEvs_2$ are not necessarily disjoint.
In $\sIFTHEN{}{}{}$, the definition of $\rextendsdef{}{}$ stops coalescing the $\rrfx$ in
\begin{displaymath}
  \IF{b}\THEN\PR{x}{r}\PAR\PW{x}{1}\ELSE\PR{x}{r}\SEMI\PW{x}{1}\FI
\end{displaymath}


We have given the semantics of $\sIF{}{}{}$ using 
disjunctive normal form. \citet{DBLP:journals/cacm/Dijkstra75} used
conjunctive normal form.  Note that 
\href{https://www.wolframalpha.com/input/?i=\%28a+and+b\%29+or+\%28not+a+and+c\%29}{$(\aForm\land\cForm_1)\lor(\neg\aForm\land\cForm_2)$}
is logically equivalent to
\href{https://www.wolframalpha.com/input/?i=\%28a+implies+b\%29+and+\%28\%28not+a\%29+implies+c\%29}{$(\aForm\limplies\cForm_1)\land(\neg\aForm\limplies\cForm_2)$}.

%We include empty sets as prep for adding while loops.

\subsection{Full Versions}

If $\aPS \in \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]$ then
$(\exists\aVal:\aEvs\fun\Val)$
$(\exists\cForm:\aEvs\fun\Formulae)$
\begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
  \item \label{write-E-x}
    if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{write-lambda-x}
    $\labelingAct(\aEv) = \DW[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$,
  \item \label{write-kappa-x}
    \begin{math}
      \labelingForm(\aEv) \rimplies
      \cForm_\aEv
      \land \aExp{=}\aVal_\aEv
    \end{math},
    
    
  \item \label{write-tau-x}
    % \begin{math}
    %   %   (\forall\aEv\in\aEvs\cap\bEvs)
    %   (\forall\aEv\in\aEvs)
    % \end{math}
    \begin{math}
      \aTr{\bEvs}{\bForm} \rimplies 
      \cForm_\aEv
      \limplies 
      \bForm[\aExp/\aLoc]
    \end{math},
    % \item
    %   \begin{math}    
    %     (\forall\aEv\in\aEvs\setminus\bEvs)
    %   \end{math}
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     \cForm_\aEv
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}
    % \item
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}.
    \stepcounter{enumi}
  \item[] \labeltext[\textsc{w}5]{}{write-term-x}
    \begin{enumerate}[leftmargin=0pt]
    \item \label{write-term-nonempty-x}
      $\aTerm \rimplies \cForm_\aEv \limplies \aExp{=}\aVal_\aEv$,
    \item \label{write-term-empty-x}
      $\aTerm \rimplies \bigvee_{\aEv\in\aEvs}\cForm_\aEv$.
    \end{enumerate}
  \end{enumerate}
\end{multicols}

\medskip
\noindent
If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]$ then
$(\exists\aVal:\aEvs\fun\Val)$
$(\exists\cForm:\aEvs\fun\Formulae)$ 
% \begin{multicols}{2}
\begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
\item \label{read-E-x}
  if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
\item \label{read-lambda-x}
  $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
\item \label{read-kappa-x}
  \begin{math}
    \labelingForm(\aEv) \rimplies
    \cForm_\aEv
  \end{math},
  \stepcounter{enumi}
\item[] \labeltext[\textsc{r}4]{}{read-tau-x}
  \begin{enumerate}[leftmargin=0pt]
  \item \label{read-tau-dependent-x}
    \begin{math}
      (\forall\aEv\in\aEvs\cap\bEvs)
    \end{math}
    \begin{math}
      \aTr{\bEvs}{\bForm} \rimplies
      \cForm_\aEv
      \limplies \aVal_\aEv{=}\uReg{\aEv}
      \limplies \bForm[\uReg{\aEv}/\aReg]
    \end{math},
    
  \item \label{read-tau-independent-x}
    \begin{math}
      (\forall\aEv\in\aEvs\setminus\bEvs)
    \end{math}
    \begin{math}
      \aTr{\bEvs}{\bForm} \rimplies
      \cForm_\aEv 
      \limplies
      \PBR{\aVal_\aEv{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}}
      \limplies
      \bForm[\uReg{\aEv}/\aReg]
    \end{math},
    
  \item \label{read-tau-empty-x}
    \begin{math}
      (\forall\bReg)
    \end{math}
    \begin{math}
      \aTr{\bEvs}{\bForm} \rimplies 
      % (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
      (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
      \limplies 
      \bForm[\bReg/\aReg].
    \end{math}  
  \end{enumerate}  
\end{enumerate}
% \begin{multicols}{2}
%   \noindent
%   And either
%   \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
%     \setcounter{enumi}{1}
%   \item \label{read-lambda-x}
%     $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
%   \item \label{read-kappa-x}
%     \begin{math}
%       \labelingForm(\aEv) \rimplies
%       \cForm_\aEv
%     \end{math},
%   \end{enumerate}
%   or $\amode\neq\mRLX$ and
%   \begin{enumerate}[topsep=0pt,label=(\textsc{d}\arabic*),ref=\textsc{d}\arabic*]
%     \setcounter{enumi}{1}
%   \item \label{read-lambda-x}
%     $\labelingAct(\aEv) = \DR[\mRLX]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
%   \item \label{read-kappa-x}
%     \begin{math}
%       \labelingForm(\aEv) \rimplies
%       \cForm_\aEv\land \aLoc{=}\aVal_\aEv
%     \end{math},
%   \end{enumerate}
% \end{multicols}
% \medskip
% Could make \textsc{d}4b:
% \begin{math}
%   (\forall\aEv\in\aEvs\setminus\bEvs)
% \end{math}
% \begin{math}
%   \aTr{\bEvs}{\bForm} \rimplies
%   \cForm_\aEv 
%   \limplies
%   \PBR{\aVal_\aEv{=}\uReg{\aEv} \land \aLoc{=}\uReg{\aEv}}
%   \limplies
%   \bForm[\uReg{\aEv}/\aReg][\uReg{\aEv}/\aLoc]
% \end{math},



% In diagrams, we use different colors for arrows.  We distinguish
% $\rrfx$ edges that are included in order from those that are not.
% \begin{itemize}
% \item \makebox{$\aEv\xrf\bEv$} arises from $\rrfx$, where $\aEv\le\bEv$,
% \item \makebox{$\aEv\xrfint\bEv$} arises from $\rrfx$, where $\lnot(\aEv\le\bEv)$.
% \end{itemize}
% To help the reader understand why order is included, we also different colors
% for arrows induced by order.  We adopt the following conventions:
% \begin{itemize}  
%   % \item relaxed accesses are blue, with a single border,
%   % \item synchronized accesses are red, with a double border,
%   % \item \makebox{$\aEv\xrf\bEv$} arises from fulfillment, where $\aEv$ \emph{matches} $\bEv$,
%   % \item \makebox{$\aEv\xwk\bEv$} arises either from fulfillment, where $\aEv$
%   %   \emph{blocks} $\bEv$, or from prefixing, where $\aEv$ was prefixed before
%   %   $\bEv$ and their actions \emph{conflict},
% \item \makebox{$\aEv\xwk\bEv$} arises from \emph{fulfillment},
% \item \makebox{$\aEv\xpo\bEv$} arises from control/data/address \emph{dependency},
% \item \makebox{$\aEv\xsync\bEv$} arises from \emph{synchronized access}.
% \end{itemize}



\section{Arm}
For simplicity, we restrict to top level parallel composition and ignore
fences\footnote{Fences are not actions in \armeight{}, which complicates the
  theorem statements.}.

\subsection{Arm executions}
\begin{definition}
  An \emph{\armeight{} execution graph}, $\aEG$, is tuple
  $(\aEvs, \labeling, {\rpoloc}, {\rlob})$ such that
  \begin{enumerate}[,label=(\textsc{a}\arabic*),ref=\textsc{a}\arabic*]
  \item $\Event\subseteq\AllEvents$ is a set of {events},
  \item $\labeling: \Event \fun \Act$ defines a {label} for each event,
  \item ${\rpoloc} : \Event\times\Event$, is a per-thread, per-location total
    order, capturing \emph{per-location program order},
  \item ${\rlob} : \Event\times\Event$, is a per-thread partial order capturing
    \emph{locally-ordered-before}, such that
    \begin{enumerate}
    \item \label{arm-lob-poloc}
      ${\rpoloc} \cup {\rlob}$ is acyclic.
    \end{enumerate}
  \end{enumerate}
\end{definition}

The definition of $\rlob$ is complex.  Comparing with our definition of
sequential composition, it is sufficient to note that $\rlob$ includes
\begin{enumerate}[label=(\textsc{l}\arabic*),ref=\textsc{l}\arabic*]
\item read-write dependencies, required by \ref{seq-kappa},
\item synchronization delay of ${\reorderra}$, required by \ref{seq-le-delays},
\item $\mSC$ access delay of ${\eqreordersc}$, required by \ref{seq-le-delays},
\item write-write and read-to-write coherence delay of ${\reorderco}$, required by \ref{seq-le-delays},
\end{enumerate}
and that $\rlob$ does \emph{not} include
\begin{enumerate}[resume,label=(\textsc{l}\arabic*),ref=\textsc{l}\arabic*]
\item \label{lob-rr}
  read-read control dependencies, required by \ref{seq-kappa},
\item \label{lob-rf}
  write-to-read order of $\rrfx$, required by \ref{seq-le-rf},
\item \label{lob-wr}
  write-to-read coherence delay of ${\reorderco}$, required by \ref{seq-le-delays}.
\end{enumerate}

\begin{definition}
  Execution $\aEG$ is
  \emph{$({\rco}, {\rrfx}, {\rgcb})$-valid}, under \emph{External Global
    Consistency} (\EGC{}) if
  \begin{enumerate}[label=(\textsc{a}\arabic*),ref=\textsc{a}\arabic*]
    \setcounter{enumi}{4}
  %\item[\eqref{arm-co}] and \eqref{arm-rf}, as for \EC,
  \item \label{arm-co}
    ${\rco} : \Event\times\Event$, is a per-location total order on
    writes, capturing \emph{coherence}, 
  \item \label{arm-rf}
    ${\rrfx} : \Event\times\Event$, is a surjective and injective
    relation on reads, capturing \emph{reads-from}, such that
    \begin{enumerate}
    \item \label{arm-match}
      if $\bEv\xrfx\aEv$ then $\labeling(\bEv) \rmatches \labeling(\aEv)$,      
    \item \label{arm-local}
      ${\rpoloc} \cup {\rco} \cup {\rrfx} \cup {\rfr}$ is acyclic,
      where $\aEv\xfr\cEv$ if %$(\exists\bEv)$
      $\aEv\xrfxinv\bEv\xco\cEv$, for some $\bEv$,
      % \stepcounter{enumi}
      % \item[] \labeltext[\textsc{a}2]{}{arm-cb}
    \end{enumerate}
    % \item ${\rpoloc} \cup {\rco} \cup {\rrfx} \cup {\rfr}$ is acyclic, where
    %   $\bEv\xfr\aEv$ if $(\exists\cEv)$ $\bEv\xrfxinv\cEv\xco\aEv$,
  \item \label{arm-gcb}
    ${\rgcb}\supseteq\PBR{{\rco}\cup{\rrfx}}$ is a linear order %, capturing \emph{globally completes before}, %$\rcb : % \Event\times\Event$
    such that 
    \begin{enumerate}%[leftmargin=0pt]
      % \item if $\bEv\xco\aEv$ then $\bEv\xgcb\aEv$,
      % \item if $\bEv\xrfx\aEv$ then $\bEv\xgcb\aEv$,
    \item \label{arm-gcb-blocks}
      if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\xgcb\bEv$ or $\aEv\xgcb\cEv$, 
    \item \label{arm-gcb-lob}
      if $\aEv\xlob\cEv$ then either $\aEv\xgcb\cEv$ or $(\exists\bEv)$
      $\bEv\xrfx\aEv$ and $\bEv\xpoloc\aEv$ but not $\bEv\xlob\cEv$.
    \end{enumerate}
  \end{enumerate}
  
  Execution $\aEG$ is
  \emph{$({\rco}, {\rrfx}, {\rcb})$-valid} under \emph{External Consistency} (\EC{}) if
  \begin{enumerate}[resume,label=(\textsc{a}\arabic*),ref=\textsc{a}\arabic*]
  \item[\eqref{arm-co}] and \eqref{arm-rf}, as for \EGC,
  \item \label{arm-cb}
    ${\rcb}\supseteq\PBR{{\rco}\cup{\rlob}}$ is a linear order %, capturing \emph{completes before}, %$\rcb : % \Event\times\Event$
    such that if $\bEv\xrfx\aEv$ then either
    \begin{enumerate}%[leftmargin=0pt]
    \item \label{arm-rfe}
      % $\bEv\xcb\aEv$ and $\cEv\rblocks\aEv$ then either $\cEv\xcb\bEv$ or $\aEv\xcb\cEv$, or 
      $\bEv\xcb\aEv$ and if $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\xcb\bEv$ or $\aEv\xcb\cEv$, or
      % $\bEv\xcb\aEv$ and $(\not\exists\cEv)$ such that $\bEv\xcb\cEv\xcb\aEv$ and $\cEv\rblocks\aEv$, or 
    \item \label{arm-rfi}
      $\bEv\xcbinv\aEv$ and $\bEv\xpoloc\aEv$ and $(\not\exists\cEv)$ $\labeling(\cEv) \rblocks \labeling(\aEv)$ and $\bEv\xpoloc\cEv\xpoloc\aEv$.
      % $\bEv\xpoloc\aEv$ and $(\not\exists\cEv)$ such that $\bEv\xpoloc\cEv\xpoloc\aEv$ and $\cEv\rblocks\aEv$.
      % \item if $\bEv\xco\aEv$ then $\bEv\xgcb\aEv$,
      % \item if $\bEv\xrfx\aEv$ then $\bEv\xgcb\aEv$,
      % \item if $\bEv\xrfx\aEv$ and $\cEv\rblocks\aEv$ then either $\cEv\xgcb\bEv$ or $\aEv\xgcb\cEv$,
      % \item if $\bEv\xlob\aEv$ then either $\bEv\xgcb\aEv$ or $(\exists\cEv)$
      %   $\cEv\xrfx\bEv$ and $\cEv\xpoloc\bEv$ but not $\cEv\xlob\aEv$.
    \end{enumerate}
  \end{enumerate}
\end{definition}
\cite{armed} explain \EGC{} and \EC{} using the following example.\footnote{We have
changed an address dependency in the first thread to a data dependency.}
\begin{gather*}
  \PW{x}{1}\SEMI 
  \PR{x}{r}\SEMI
  \PW{y}{r} \PAR
  \PR[\mACQ]{y}{1}\SEMI
  \PR{x}{s}
  \\
  \tag{\cmark\armeight}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DW{x}{1}}{}
      \event{b}{\DR{x}{1}}{right=of a}
      \event{c}{\DW{y}{1}}{right=of b}
      \raevent{d}{\DR[\mACQ]{y}{1}}{right=2.5em of c}
      \event{e}{\DR{x}{0}}{right=of d}
      \rfx{a}{b}
      \lob{b}{c}
      \rfx{c}{d}
      \lob{d}{e}
      \co[out=-165,in=-15]{e}[above right]{a}
    \end{tikzinline}}
\end{gather*}
\EGC{} drops $\rlob$-order in the first thread using \ref{arm-gcb-lob}, since
$\DWP{x}{1}$ is not $\rlob$-ordered before $\DWP{y}{1}$.
\begin{gather*}
  \tag{$\rgcb$}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DW{x}{1}}{}
      \event{b}{\DR{x}{1}}{right=of a}
      \event{c}{\DW{y}{1}}{right=of b}
      \raevent{d}{\DR[\mACQ]{y}{1}}{right=2.5em of c}
      \event{e}{\DR{x}{0}}{right=of d}
      \gcbz{a}{b}
      \gcbz{c}{d}
      \gcbz{d}{e}
      \gcbz[out=-165,in=-15]{e}{a}
      % \rfx{a}{b}
      % %\lob{b}{c}
      % \rfx{c}{d}
      % \lob{d}{e}
      % \co[out=-165,in=-15]{e}[above right]{a}
    \end{tikzinline}}
\end{gather*}
\EC{} drops $\rrfx$-order in the first thread using \ref{arm-rfi}.
\begin{gather*}
  \tag{$\rcb$}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DW{x}{1}}{}
      \event{b}{\DR{x}{1}}{right=of a}
      \event{c}{\DW{y}{1}}{right=of b}
      \raevent{d}{\DR[\mACQ]{y}{1}}{right=2.5em of c}
      \event{e}{\DR{x}{0}}{right=of d}
      \cbz{b}{c}
      \cbz{c}{d}
      \cbz{d}{e}
      \cbz[out=-165,in=-15]{e}{a}
      % %\rfx{a}{b}
      % \lob{b}{c}
      % \rfx{c}{d}
      % \lob{d}{e}
      % \co[out=-165,in=-15]{e}[above right]{a}
    \end{tikzinline}}
\end{gather*}

\subsection{Arm Compilation 1}

\citet{DBLP:journals/pacmpl/PodkopaevLV19} lowers to \armeight{} as follows:
Relaxed access is implemented using \LDR/\STR, non-relaxed access using
\LDAR/\STLR.  %, acquire and other fences using \DMBLD/\DMBSY.
In this section, we consider a suboptimal strategy, which lowers non-relaxed
reads to $(\DMBSY\SEMI\LDAR)$.

We do not distinguish control dependencies from address dependencies, and
therefore \ref{lob-rr} forces us to drop all dependencies between reads.  To
achieve this, we modify the definition of $\labelingForm'_2$ in
\reffig{fig:sem}.
\begin{definition}
  \label{def:semrr}
  Let $\semrr{}$ be as defined in \reffig{fig:sem}, replacing the definition
  of $\labelingForm'_2$ with:
  \begin{displaymath}
    \labelingForm'_2(\aEv)=
    \begin{cases}
      \aTr[1]{}{\labelingForm_2(\aEv)} & \text{if}\; \labeling(\aEv) \;\text{is a read}
      \\
      \aTr[1]{\Cdown{\aEv}}{\labelingForm_2(\aEv)} & \text{otherwise, where}\; \Cdown{\aEv}=\{ \cEv \mid \cEv \lt \aEv \}
    \end{cases}
    % $\Cdown{\aEv}=\{ \cEv \mid \cEv \lt \aEv \}$ if $\labeling(\aEv)$ is a write, and $\Cdown{\aEv}=\aEvs_1$, otherwise
    % \Cdown{\aEv}=
    % \begin{cases}
    %   \{ \cEv \mid \cEv \lt \aEv \} & \textif \labeling(\aEv) \;\text{is a write}
    %   \\
    %   \aEvs_1 & \textotherwise
    % \end{cases}
  \end{displaymath}
\end{definition}


\begin{theorem}
  \label{thm:ec}
  Suppose $\aEG_1$ is $({\rco_1}, {\rrfx_1}, {\rgcb_1})$-valid for $\aCmd$
  under the suboptimal lowering that maps non-relaxed reads to
  $(\DMBSY\SEMI\LDAR)$.  Then there is a top-level pomset
  $\aPS_2\in\semrr{\aCmd}$ such that $\aEvs_2=\aEvs_1$,
  $\labeling_2=\labeling_1$, ${\rrfx_2}={\rrfx_1}$, and ${\le_2}={\rgcb_1}$.

  \vspace{-.5\baselineskip}
  \begin{proof}
    First, we establish some lemmas about \armeight.
    
    \vspace{-.5\baselineskip}
    \begin{lemma}
      \label{lemma:fr}
      Suppose $\aEG$ is $({\rco}, {\rrfx}, {\rgcb})$-valid.  Then
      ${\rgcb}\supseteq{\rfr}$.

      \vspace{-.5\baselineskip}
      \begin{proof}
        Using the definition of ${\rfr}$ from \ref{arm-local}, we have
        $\aEv\xrfxinv\bEv\xco\cEv$, and therefore $\labeling(\cEv)$ blocks
        $\labeling(\aEv)$.    
        Applying \ref{arm-gcb-blocks}, we have that either $\cEv\xgcb\bEv$ or $\aEv\xgcb\cEv$.
        Since $\rgcb$ includes $\rco$, we have $\bEv\xgcb\cEv$, and therefore it
        must be that $\aEv\xgcb\cEv$.
      \end{proof}
    \end{lemma}
    
    \begin{lemma}
      \label{lemma:wr}
      Suppose $\aEG$ is $({\rco}, {\rrfx}, {\rgcb})$-valid and
      $\cEv\xpoloc\aEv$, where $\labeling(\cEv)\rblocks\labeling(\aEv)$.
      Then $\cEv\xgcb\aEv$.
      %$\labeling(\cEv)=\DWP{x}{}$ and $\labeling(\aEv)=\DRP{x}{}$.

      \vspace{-.5\baselineskip}
      \begin{proof}
        By way of contradiction, assume $\aEv\xgcb\cEv$.  If $\cEv\xrfx\aEv$
        then by \ref{arm-gcb} we must also have $\cEv\xgcb\aEv$,
        contradicting the assumption that $\rgcb$ is a total order.
        %
        Otherwise that there is some $\bEv\neq\cEv$ such that
        $\bEv\xrfx\aEv$, and therefore $\bEv\xgcb\aEv$.  By transitivity,
        $\bEv\xgcb\cEv$.  By the definition of $\rfr$, we have
        $\aEv\xfr\cEv$.  But this contradicts \ref{arm-local}, since
        $\cEv\xpoloc\aEv$.
        %Applying \ref{arm-gcb-blocks}, we have that either $\cEv\xgcb\bEv$ or $\aEv\xgcb\cEv$.
      \end{proof}
    \end{lemma}
    We show that all the order required in the pomset is also required by
    \armeight{}.  \ref{rf-block} holds since ${\rcb_1}$ is consistent with
    ${\rco_1}$ and ${\rfr_1}$.  As noted above $\rlob$ includes the order
    required by \ref{seq-kappa} and \ref{seq-le-delays}.  We need only show
    that the order removed from \ref{arm-gcb-lob} can also be removed from
    the pomset.  In order for \label{arm-gcb-lob} to remove order from $\aEv$
    to $\cEv$, we must have $\bEv\xrfx\aEv$ and $\bEv\xpoloc\aEv$ but not
    $\bEv\xlob\cEv$.  Because of our suboptimal lowering, it must be that
    $\aEv$ is a relaxed read; otherwise the $\DMBSY$ would require
    $\bEv\xlob\cEv$.  Thus we know that \ref{seq-le-delays} does not require
    order from $\aEv$ to $\cEv$.  By chaining \ref{read-tau-ind} and
    \ref{write-tau}, any dependence on the read can by satisfied without
    introducing order in \ref{seq-kappa}.
  \end{proof}  
\end{theorem}



% This model compiles correctly to arm using the lowering: Relaxed access is
% implemented using \texttt{ldr}/\texttt{str}, non-relaxed reads using
% \texttt{dmb st}\SEMI\texttt{ldar}, non-relaxed writes using \texttt{stlr},
% acquire fences using \texttt{dmb}.\texttt{ld} and other fences using 
% \texttt{dmb}.\texttt{sy}.
% \begin{align*}
%   \low{\PW[\gemode\mREL]{\REF{\aReg}}{\bReg}} &= \texttt{stlr}\;\bReg,\REF{\aReg}
%   &
%   \low{\PR[\mRLX]{\REF{\aReg}}{\bReg}} &= \texttt{ldr}\;\bReg,\REF{\aReg}
%   \\
%   \low{\PW[\mRLX]{\REF{\aReg}}{\bReg}} &= \texttt{str}\;\bReg,\REF{\aReg}
%   &
%   \low{\PR[\gemode\mACQ]{\REF{\aReg}}{\bReg}} &= \texttt{dmb st}\SEMI\texttt{ldar}\;\bReg,\REF{\aReg}
% \end{align*}

Downgrading messes up publication:
\begin{gather*}
  \PW{x}{\PR{x}{}+1}\SEMI
  \PW[\mREL]{y}{1}
  \PAR
  \PW{x}{1}\SEMI
  \IF{\PR[\mACQ]{y}{}\AND\PR[\mACQ]{x}{}}\THEN
  \PR{z}{s}
  \FI
  \PAR
  \PW{z}{1}\SEMI
  \PW[\mREL]{x}{1}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{b1}{\DR{x}{1}}{}
      \event{b2}{\DW{x}{2}}{right=of b1}
      \raevent{b3}{\DW[\mREL]{y}{1}}{right=of b2}
      \po{b1}{b2}
      \sync{b2}{b3}
      \event{a1}{\DW{x}{1}}{right=3em of b3}
      \raevent{a2}{\DR[\mACQ]{y}{1}}{right=of a1}
      \raevent{a3}{\DR[\mACQ]{x}{1}}{right=of a2}
      \event{a4}{\DR{z}{0}}{right=of a3}
      \sync{a2}{a3}
      \sync{a3}{a4}
      \event{c1}{\DW{z}{1}}{right=3em of a4}
      \raevent{c2}{\DW[\mREL]{x}{1}}{right=of c1}
      \sync{c1}{c2}
      \rf[out=-165,in=-15]{a1}{b1}
      \rf[out=15,in=165]{b3}{a2}
      \rf[out=-165,in=-15]{c2}{a3}
      \wk{a4}{c1}
    \end{tikzinline}}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{b1}{\DR{x}{1}}{}
      \event{b2}{\DW{x}{2}}{right=of b1}
      \raevent{b3}{\DW[\mREL]{y}{1}}{right=of b2}
      \po{b1}{b2}
      \sync{b2}{b3}
      \event{a1}{\DW{x}{1}}{right=3em of b3}
      \raevent{a2}{\DR[\mACQ]{y}{1}}{right=of a1}
      \event{a3}{\DR{x}{1}}{right=of a2}
      % \raevent{a3}{\DR[\mACQ]{x}{1}}{right=of a2}
      \event{a4}{\DR{z}{0}}{right=of a3}
      \sync{a2}{a3}
      \sync[out=15,in=165]{a2}{a4}
      \event{c1}{\DW{z}{1}}{right=3em of a4}
      \raevent{c2}{\DW[\mREL]{x}{1}}{right=of c1}
      \sync{c1}{c2}
      \rf[out=-165,in=-15]{a1}{b1}
      \rf[out=15,in=165]{b3}{a2}
      \rf[out=-165,in=-15]{c2}{a3}
      \wk{a4}{c1}
    \end{tikzinline}}
\end{gather*}

\subsection{Arm Compilation 2}

\begin{definition}
  Let $\semrf{}$ be as defined for $\semrr{}$ in \refdef{def:semrr} and
  \reffig{fig:sem}, changing \ref{seq-le-rf} and \ref{seq-le-delays}:
  \begin{itemize}
  \item[{\labeltext[\textsc{s}7b$'$]{(\textsc{s}7b$'$)}{seq-le-rf-rf}}]
    if $\labeling_1(\cEv) \rblocks \labeling_2(\aEv)$ then $\bEv\xrfx\aEv$
    implies $\cEv\le\bEv$,
  \item[{\labeltext[\textsc{s}7c$'$]{(\textsc{s}7c$'$)}{seq-le-delays-rf}}]
    if $\labeling_1(\bEv) \rdelaysp \labeling_2(\aEv)$ then $\bEv\le\aEv$,\\
    where $\rdelayspdef$ replaces $\eqreorderco$ in \refdef{def:actions} of
    $\rdelaysdef$ by
    \begin{math}
      {\reorderlws}
      =
      \{(\DW{\aLoc}{}, \DW{\aLoc}{}),\;(\DR{\aLoc}{}, \DW{\aLoc}{})\}
    \end{math}.
  \end{itemize}  
\end{definition}

Note that \reflem{lem:rf:implies:le} fails for $\semrf{}$, since
$\bEv\xrfx\aEv$ may not imply $\bEv\le\aEv$ when $\bEv$ and $\aEv$ come from
different sides of a sequential composition.  This means that $\rrfx$ must be
verified during pomset construction, rather than post-hoc.  If one wants a
post-hoc verification technique for $\rrfx$, it is possible to include
program order ($\rpox$) in the pomset.
\begin{lemma}
  $\aPS$ is top-level iff $\bEv\xrfx\aEv$ implies either
  \begin{itemize}
  \item external fulfillment: $\bEv\le\aEv$ and if $\labeling(\cEv)$ blocks
    $\labeling(\aEv)$ then either $\cEv\le\bEv$ or $\aEv\le\cEv$, or
  \item internal fulfillment: $\bEv\xpox\aEv$ and $(\not\exists\cEv)$
    $\labeling(\cEv) \rblocks \labeling(\aEv)$ and $\bEv\xpox\cEv\xpox\aEv$.
  \end{itemize}
\end{lemma}
% \begin{enumerate}
% \item[(\textsc{m}7d)]
%   if $\labeling(\cEv) \rblocks \labeling(\aEv)$
%   then $\bEv\xrfx\aEv$ implies $\cEv\le\bEv$.
%   %   if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then not $\bEv\le\cEv\xpox\aEv$.
% \end{enumerate}




% It follows from these that 
% \begin{itemize}
% \item if $\bEv\xfr\aEv$ then $\bEv\xgcb\aEv$, where $\bEv\xfr\aEv$ if
%   $(\exists\cEv)$ $\bEv\xrfxinv\cEv\xco\aEv$.
% \end{itemize}
% And therefore
% \begin{itemize}
% \item if $\bEv\xeco\aEv$ then $\bEv\xgcb\aEv$.
% \end{itemize}

\begin{theorem}
  \label{thm:ec}
  Suppose $\aEG_1$ %$(\aEvs_1, \labeling_1, {\rpoloc_1}, {\rlob_1})$
  is \EC-valid for $\aCmd$ via $({\rco_1}, {\rrfx_1}, {\rcb_1})$ and that
  ${\rcb_1}\supseteq{\rfr_1}$.  Then there is a top-level pomset
  $\aPS_2\in\sem{\aCmd}$ such that $\aEvs_2=\aEvs_1$,
  $\labeling_2=\labeling_1$, ${\rrfx_2}={\rrfx_1}$, and ${\le_2}={\rcb_1}$.

  \vspace{-.5\baselineskip}
  \begin{proof}
    We show that all the order required in the pomset is also required by
    \armeight{}.  \ref{rf-block} holds since ${\rcb_1}$ is consistent with
    ${\rco_1}$ and ${\rfr_1}$.  \ref{seq-le-rf} follows from \ref{arm-rfi}.
    As noted above, $\rlob$ includes the order required by
    \ref{seq-kappa} and \ref{seq-le-delays}.  
  \end{proof}
\end{theorem}

The generality of \refthm{thm:ec} is not limited by the assumption that
${\rcb_1}\supseteq{\rfr_1}$:
\begin{lemma}
  \label{lemma:fr}
  Suppose $\aEG$ is \EC-valid via $({\rco}, {\rrfx}, {\rcb})$.  Then there a
  permutation ${\rcbp}$ of ${\rcb}$ such that $\aEG$ is \EC-valid via
  $({\rco}, {\rrfx}, {\rcbp})$ and ${\rcbp}\supseteq{\rfr}$, where ${\rfr}$
  is defined in \ref{arm-local}.

  \vspace{-.5\baselineskip}
  \begin{proof}
    We show that any ${\rcb}$ order that contradicts ${\rfr}$ is incidental.

    By definition of $\rfr$, %$(\exists\bEv)$
    $\aEv\xrfxinv\bEv\xco\cEv$, for some $\bEv$.
    Since ${\rcb}\supseteq{\rco}$, we know that $\bEv\xco\cEv$.

    If \ref{arm-rfe} applies to $\bEv\xrfx\aEv$, then $\aEv\xcb\cEv$, since
    it cannot be that $\cEv\xco\bEv$.

    Suppose \ref{arm-rfi} applies to $\bEv\xrfx\aEv$ and $\cEv$ is from a
    different thread.  Because it is a different thread, we cannot have
    $\aEv\xlob\cEv$, and thus the order in $\rcb$ is incidental.

    Suppose \ref{arm-rfi} applies to $\bEv\xrfx\aEv$ and $\cEv$ is from the
    same thread.  Since $\cEv\xco\bEv$, it cannot be that $\cEv\xpoloc\bEv$,
    using \ref{arm-local}.  It also cannot be that
    $\bEv\xpoloc\cEv\xpoloc\aEv$.  It must be that $\aEv\xpoloc\cEv$.  By
    \ref{arm-lob-poloc}, we cannot have $\aEv\xlob\cEv$, and thus the order
    in $\rcb$ is incidental.
  \end{proof}
\end{lemma}


% Lemma: ${\rpoloc}\cup{\rpre}$ is acyclic.

% Theorem: per-thread essential ${\le}$ $\subseteq$ ${\rpoloc}\cup{\rpre}$.


Bad example:
\begin{gather*}
  \PEXCHG{x}{r}{2}\SEMI 
  \PR{x}{s}\SEMI
  \PW{y}{s{-}1} \PAR
  \PR{y}{r}\SEMI
  \PW{x}{r}
  \\
  \tag{\cmark\armeight}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DR{x}{1}}{}
      \event{b}{\DW{x}{2}}{right=of a}
      \event{c}{\DR{x}{2}}{right=of b}
      \event{d}{\DW{y}{1}}{right=of c}
      \event{e}{\DR{y}{1}}{right=3em of d}
      \event{f}{\DW{x}{1}}{right=of e}
      \pre{a}{b}
      \rf{b}{c}
      \lob{c}{d}
      \rf{d}{e}
      \pre{e}{f}
      \rf[out=-165,in=-15]{f}{a}
    \end{tikzinline}}
  % \hbox{\begin{tikzinline}[node distance=1.5em]
  %   \event{a}{\DR{x}{1}}{}
  %   \event{b}{\DW{x}{2}}{right=of a}
  %   \event{c}{\DR{x}{2}}{right=of b}
  %   \event{d}{\DW{y}{1}}{right=of c}
  %   \event{e}{\DR{y}{1}}{right=3em of d}
  %   \event{f}{\DW{x}{1}}{right=of e}
  %   \rmw{a}{b}
  %   \rfi{b}{c}
  %   \dob{c}{d}
  %   \rfe{d}{e}
  %   \dob{e}{f}
  %   \rfe[out=-165,in=-15]{f}{a}
  % \end{tikzinline}}
  \\
  \tag{$\le$}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DR{x}{1}}{}
      \event{b}{\DW{x}{2}}{right=of a}
      \event{c}{\DR{x}{2}}{right=of b}
      \event{d}{\DW{y}{1}}{right=of c}
      \event{e}{\DR{y}{1}}{right=3em of d}
      \event{f}{\DW{x}{1}}{right=of e}
      \rmw{a}{b}
      \rf{b}{c}
      % \po{c}{d}
      \rf{d}{e}
      \po{e}{f}
      \rf[out=-165,in=-15]{f}{a}
    \end{tikzinline}}
\end{gather*}
Anton example 1 \texttt{[rfi-coe-coe]}
\begin{gather*}
  \taglabel{rfi-coe-coe}
  \PW{x}{2}\SEMI 
  \PR[\mACQ]{x}{r}\SEMI
  \PW{y}{1} \PAR
  \PW{y}{2}\SEMI
  \PW[\mREL]{x}{1}
  \\
  \tag{\cmark\armeight}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DW{x}{2}}{}
      \raevent{b}{\DR[\mACQ]{x}{2}}{right=of a}
      \event{c}{\DW{y}{1}}{right=of b}
      \event{d}{\DW{y}{2}}{right=2.5em of c}
      \raevent{e}{\DW[\mREL]{x}{1}}{right=of d}
      \rfi{a}{b}
      \bob{b}{c}
      \coe{c}{d}
      \bob{d}{e}
      \coe[out=-165,in=-15]{e}{a}
    \end{tikzinline}}
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a}{\DW{x}{2}}{}
      \event{b}{\DR{x}{2}}{right=of a}
      \event{c}{\DW{y}{1}}{right=of b}
      \event{d}{\DW{y}{2}}{right=2.5em of c}
      \raevent{e}{\DW[\mREL]{x}{1}}{right=of d}
      \rf{a}{b}
      \wk{c}{d}
      \sync{d}{e}
      \wk[out=-165,in=-15]{e}{a}
    \end{tikzinline}}
\end{gather*}

\endinput
\section{OLD}
\subsection{Pomsets}
\label{sec:pomsets}

We first consider a fragment of our language that can be modeled using simple
pomsets.  This captures read and write actions which may be reordered,
but as we shall see does \emph{not} capture control or data dependencies.

\begin{definition}
  \label{def:pomsets}
  A \emph{pomset} over $\Act$ is a tuple
  $(\Event, {\le}, \labeling)$ where
  \begin{itemize}
  \item $\Event\subset\AllEvents$ is a set of \emph{events},
  \item
    ${\le} \subseteq (\Event\times\Event)$ is the \emph{causality} partial order, 
  \item
    $\labeling: \Event \fun \Act$ is a \emph{labeling}.
  \end{itemize}
\end{definition}
Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.  Let $\Pom$
be the set of all pomsets.

We lift terminology from actions to events.  For example, we say that $\aEv$
writes $\aLoc$ if $\labeling(\aEv)$ writes $\aLoc$.  We also drop quantifiers
when clear from context, such as
$(\forall\aEv\in\Event)(\forall\aLoc\in\Loc)$.

\begin{definition}
  \label{def:fulfilled}
  Action $\DWP{\aLoc}{\aVal} \rmatchesdef \DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.
  Action $\DWP{\aLoc}{\aVal} \rblocksdef \DRP{\aLoc}{\bVal}$, for any
  $\aVal$, $\bVal$.
  
  % A pomset $\aPS$ is \emph{closed} if for every $\aEv$ which can be
  % fulfilled, there is a $\bEv\le\aEv$ which fulfills it, and for any $\cEv$
  % which can block $\aEv$, either $\cEv\le\bEv$ or $\aEv\le\cEv$.

  A read event $\aEv$ is \emph{fulfilled} if there is a $\bEv\le\aEv$ which
  matches it and, for any $\cEv$ which can block $\aEv$, either $\cEv\le\bEv$
  or $\aEv\le\cEv$.

  % Pomset $\aPS$ is \emph{fulfilled} if every read in $\aPS$ is fulfilled.
\end{definition}

We introduce reorderability \cite{DBLP:books/ws/95/Mazurkiewicz95} in order to
provide examples with coherence in this subsection.  In
\textsection\ref{sec:q} we show that coherence can be encoded in the logic,
making reorderability unnecessary.
\begin{definition}
  Actions $\aAct$ and $\bAct$ are \emph{reorderable}
  (${\aAct\reorder\bAct}$) if either both are reads or they are accesses to
  different locations.  Formally
  \begin{math}
    {\reorder} = \{(\DR{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \}
    \cup\{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}.
  \end{math}
  % \emph{Independency} (${\reorder}\subseteq\Act\times\Act$), is defined:
  \begin{comment}
    % {\reorderSC} &= \emptyset
    % \\
    % {\reorderRLX} &=
    \reorder &=
    \{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}
    \\[-.5ex]&\mkern2mu\cup\mkern2mu
    \{(\DR{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \}
    % \\[-.5ex]&\mkern2mu\cup\mkern2mu
    % \{(\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc \lor \aVal=\bVal\}
    % \\[-.5ex]&\mkern2mu\cup\mkern2mu
    % \{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}
  \end{comment}

  Actions that are not reorderable are in \emph{conflict}.
\end{definition}
We can now define a model of processes given as sets of pomsets
sufficient to give the semantics for a fragment of our language
without control or data dependencies.
\begin{definition} %$\phantom{\;}$\par
  \label{def:pomset-semantics}

  \noindent
  If $\aPS\in\sNIL$ then $\aEvs = \emptyset$.

  \noindent
  If $\aPS \in \sPAR{\aPSS_1}{\aPSS_2}$ then  
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}[topsep=0pt]
  \item \label{par-E}
    $\aEvs = (\aEvs_1\cup\aEvs_2)$,
  \item \label{par-le1}
    if $\bEv\le_1\aEv$ then $\bEv\le\aEv$, 
  \item \label{par-le2}
    if $\bEv\le_2\aEv$ then $\bEv\le\aEv$, 
  \item \label{par-lambda1}
    if $\aEv\in\aEvs_1$ then $\labeling(\aEv) = \labeling_1(\aEv)$, 
  \item \label{par-lambda2x}
    if $\aEv\in\aEvs_2$ then $\labeling(\aEv) = \labeling_2(\aEv)$,
    \label{pomsetParCountLast}
    \newcounter{pomsetParCount}
    \setcounter{pomsetParCount}{\value{enumi}}
  \item \label{par-disjoint}
    $\aEvs_1$ and $\aEvs_2$ are disjoint.
    \label{pomsetParDisjointCountLast}
    \newcounter{pomsetParDisjointCount}
    \setcounter{pomsetParDisjointCount}{\value{enumi}}
  \end{enumerate}
  \noindent
  If $\aPS \in (\aAct\sPREFIX\aPSS_2)$ then
  $(\exists\aEvs_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}[topsep=0pt]
  \item \label{pre-E}
    $\aEvs=(\aEvs_1 \cup \aEvs_2)$,
  \item \label{pre-unique}
    if $\bEv,\aEv\in\aEvs_1$ then $\bEv=\aEv$,
  \item \label{pre-le2}
    if $\bEv\le_2\aEv$ then $\bEv\le\aEv$, 
  \item \label{pre-lambda1}
    if $\aEv\in\aEvs_1$ then $\labelingAct(\aEv) = \aAct$,
  \item \label{pre-lambda2}
    if $\aEv\in\aEvs_2$ then $\labelingAct(\aEv) = \labelingAct_2(\aEv)$,
  \item
    \label{pre-reorder}
    if $\bEv\in\aEvs_1$, $\aEv\in\aEvs_2$ then either
    $\bEv\leq\aEv$ or $a\reorder\labeling_2(\aEv)$.
    \label{pomsetPrefixOrderCountLast}
    % \newcounter{pomsetPrefixCount}
    % \setcounter{pomsetPrefixCount}{\value{enumi}}
    \newcounter{pomsetPrefixOrderCount}
    \setcounter{pomsetPrefixOrderCount}{\value{enumi}}    
  \end{enumerate}
  \noindent
  If $\aPS \in \sTOP{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}[topsep=0pt]
  \item  \label{top-E} % [{\labeltext[T1]{T1)}{T1}}]
    $\aEvs=\aEvs_1$,
  \item  \label{top-lambda} % [{\labeltext[T2]{T2)}{T2}}]
    $\labelingAct(\aEv) = \labelingAct_1(\aEv)$,
  \item  \label{top-le} % [{\labeltext[T2]{T2)}{T2}}]
    if $\bEv\le_1\aEv$ then $\bEv\le\aEv$, 
  \item  \label{top-fulfilled} % [{\labeltext[T3]{T3)}{T3}}]
    if $\labelingAct_1(\aEv)$ is a read then
    $\aEv$ is fulfilled (\refdef{def:fulfilled}).
    \label{pomsetTopCountLast}
    \newcounter{pomsetTopCount}
    \setcounter{pomsetTopCount}{\value{enumi}}
  \end{enumerate}  
\end{definition}
\begin{definition}
  \noindent
  For a language fragment, the semantics is:
  \begin{align*}
    \sem{\PW[\amode]{\aLoc}{\aVal}\SEMI \aCmd} &= \textstyle\DWP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
    &
    \sem{\SKIP} &= \sem{\NIL} = \sNIL 
    \\
    \sem{\PR[\amode]{\aLoc}{\aReg}\SEMI \aCmd} &= \textstyle\bigcup_{\aVal}\DRP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
    &
    \sem{\aCmd_1 \PAR \aCmd_2} &= \sPAR{\sem{\aCmd_1}}{\sem{\aCmd_2}}
    % \\
    % \sem{\PA{\aLoc}{\aVal}\SEMI \aCmd} &= \textstyle\DRP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
  \end{align*}
  % Let $\aPSS$ range over sets of pomsets.
\end{definition}

In this semantics, both $\SKIP$ and $\NIL$ map to the empty pomset.  Parallel
composition is disjoint union, inheriting labeling and order from the two
sides.  Prefixing may add a new action (on the left) to an existing pomset
(on the right), inheriting labeling and order from the right.  

It is worth noting that if ${\reorder}$ is taken to be the empty relation,
then top-level pomsets of \refdef{def:pomsets} correspond to sequentially
consistent executions up to mumbling
\cite{DBLP:journals/iandc/Brookes96}.

\begin{example}
  \label{ex:mumble1}
  Mumbling is allowed, since there is no requirement that left and right be
  disjoint in the definition of prefixing.  Both of the pomsets below are
  allowed.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1} \SEMI \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{\DW{x}{1}}{}
          \event{a2}{\DW{x}{1}}{right=of a1}
          \wk{a1}{a2}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{1} \SEMI \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{\DW{x}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  In the left pomset, the order between the events is enforced by clause
  \ref{pre-reorder}, since the actions are in conflict.
\end{example}

\begin{example}
  \label{ex:pub1}
  Although this model enforces coherence, it is very weak.  For example, it
  makes no distinction between synchronizing and relaxed access, thus
  allowing:
  \begin{gather*}
    \PW{x}{0}\SEMI 
    \PW{x}{1}\SEMI \PW[\mREL]{y}{1} \PAR \PR[\mACQ]{y}{r} \SEMI \PR{x}{s} 
    \\[-.4ex]
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wx0}{\DW{x}{0}}{}
        \event{wx1}{\DW{x}{1}}{right=of wx0}
        \raevent{wy1}{\DW[\mREL]{y}{1}}{right=of wx1}
        \raevent{ry1}{\DR[\mACQ]{y}{1}}{right=2.5em of wy1}
        \event{rx0}{\DR{x}{0}}{right=of ry1}
        % \sync{wx1}{wy1}
        % \sync{ry1}{rx0}
        \rf{wy1}{ry1}
        \wk[in=-15,out=-165]{rx0}{wx1}
        \wk{wx0}{wx1}
        \rf[out=15,in=165]{wx0}{rx0}
      \end{tikzinline}}
  \end{gather*}  
  We show how to enforce the intended semantics, where $\DWP[\mREL]{y}{1}$
  \emph{publishes} $\DWP{x}{1}$ in \refex{ex:pub2}.
\end{example}
In diagrams, we use different shapes and colors for arrows and events.  These
are included only to help the reader understand why order is included.  We
adopt the following conventions (dependency and synchronization order will
appear later in the paper):
\begin{itemize}  
\item relaxed accesses are blue, with a single border,
\item synchronized accesses are red, with a double border,
  % \item sequentially-consistent accesses are orange, with a bold double
  %   border,
\item \makebox{$\aEv\xrf\bEv$} arises from fulfillment, where $\aEv$ \emph{matches} $\bEv$,
\item \makebox{$\aEv\xwk\bEv$} arises either from fulfillment, where $\aEv$
  \emph{blocks} $\bEv$, or from prefixing, where $\aEv$ was prefixed before
  $\bEv$ and their actions \emph{conflict},
\item \makebox{$\aEv\xpo\bEv$} arises from control/data/address \emph{dependency},% (eg, control),
\item \makebox{$\aEv\xsync\bEv$} arises from \emph{synchronized access}.
\end{itemize}

\begin{definition}
  $\aPSS_1$ \emph{refines} $\aPSS_2$ if $\aPSS_1\subseteq\aPSS_2$.
\end{definition}

\begin{example}
  \refex{ex:mumble1} shows that $\sem{\PW{x}{1}}$ refines $\sem{\PW{x}{1}\SEMI\PW{x}{1}}$.
\end{example}

\subsection{Pomsets with Preconditions}
\label{sec:pomsets-pre}

The previous section modeled a language fragment without conditionals (and hence no
control dependencies) or expressions (and hence no data dependencies). We now
address this, by adopting a \emph{pomsets with preconditions} model
similar to~\cite{DBLP:journals/pacmpl/JagadeesanJR20}.
% restricting attention to relaxed access.
% We discuss the differences in \S\ref{sec:discussion}.

\begin{definition}
  A \emph{pomset with preconditions} is
  a pomset (\refdef{def:pomsets}) together with $\labelingForm:\aEvs\fun\Formulae$.
\end{definition}
\begin{definition}
  \label{def:q-sub}
  Let $[\aForm/\Q{}]$ substitute all quiescence symbols by $\aForm$.
\end{definition}


% \begin{definition}
%   Let $\aSub$ be a substitution.  If $\aPS\in(\aPSS\aSub)$ then
%   $(\exists\aPS\in\aPSS)$ $\Event = \Event'$, ${\le} = {\le'}$,
%   $\labelingAct = \labelingAct'$, and
%   $\labelingForm(\aEv) = \labelingForm'(\aEv)\aSub$.
% \end{definition}

% Definition \ref{def:pomsets-pre}, describes operators 
% sufficient to give the semantics to a larger fragment of our language:
We can now define a model of processes given as sets of pomsets with preconditions
sufficient to give the semantics for a fragment of our language
where every use of sequential composition is either
$(\PW[\amode]{\aLoc}{\aExp}\SEMI \aCmd)$ or
$(\PR[\amode]{\aLoc}{\aReg}\SEMI \aCmd)$.
\begin{definition}%$\phantom{\;}$\par
  \label{def:pomsets-pre}
  
  \noindent
  If $\aPS\in\sNIL$ then $\aEvs = \emptyset$.

  \noindent
  If $\aPS \in \sPAR{\aPSS_1}{\aPSS_2}$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetParDisjointCount}}
  \item[1--\ref{pomsetParDisjointCountLast})]
    as for $\sPAR{}{}$ in \refdef{def:pomset-semantics},
  \item %\label{par-kappa1}
    if $\aEv\in\aEvs_1$ then $\labelingForm(\aEv) \rimplies \labelingForm_1(\aEv)$,
  \item %\label{par-kappa2}
    if $\aEv\in\aEvs_2$ then $\labelingForm(\aEv) \rimplies \labelingForm_2(\aEv)$.
    \newcounter{pomsetPreParCount}
    \setcounter{pomsetPreParCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS \in \sIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[1--\ref{pomsetParCountLast})] 
    as for $\sPAR{}{}$  in \refdef{def:pomset-semantics} (ignoring disjointness),
  \item \label{if-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv) \rimplies \aForm\land\labelingForm_1(\aEv)$,
  \item \label{if-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv) \rimplies \neg\aForm\land\labelingForm_2(\aEv)$, 
  \item %\label{if-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then\\
    $\labelingForm(\aEv) \rimplies (\aForm\limplies\labelingForm_1(\aEv))\land(\neg\aForm\limplies\labelingForm_2(\aEv))$.
    % $\labelingForm(\aEv) \rimplies (\aForm\land\labelingForm_1(\aEv))\lor(\neg\aForm\land\labelingForm_2(\aEv))$.
    \label{pomsetPreIfCountLast}
    \newcounter{pomsetPreIfCount}
    \setcounter{pomsetPreIfCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS \in \sSTOREPRE{\aLoc}{\aExp}{\aPSS_2}$ then
  $(\exists\aPS_2\in\aPSS_2)$
  $(\exists\aVal\in\Val)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetPrefixOrderCount}}
  \item[1--\ref{pomsetPrefixOrderCountLast})]
    as for $\DWP{\aLoc}{\aVal}\sPREFIX\aPSS_2$ in \refdef{def:pomset-semantics}, % (ignoring \thepomsetPrefixOrderCount),
  \item \label{storepre-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv) \rimplies \aExp{=}\aVal$,
  \item \label{storepre-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv) \rimplies \labelingForm_2(\aEv)$,
  \item \label{storepre-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm(\aEv) \rimplies \aExp{=}\aVal \lor \labelingForm_2(\aEv)$.
    % \item if $\aEv\in\aEvs_2$ then either
    %   $\labelingForm(\aEv) \rimplies \labelingForm_2(\aEv)$ or\\
    %   $\aEv\in\aEvs_1$ and $\labelingForm(\aEv) \rimplies (\aExp{=}\aVal)\lor \labelingForm_2(\aEv)$.
  \end{enumerate}

  \noindent
  If $\aPS \in \sLOADPRE{\aReg}{\aLoc}{\aPSS_2}$ then
  $(\exists\aPS_2\in\aPSS_2)$
  $(\exists\aVal\in\Val)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetPrefixOrderCount}}
  \item[1--\ref{pomsetPrefixOrderCountLast})]
    as for $\DRP{\aLoc}{\aVal}\sPREFIX\aPSS_2$ in \refdef{def:pomset-semantics}, % (ignoring \thepomsetPrefixOrderCount),
  \item \label{loadpre-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then either \\
    $\labelingForm(\aEv) \rimplies \aReg{=}\aVal\limplies\labelingForm_2(\aEv)$ and $(\exists\bEv\in\aEvs_1)\;\bEv<\aEv$, or \\
    $\labelingForm(\aEv) \rimplies \labelingForm_2(\aEv)$.
    % \\ \mbox{$\quad$} for some $\bEv\in\aEvs_1$.
  \end{enumerate}  

  \label{def:pomsets-top}
  \labeltext[\ensuremath{\sTOP{}}]{}{sTOP}
  \noindent
  If $\aPS \in \sTOP{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetTopCount}}
  \item[1--\ref{pomsetTopCountLast})] % \label{top-E} % [{\labeltext[T1]{T1)}{T1}}]
    as for $\sTOP{}$ in \refdef{def:pomset-semantics},
  \item \label{top-kappa-write} % [{\labeltext[T3]{T3)}{T3}}]
    if $\labelingAct_1(\aEv)$ is a write,
    $\labelingForm_1(\aEv) [\TRUE/\Q{}][\TRUE/\RW]$ is a tautology,
  \item \label{top-kappa-read} % [{\labeltext[T3]{T3)}{T3}}]
    if $\labelingAct_1(\aEv)$ is a read,
    $\labelingForm_1(\aEv) [\TRUE/\Q{}][\FALSE/\RW]$ is a tautology.
    \newcounter{pomsetPreTopCount}
    \setcounter{pomsetPreTopCount}{\value{enumi}}
  \end{enumerate}  
\end{definition}
Let $\PomPre$ be the set of all pomsets with preconditions.
% A pomset with preconditions is \emph{top level} if it is fulfilled
% (\refdef{def:fulfilled}) and every precondition is a tautology.
The function $\sTOP{}:2^{\PomPre}\fun2^{\Pom}$ embeds sets of pomsets with preconditions into sets of
pomsets.  It also substitutes formulae for quiescence and write symbols, for
use in \textsection\ref{sec:q}-\ref{sec:arm}.  In these ``top-level''
pomsets, every read is fulfilled and every precondition is a tautology.
\begin{definition}
  \noindent
  For a language fragment, the semantics is:
  \begin{gather*}
    \sem{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} = \sIFTHEN{\aExp{\neq}0}{\sem{\aCmd_1}}{\sem{\aCmd_2}}
    \\
    \begin{aligned}
      \sem{\PW[\amode]{\aLoc}{\aExp}\SEMI \aCmd} &=
      \sSTOREPRE{\aLoc}{\aExp}{\sem{\aCmd}}
      &
      \sem{\SKIP} &= \sem{\NIL} = \sNIL 
      \\
      \sem{\PR[\amode]{\aLoc}{\aReg}\SEMI \aCmd} &=
      \sLOADPRE{\aReg}{\aLoc}{\sem{\aCmd}}
      &
      \makebox[3.5em][r]{$\sem{\aCmd_1 \PAR \aCmd_2}$} &= \sPAR{\sem{\aCmd_1}}{\sem{\aCmd_2}}
    \end{aligned}
  \end{gather*}
\end{definition}
%% Following our convention for subscripts, in the final clause of
%% $\sLOADPRE{}{}{}$, $<$ refers to the order of $\aPS$.  Also note that
%% $\sLOADPRE{}{}{}$ does not constrain $\labelingForm(\aEv)$ if
%% $\aEv\in\aEvs_1$.

\begin{example}
  \label{ex:data}
  A simple example of a data dependency
  is a pomset $\aPS\in\sem{\PR{x}{r}\SEMI \PW{y}{r}}$,
  for which there must be an $\aVal\in\Val$ and $\aPS'\in \sem{\PW{y}{r}}$
  such as the following, where $\aVal=1$:
  % \vspace{-.5\baselineskip}
  \begin{gather*}
    \PW{y}{r}
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{r{=}1\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gather*}
  The value chosen for the read may be different from that chosen for the write:
  % \vspace{-.5\baselineskip}
  \begin{gather*}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx0}{\DR{x}{0}}{}
        \event{wy1}{r{=}0\limplies r{=}1 \mid \DW{y}{1}}{right=of rx0}
        \po{rx0}{wy1}
      \end{tikzinline}}
  \end{gather*}
  In this case, the pomset's preconditions depend on a bound register, so
  cannot contribute to a top-level pomset.

  If the values chosen for read and write are compatible, then we have two
  cases: the independent case, which again cannot be part of a top-level
  pomset,
  \begin{gather*}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx1}{\DR{x}{1}}{}
        \event{wy1}{r{=}1 \mid \DW{y}{1}}{right=of rx1}
      \end{tikzinline}}
  \end{gather*}
  and the dependent case:
  \begin{gather*}
    % \PR{x}{r}\SEMI \PW{y}{r}
    % \\
    % \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx1}{\DR{x}{1}}{}
        \event{wy1}{r{=}1\limplies r{=}1 \mid \DW{y}{1}}{right=of rx1}
        \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gather*}
  Since $r{=}1\limplies r{=}1$ is a tautology, this can be part of
  a top-level pomset.
\end{example}

\begin{example}
  Control dependencies are similar, for example
  for any $\aPS\in\sem{\PR{x}{r}\SEMI \IF r \THEN \PW{y}{1} \FI}$,
  there must be an $\aVal\in\Val$ and $\aPS'\in \sem{\IF r \THEN \PW{y}{1} \FI}$
  such as:
  \begin{gather*}
    \IF r \THEN \PW{y}{1} \FI
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{r{\ne}0\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gather*}
  The rest of the reasoning is the same as \refex{ex:data}.
\end{example}

\begin{example}
  A simple example of an independency
  is a pomset $\aPS\in\sem{\PR{x}{r}\SEMI \PW{y}{1}}$,
  for which there must be:
  % an %$\aVal\in\Val$ and
  % $\aPS'\in \sem{\PW{y}{r}}$
  % such as:
  % \vspace{-1\baselineskip}
  \begin{gather*}
    \PW{y}{1}
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{1{=}1\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gather*}
  In this case it doesn't matter what value the read chooses:
  \begin{gather*}
    \PR{x}{r}\SEMI \PW{y}{1}
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx0}{\DR{x}{0}}{}
        \event{wy1}{1{=}1 \mid \DW{y}{1}}{right=of rx0}
      \end{tikzinline}}
  \end{gather*}
  % Since $1{=}1$ is a tautology, this can be part of
  % a top-level pomset.
\end{example}

\begin{example}
  Consider $\aPS\in\sem{\IF {r{=}1} \THEN \PW{y}{r} \ELSE \PW{y}{1}\FI}$, so
  there must be $\aPS_1\in\sem{\PW{y}{r}}$,
  and $\aPS_2\in\sem{\PW{y}{1}}$, such as:
  \begin{align*}
    \begin{gathered}
      \PW{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
          \event{wy1}{r{=}1 \mid \DW{y}{1}}{}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{y}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
          \event{wy1}{1{=}1 \mid \DW{y}{1}}{}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  Since there is no requirement for disjointness in the semantics of conditionals,
  we can consider the case where the event \emph{coalesces} from the two pomsets,
  in which case:
  \begin{gather*}
    \IF{r{=}1} \THEN \PW{y}{r} \ELSE \PW{y}{1}\FI
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{(r{=}1 \limplies r{=}1) \land (r{\ne}1 \limplies 1{=}1) \mid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gather*}
  Here, the precondition is a tautology, 
  independent of $r$.
  % We refer to event sharing as \emph{coalescing} or \emph{merging}.
\end{example}

\subsection{Pomsets with Predicate Transformers}
\label{sec:pomsets-trans}

Having reviewed the work we are building on, we now turn to
the contribution of this paper, which is a model of \emph{pomsets with predicate transformers}.
\emph{Predicate transformers} are
functions on formulae which preserve logical structure, providing a natural model of sequential composition.


\begin{definition}
  \label{def:trans}
  A \emph{predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{itemize}
  \item $\aTr{}{\FALSE}$ is $\FALSE$,    
  \item $\aTr{}{\bForm_1\land\bForm_2}$ is $\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$,    
  \item $\aTr{}{\bForm_1\lor\bForm_2}$ is $\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$, 
  \item if $\aForm \rimplies \bForm$, then $\aTr{}{\aForm} \rimplies \aTr{}{\bForm}$.
  \end{itemize}
\end{definition}
\noindent
Note that substitutions ($\aTr{}{\psi}=\psi[\aExp/\aReg]$) and implications on the right
($\aTr{}{\psi}=\phi\limplies\psi$) are predicate transformers.

As discussed in \S\ref{sec:intro}, predicate transformers suffice for sequentially consistent
models, but not relaxed models, where dependency calculation is crucial.
For dependency calculation, we use a \emph{family} of predicate transformers,
indexed by sets of events. We use $\aTr{\bEvs}{}$ as the predicate transformer
applied to any event $\aEv$ where if $\bEv\in\bEvs$ then $\bEv<\aEv$.

\begin{definition}
  \label{def:family}
  A \emph{family of predicate transformers} for $\aEvs$ consists of a
  predicate transformer $\aTr{\bEvs}{}$ for each $\bEvs\subseteq\AllEvents$,
  such that if $\cEvs \cap \aEvs \subseteq \bEvs$ then $\aTr{\cEvs}{\bForm}
  \rimplies \aTr{\bEvs}{\bForm}$.

  We write $\aTr{}{}$ as an abbreviation of $\aTr{\aEvs}{}$.
\end{definition}

%% Note that in a family of predicate transformers for $\aEvs$, transformers for
%% smaller subsets of $\aEvs$ are stronger.

\begin{definition}
  A \emph{pomset with predicate transformers} is a pomset with preconditions (\refdef{def:pomsets-pre}),
  together with a family of predicate transformers for $\aEvs$.
\end{definition}
\begin{comment}
  Let $\PomTrans$ be the set of all pomsets with predicate transformers.
  % \begin{definition}
  %   For pomset $\aPS$ and $\aEv\in\aEvs$, let
  %   $\downclose[0]{\aEv} = \{ \bEv\in\aEvs \mid \bEv < \aEv \}$.
  % \end{definition}
  We can covert between pomsets with preconditions and pomsets with predicate
  transformers. In one direction, $\sTHREAD{}:2^{\PomTrans}\fun2^{\PomPre}$
  drops predicate transformers, and in the other,
  $\sFORK{}:2^{\PomPre}\fun2^{\PomTrans}$ adopts the identity transformer.

  \begin{definition}
    \label{def:pomsets-group}
    \noindent
    If $\aPS \in \sTHREAD{\aPSS}$ then
    $(\exists\aPS_1\in\aPSS)$
    \begin{enumerate}[topsep=0pt]
    \item  \label{thread-E} % [{\labeltext[T1]{T1)}{T1}}]
      $\aEvs=\aEvs_1$,
    \item  \label{thread-lambda} % [{\labeltext[T2]{T2)}{T2}}]
      $\labelingAct(\aEv) = \labelingAct_1(\aEv)$,
    \item \label{thread-le} % [{\labeltext[T2]{T2)}{T2}}]
      if $\bEv\le_1\aEv$ then $\bEv\le\aEv$,
    \item  \label{thread-kappa}\label{T3} % [{\labeltext[T3]{T3)}{T3}}]
      $\labelingForm(\aEv) \rimplies \labelingForm_1(\aEv)$.
      \newcounter{pomsetXThreadCount}
      \setcounter{pomsetXThreadCount}{\value{enumi}}
    \end{enumerate}  

    \noindent
    If $\aPS \in \sFORK{\aPSS}$ then
    $(\exists\aPS_1\in\aPSS)$
    \begin{enumerate}[topsep=0pt]
    \item \label{fork-E} % [{\labeltext[F1]{F1)}{F1}}]
      $\aEvs=\aEvs_1$,
    \item  \label{fork-lambda} % [{\labeltext[F2]{F2)}{F2}}]
      $\labelingAct(\aEv) = \labelingAct_1(\aEv)$,
    \item \label{fork-le} % [{\labeltext[T2]{T2)}{T2}}]
      if $\bEv\le_1\aEv$ then $\bEv\le\aEv$,
      \newcounter{pomsetXForkCount}
      \setcounter{pomsetXForkCount}{\value{enumi}}
    \item  \label{fork-kappa}\label{F3}  % [{\labeltext[F3]{F3)}{F3}}]
      $\labelingForm(\aEv) \rimplies \labelingForm_1(\aEv)$, 
    \item  \label{fork-tau}\label{F4}  % [{\labeltext[F4]{F4)}{F4}}]
      $\aTr{\bEvs}{\bForm} \rimplies \bForm$.
    \end{enumerate}  
  \end{definition}

  We model thread groups as sets of pomsets with preconditions,
  as in \S\ref{sec:pomsets-pre}.

  \begin{definition}
    \noindent
    Adopting $\sNIL$ and $\sPAR{}{}$ from \refdef{def:pomsets-pre},
    the semantics of thread groups is:
    \begin{align*}
      \sem{\THREAD{\aCmd}} &= \sTHREAD{}\sem{\aCmd}
      &
      \sem{\aGrp_1 \PAR \aGrp_2} &= \sPAR{\sem{\aGrp_1}}{\sem{\aGrp_2}}
      &
      \sem{\NIL} &= \sNIL     
    \end{align*}
    % , and
    % $\sTHREAD{}$ is as follows.
  \end{definition}

  We model commands by adding predicate transformers to
  \refdef{def:pomsets-pre}, in order to calculate preconditions.
\end{comment}
\begin{definition}
  \label{def:pomsets-trans}

  \noindent
  If $\aPS\in\sABORT$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm} \rimplies \FALSE$.
  \end{itemize}

  \noindent
  If $\aPS\in\sSKIP$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm} \rimplies \bForm$.
  \end{itemize}

  \noindent
  If $\aPS\in\sLET{\aReg}{\aExp}$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm} \rimplies \bForm[\aExp/\aReg]$.
  \end{itemize}

  \noindent
  If $\aPS \in \sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetPreIfCount}}
  \item[1--\ref{pomsetPreIfCountLast})] as for $\sIF{}$ in \refdef{def:pomsets-pre},
  \item \label{if-tau}
    $\aTr{\bEvs}{\bForm} \rimplies (\aForm\limplies\aTr[1]{\bEvs}{\bForm})\land(\neg\aForm\limplies\aTr[2]{\bEvs}{\bForm})$.
    % $(\aForm\land\aTr[1]{\bEvs%\cap\aEvs_1
    % }{\bForm})\lor(\neg\aForm\land\aTr[2]{\bEvs%\cap\aEvs_2
    % }{\bForm})$.
  \end{enumerate}

  \noindent
  If $\aPS \in \sLPAR{\aPSS_1}{\aPSS_2}$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetPreParCount}}
  \item[\ref{par-E}--\ref{par-kappa2})]
    as for $\sPAR{}{}$ in \refdef{def:pomsets-pre},
  \item \label{par-tau1}
    $\aTr{\bEvs}{\bForm} \rimplies \aTr[2]{\bEvs}{\bForm}$,
  \item \label{par-tau2}
    $\aTr{\bEvs}{\aSym} \rimplies \aTr[1]{\bEvs}{\aSym}$,
    for every quiescence symbol $\aSym$.
  \end{enumerate}

  \noindent
  If $\aPS \in \sSEMI{\aPSS_1}{\aPSS_2}$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  % let $\labelingForm'_2(\aEv)=\aTr[1]{{\downclose[0]{\aEv}}}{\labelingForm_2(\aEv)}$  
  % let $\labelingForm'_2(\aEv)=\aTr[1]{\{ \bEv \mid \bEv < \aEv \}}{\labelingForm_2(\aEv})$  
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[1--\ref{pomsetParCountLast})]
    as for $\sPAR{}{}$  in \refdef{def:pomset-semantics} (ignoring disjointness),
  \item \label{seq-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv) \rimplies \labelingForm_1(\aEv)$,
  \item \label{seq-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv) \rimplies \labelingForm'_2(\aEv)$,
  \item \label{seq-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm(\aEv) \rimplies \labelingForm_1(\aEv)\lor\labelingForm'_2(\aEv)$,
    \\ where $\labelingForm'_2(\aEv)=\aTr[1]{\cEvs%\cap\aEvs_1
    }{\labelingForm_2(\aEv})$, where $\cEvs=\{ \cEv \mid \cEv < \aEv \}$,
  \item \label{seq-tau}
    $\aTr{\bEvs}{\bForm} \rimplies \aTr[1]{\bEvs}{\aTr[2]{\bEvs}{\bForm}}$.
    \newcounter{pomsetXSemiCount}
    \setcounter{pomsetXSemiCount}{\value{enumi}}
    % \item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ either $\bEv<\aEv$ or $a\reorder\labeling_2(\aEv)$.
  \end{enumerate}
  % where we define $\labelingForm'_2(\aEv)$ to be $\aTr[1]{\{ \bEv \mid \bEv < \aEv \}}{\labelingForm_2(\aEv})$.

  \noindent
  If $\aPS \in \sSTORE[\amode]{\aLoc}{\aExp}$ then
  $(\exists\aVal\in\Val)$
  % $(\forall\bEvs\neq\emptyset)$
  \begin{enumerate}[topsep=0pt]
  \item[{\labeltext[S1]{S1)}{S1}}]
    if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item[{\labeltext[S2]{S2)}{S2}}]
    $\labelingAct(\aEv) = \DW{\aLoc}{\aVal}$,
  \item[{\labeltext[S3]{S3)}{S3}}]
    $\labelingForm(\aEv) \rimplies \aExp{=}\aVal$,
  \item[{\labeltext[S4]{S4)}{S4}}]
    $\aTr{\bEvs}{\bForm} \rimplies \bForm\noSUB{[\aExp/\aLoc]}\land\aExp{=}\aVal$, % \land (\Q{}\limplies\aExp{=}\aVal)$,
  \item[{\labeltext[S5]{S5)}{S5}}]
    $\aTr{\cEvs}{\bForm} \rimplies \bForm\noSUB{[\aExp/\aLoc]}$, % \land % \lnot\Q{}$.
    \\ where $\bEvs\cap\aEvs\neq\emptyset$ and $\cEvs\cap\aEvs=\emptyset$.
    % \item %if $\bEvs\neq\emptyset$ then
    %   $\aTr{\bEvs}{\bForm} \rimplies (\aExp{=}\aVal) \land \bForm[\aExp/\aLoc]$, if $\bEvs\neq\emptyset$,
    %   \newcounter{pomsetXStoreCount}
    %   \setcounter{pomsetXStoreCount}{\value{enumi}}
  \end{enumerate}

  % \noindent
  % If $\aPS \in \sLOAD[\amode]{\aReg}{\aLoc}$ then
  % $(\exists\aVal\in\Val)$
  % $(\forall\bEvs\neq\emptyset)$
  % \begin{enumerate}[topsep=0pt]
  % \item[{\labeltext[L1]{L1)}{L1}}] 
  %   if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  % \item[{\labeltext[L2]{L2)}{L2}}]
  %   $\labelingAct(\aEv) = \DRP{\aLoc}{\aVal}$,
  % \item[{\labeltext[L3]{L3)}{L3}}]
  %   $\labelingForm(\aEv) \rimplies \TRUE$,
  % \item[{\labeltext[L4]{L4)}{L4}}]
  %   %   if $\bEvs\neq\emptyset$ then
  %   $\aTr{\bEvs}{\bForm} \rimplies %$\phantom{(\aLoc{=}\aReg\lor{}}
  %   \aVal{=}\aReg\limplies\bForm$, 
  % \item[{\labeltext[L5]{L5)}{L5}}]
  %   %   if $\bEvs=\emptyset$ then
  %   $\aTr{\emptyset}{\bForm}\; \rimplies ((\aLoc{=}\aReg\lor\aVal{=}\aReg)\limplies\bForm) \land \lnot\Q{}$.
  % \item[{\labeltext[L6]{L6)}{L6}}]
  %   if $\aEvs=\emptyset$ then
  %   $\aTr{\emptyset}{\bForm}\; \rimplies \bForm \land \lnot\Q{}$.
  % \end{enumerate}

  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}{\aLoc}$ then %either $\aEvs\neq\emptyset$ and
  $(\exists\aVal\in\Val)$
  % $(\forall\bEvs{\neq}\emptyset)$
  \begin{enumerate}[topsep=0pt]
  \item[{\labeltext[L1]{L1)}{L1}}] 
    if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item[{\labeltext[L2]{L2)}{L2}}]
    $\labelingAct(\aEv) = \DR{\aLoc}{\aVal}$,
  \item[{\labeltext[L3]{L3)}{L3}}]
    $\labelingForm(\aEv) \rimplies \TRUE$,
  \item[{\labeltext[L4]{L4)}{L4}}]
    $\aTr{\bEvs}{\bForm} \rimplies \aVal{=}\aReg\limplies\bForm$, 
  \item[{\labeltext[L5]{L5)}{L5}}]
    % $\aTr{\cEvs}{\bForm} \rimplies (\aVal{=}\aReg\lor\aLoc{=}\aReg)\limplies\bForm$, % \land \lnot\Q{}$,
    $\aTr{\cEvs}{\bForm} \rimplies \bForm$, % \land \lnot\Q{}$,
    \\ where $\bEvs\cap\aEvs\neq\emptyset$ and $\cEvs\cap\aEvs=\emptyset$,
  \end{enumerate}
  % or
  % $\aEvs=\emptyset$ and 
  % \begin{enumerate}[topsep=0pt]
  % \item[{\labeltext[L6]{L6)}{L6}}] 
  %   $\aTr{\dEvs}{\bForm}\; \rimplies \bForm$. % \land \lnot\Q{}$.
  % \end{enumerate}
  If $\aPS \in \sTOP{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetPreTopCount}}
  \item[1--\ref{top-kappa-read})] as in \refdef{def:pomsets-top},    
  \item $\aTr{\aEvs_1}{\aSym} \rimplies \aSym$, for every quiescence symbol $\aSym$.
  \end{enumerate}
\end{definition}
\begin{definition}
  \label{def:sem-funs}
  \noindent
  The semantics of commands is:
  \begin{scope}
    \allowdisplaybreaks
    \begin{gather*}
      \sem[\aThrd]{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} = \sIFTHEN{\aExp{\neq}0}{\sem[\aThrd]{\aCmd_1}}{\sem[\aThrd]{\aCmd_2}}
      \\
      \begin{aligned}
        \sem[\aThrd]{\PW[\amode]{\aLoc}{\aExp}} &= \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]
        &
        \sem[\aThrd]{\SKIP} &= \sSKIP 
        \\
        \sem[\aThrd]{\PR[\amode]{\aLoc}{\aReg}} &= \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]
        &
        \sem[\aThrd]{\aCmd_1 \LPAR[\bThrd] \aCmd_2} &= \sLPAR{\sem[\aThrd]{\aCmd_1}}{\sem[\bThrd]{\aCmd_2}}
        \\
        \sem[\aThrd]{\LET{\aReg}{\aExp}} &= \sLET{\aReg}{\aExp}
        & 
        \sem[\aThrd]{\aCmd_1 \SEMI \aCmd_2} &= \sSEMI{\sem[\aThrd]{\aCmd_1}}{\sem[\aThrd]{\aCmd_2}}
        \\
        \sem[\aThrd]{\PF[\ascope]{\amode}} &= \sFENCE[\ascope]{\amode}[\aThrd]
        &
      \end{aligned}
    \end{gather*}
  \end{scope}
\end{definition}

Most of these definitions are straightforward adaptations of
\S\ref{sec:pomsets-pre}, but the treatment of sequential composition
is new.  This uses the usual rule for composition of predicate
transformers (but preserving the indexing set). For the pomset, we
take the union of their events, preserving actions, but crucially in
cases~\ref{seq-kappa2} and~\ref{seq-kappa12} we apply a predicate
transformer $\aTr[1]{\cEvs}{}$ from the left-hand side to a precondition
$\labelingForm_2(\aEv)$ from the right-hand side to build the precondition
$\labelingForm'_2(\aEv)$.  The indexing set $\cEvs$ for the predicate
transformer is $\{ \cEv\mid \cEv<\aEv \}$, so can depend on the causal
order.

%% In the predicate transformers for store and load, \ref{S4} and \ref{L4}
%% denote the \emph{dependent case}, whereas \ref{S5} and \ref{L5}
%% denote the \emph{independent case}.  For stores, the dependent and
%% independent cases are the same; this will change in the next section, where
%% we introduce quiescence.  In the dependent case for load, we can assume that
%% $\aReg$ is the value $\aVal$, which has appears in the read action, when
%% proving $\bForm$.  In the independent case for load, we can only make the
%% weaker assumption that either $\aReg$ is $\aVal$ or it is value defined by
%% preceding code for $\aLoc$.  That is, we do not know whether subsequent code
%% sees the value $\aVal$, or the value of some preceding write of $\aLoc$.


% Recall that $\uRegs{\bEvs}=\{\uReg{\bEv}\mid\bEv\in\bEvs\}$.



% [Note that we could change the premise of $\aTr{\emptyset}{}$ in $\sLOAD{}{}$
% from $(\aVal{=}\aReg\lor\aLoc{=}\aReg)$ to $(\aLoc{=}\aReg)$. The
% requirements of a family of predicate transforms effectively adds the
% additional requirement.]


% \aCmd if P is top-level and quiescent then predicate transformer may be wp(\aCmd,phi).
% Only thing is we are substituting v/r, rather than x/r.


% \aCmd any substitution/valuation sigma giving values for register, can find a
% pomset P such that when you apply the substitution to all the preconditions
% are tautologies and if the substitution validates the wp, then the
% substitution validates the $tau_E$

% substitution validates the wp: wp(\aCmd,phi)sigma is a tautology





\begin{comment} Consider the following executions.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{1{=}1\mid\DW{x}{1}}{}
          \xform{x1d}{\bForm[1/x]}{right=of a1}
          \xform{x1i}{\bForm[1/x]}{below=of x1d}
          \xos{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{2{=}1\mid\DW{x}{1}}{}
          \xform{x1d}{\bForm[2/x]}{right=of a1}
          \xform{x1i}{\bForm[2/x]}{below=of x1d}
          \xos{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  % Simplifying:
  % \begin{align*}
  %   \begin{gathered}
  %   %     \PW{x}{1}
  %   %     \\
  %     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %       \event{a1}{\DW{x}{1}}{}
  %       \xform{x1d}{\bForm[1/x]}{right=of a1}
  %       \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %       \xos{a1}{x1d}
  %     \end{tikzinline}}
  %   \end{gathered}
  %   &&
  %   \begin{gathered}
  %   %     \PW{x}{2}
  %   %     \\
  %     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %       \event{a1}{\FALSE\mid\DW{x}{1}}{}
  %       \xform{x1d}{\FALSE}{right=of a1}
  %       \xform{x1i}{\bForm[2/x]}{right=of x1d}
  %       \xos{a1}{x1d}
  %     \end{tikzinline}}
  %   \end{gathered}
  % \end{align*}
  Merging the actions, we have:
  % \begin{gather*}
  %   \PW{x}{1}\SEMI \PW{x}{2}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
  %     \xform{x1d}{(\bForm[1/x])[2/x]}{below=of a1}
  %     \xform{x1i}{(\bForm[1/x])[2/x]}{below=of x1d}
  %     \xos{a1}{x1d}
  %   \end{tikzinline}}
  % \end{gather*}
  % which simplifies to
  % \begin{gather*}
  %   %   \PW{x}{1}\SEMI \PW{x}{2}
  %   %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{a1}{\DW{x}{1}}{}
  %     \xform{x1d}{\bForm[1/x] }{right=of a1}
  %     \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %     \xos{a1}{x1d}
  %   \end{tikzinline}}
  % \end{gather*}
  % which simplifies to
  \begin{gather*}
    \PW{x}{1}\SEMI \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
        \xform{x1d}{(\bForm[2/x])[1/x]}{right=of a1}
        \xform{x1i}{(\bForm[2/x])[1/x]}{right=of x1d}
        \xos{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
  which simplifies to
  \begin{gather*}
    % \PW{x}{1}\SEMI \PW{x}{2}
    % \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{1}}{}
        \xform{x1d}{\bForm[2/x]}{right=of a1}
        \xform{x1i}{\bForm[2/x]}{right=of x1d}
        \xos{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
  % \end{figure}
  % \begin{example} Merging right.
  %   \begin{align*}
  %     \begin{gathered}
  %       \PW{x}{1}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{1{=}2\mid\DW{x}{1}}{}
  %         \xform{x1d}{\bForm[1/x]}{right=of a1}
  %         \xform{x1i}{\bForm[1/x]}{below=of x1d}
  %         \xos{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %     &&
  %     \begin{gathered}
  %       \PW{x}{2}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{2{=}2\mid\DW{x}{1}}{}
  %         \xform{x1d}{\bForm[2/x]}{right=of a1}
  %         \xform{x1i}{\bForm[2/x]}{below=of x1d}
  %         \xos{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %   \end{align*}
  %   Simplifying:
  %   \begin{align*}
  %     \begin{gathered}
  %       \PW{x}{1}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{\FALSE\mid\DW{x}{2}}{}
  %         \xform{x1d}{\FALSE}{right=of a1}
  %         \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %         \xos{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %     &&
  %     \begin{gathered}
  %       \PW{x}{2}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{\DW{x}{2}}{}
  %         \xform{x1d}{\bForm[2/x]}{right=of a1}
  %         \xform{x1i}{\bForm[2/x]}{right=of x1d}
  %         \xos{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %   \end{align*}
  %   Merging the actions, we have:
  The programs are also capable of writing 2.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{1{=}2\mid\DW{x}{2}}{}
          \xform{x1d}{\bForm[1/x]}{right=of a1}
          \xform{x1i}{\bForm[1/x]}{below=of x1d}
          \xos{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{2{=}2\mid\DW{x}{2}}{}
          \xform{x1d}{\bForm[2/x]}{right=of a1}
          \xform{x1i}{\bForm[2/x]}{below=of x1d}
          \xos{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  Merging right.
  \begin{gather*}
    % \PW{x}{1}\SEMI \PW{x}{2}
    % \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{2}}{}
        \xform{x1d}{\bForm[2/x]}{right=of a1}
        \xform{x1i}{\bForm[2/x]}{right=of x1d}
        \xos{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
\end{comment}

\begin{comment}
  Separate actions:
  \begin{align*}
    \begin{gathered}
      \PW{x}{1} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[1/x]}{}
          \xform{xi}{\bForm[1/x]}{below=of xd}
          \event{a1}{1{=}1\mid\DW{x}{1}}{left=of xd}
          \xos{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[2/x]}{}
          \xform{xi}{\bForm[2/x]}{below=of xd}
          \event{a2}{2{=}2\mid\DW{x}{2}}{left=of xd}      
          \xos{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Simplifying:
  \begin{align*}
    \begin{gathered}
      % \PW{x}{1} 
      % \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[1/x]}{}
          \xform{xi}{\bForm[1/x]}{right=of xd}
          \event{a1}{\DW{x}{1}}{left=of xd}
          \xos{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      % \PW{x}{2}
      % \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[2/x]}{}
          \xform{xi}{\bForm[2/x]}{right=of xd}
          \event{a2}{\DW{x}{2}}{left=of xd}      
          \xos{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together unordered:
  \begin{gather*}
    \PW{x}{1}\SEMI \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdi}{\bForm[2/x]}{}
        \xform{xdd}{\bForm[2/x]}{right=of xdi}
        \xform{xid}{\bForm[2/x]}{right=of xdd}
        \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
        \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
        \xform{xii}{\bForm[2/x]}{right=of xid}
        \xos{a1}{xdi}
        \xos{a2}{xid}
        \xos{a1}{xdd}
        \xos{a2}{xdd}
      \end{tikzinline}}
  \end{gather*}
  Adding order does nothing since the preconditions are tautologies.
  % \begin{gather*}
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \xform{xdi}{\bForm[1/x]}{}
  %     \xform{xdd}{\bForm[1/x]}{right=of xdi}
  %     \xform{xid}{\bForm[1/x]}{right=of xdd}
  %     \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
  %     \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
  %     \xform{xii}{\bForm[1/x]}{right=of xid}
  %     \xos{a1}{xdi}
  %     \xos{a2}{xid}
  %     \xos{a1}{xdd}
  %     \xos{a2}{xdd}
  %     \po{a1}{a2}
  %   \end{tikzinline}}
  % \end{gather*}
\end{comment}

\begin{example}
  For read to write dependency, consider:
  \begin{align*}
    \begin{gathered}
      \PR{x}{r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{1{=}r\limplies\bForm}{}
          \xform{xi}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm}{right=.5em of xd}
          \eventl{\bEv}{a1}{\DR{x}{1}}{left=of xd}
          \xos{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{r{=}1\land\bForm\noSUB{[r/y]}}{}
          \xform{xi}{\bForm\noSUB{[r/y]}}{right=.5em of xd}
          \eventl{\aEv}{a2}{r{=}1\mid\DW{y}{1}}{left=of xd}      
          \xos{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together without order,
  we calculate the precondition $\labelingForm(\aEv)$
  as $\aTr[1]{\cEvs}{\labelingForm_2(\aEv)}$, where $\cEvs$ is $\{\cEv\mid\cEv<\aEv\}$, which is $\emptyset$.
  Since $\aTr[1]{\emptyset}{\bForm}$ is $\bForm$, this gives that 
  $\labelingForm(\aEv)$ is $\labelingForm_2(\aEv)$, which is $\aReg{=}1$.
  This gives the pomsaet with predicate transformers:
  \begin{gather*}
    \PR{x}{r} \SEMI
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdd}{1{=}r\limplies(r{=}1\land \bForm\noSUB{[r/y]})}{}
        \xform{xdi}{1{=}r\limplies\bForm\noSUB{[r/y]}}{left=of xdd}
        \xform{xid}{r{=}1\land\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xdd}
        \xform{xii}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xid}
        \eventl{\bEv}{a1}{\DR{x}{1}}{above left=.5em and -2em of xdd}
        \eventl{\aEv}{a2}{\noOR{(x{=}r\lor1{=}r)\limplies} r{=}1\mid\DW{y}{1}}{above right=.5em and -4em of xdd}
        \xos{a1}{xdi}
        \xos{a2}{xid}
        \xos{a1}{xdd}
        \xos{a2}{xdd}
      \end{tikzinline}}
  \end{gather*}
  This pomset's preconditions depend on a bound register, so cannot contribute
  to a top-level pomset.
  
  Putting them together with order,
  we calculate the precondition $\labelingForm(\aEv)$
  as $\aTr[1]{\cEvs}{\labelingForm_2(\aEv)}$, where $\cEvs$ is $\{\cEv\mid\cEv<\aEv\}$, which is $\{\bEv\}$.
  Since $\aTr[1]{\{\bEv\}}{\bForm}$ is $(1{=}\aReg \limplies \bForm)$, this gives that 
  $\labelingForm(\aEv)$ is $(1{=}\aReg \limplies \labelingForm_2(\aEv))$, which is $(1{=}\aReg \limplies \aReg{=}1)$.
  This gives the pomset with predicate transformers:
  \begin{gather*}
    \PR{x}{r} \SEMI
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdd}{1{=}r\limplies(r{=}1\land \bForm\noSUB{[r/y]})}{}
        \xform{xdi}{1{=}r\limplies\bForm\noSUB{[r/y]}}{left=of xdd}
        \xform{xid}{r{=}1\land\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xdd}
        \xform{xii}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xid}
        \eventl{\bEv}{a1}{\DR{x}{1}}{above left=.5em and -2em of xdd}
        \eventl{\aEv}{a2}{1{=}r\limplies r{=}1\mid\DW{y}{1}}{above right=.5em and -4em of xdd}
        \xos{a1}{xdi}
        \xos{a2}{xid}
        \xos{a1}{xdd}
        \xos{a2}{xdd}
        \po{a1}{a2}
      \end{tikzinline}}
  \end{gather*}
  This pomset's preconditions do not depend on a bound register, so can contribute
  to a top-level pomset.
\end{example}

\begin{example}
  If the read and write choose different values:
  \begin{align*}
    \begin{gathered}
      \PR{x}{r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{1{=}r\limplies\bForm}{}
          \xform{xi}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm}{right=.5em of xd}
          \event{a1}{\DR{x}{1}}{left=of xd}
          \xos{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm\noSUB{[r/y]}}{}
          \xform{xi}{r{=}2\land\bForm\noSUB{[r/y]}}{right=.5em of xd}
          \event{a2}{r{=}2\mid\DW{y}{2}}{left=of xd}      
          \xos{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together with order, we have the following, which cannot be
  part of a top-level pomset:
  \begin{gather*}
    \PR{x}{r} \SEMI
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdd}{1{=}r\limplies(r{=}2\land \bForm\noSUB{[r/y]})}{}
        \xform{xdi}{1{=}r\limplies\bForm\noSUB{[r/y]}}{left=of xdd}
        \xform{xid}{r{=}2\land\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xdd}
        \xform{xii}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xid}
        \eventl{\bEv}{a1}{\DR{x}{1}}{above left=.5em and -2em of xdd}
        \eventl{\aEv}{a2}{1{=}r\limplies r{=}2\mid\DW{y}{2}}{above right=.5em and -4em of xdd}
        \xos{a1}{xdi}
        \xos{a2}{xid}
        \xos{a1}{xdd}
        \xos{a2}{xdd}
        \po{a1}{a2}
      \end{tikzinline}}
  \end{gather*}

  % The precondition of $\DWP{y}{2}$ is unsatisfiable if no further assumptions
  % can be made on $r$; that is the case here, since we assume each register
  % occurs at most once in source programs. If we choose a pomset that without
  % the order $\DRP{x}{1}\xpo\DWP{y}{2}$, the precondition of $\DWP{y}{1}$ is
  % strengthened to $(r{=}2)$, which is also unsatisfiable without further
  % assumptions on $r$; the predicate transformers are unchanged.
\end{example}

\begin{example}
  \label{ex:left-merge}
  \ref{S4} includes $\aExp{=}\aVal$ to ensure that
  spurious merges do not go undetected.  Consider the following.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{1{=}1\mid\DW{x}{1}}{}
          \xform{x1d}{1{=}1\land\bForm}{right=of a1}
          \xform{x1i}{\bForm}{right=.5em of x1d}
          \xos{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a2}{2{=}1\mid\DW{x}{1}}{}
          \xform{x2d}{2{=}1\land\bForm}{right=of a2}
          \xform{x2i}{\bForm}{right=.5em of x2d}
          \xos{a2}{x2d}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  % Simplifying
  %% \begin{align*}
  %%   \begin{gathered}
  %%     \PW{x}{1}
  %%     \\
  %%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %%       \event{a1}{\Qr{\aLoc}\land\Qw{\aLoc}\mid\DW{x}{1}}{}
  %%       \xform{x1d}{\bForm}{below=of a1}
  %%       \xform{x1i}{\bForm[\FALSE/\Qw{\aLoc}]}{below=of x1d}
  %%       \xo{a1}{x1d}
  %%     \end{tikzinline}}
  %%   \end{gathered}
  %%   &&
  %%   \begin{gathered}
  %%     \PW{x}{2}
  %%     \\
  %%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %%       \event{a2}{\FALSE\mid\DW{x}{1}}{}
  %%       \xform{x2d}{\bForm[\FALSE/\Qw{\aLoc}]}{below=of a2}
  %%       \xform{x2i}{\bForm[\FALSE/\Qw{\aLoc}]}{below=of x2d}
  %%       \xo{a2}{x2d}
  %%     \end{tikzinline}}
  %%   \end{gathered}
  %% \end{align*}
  Merging the actions, since $2{=}1$ is unsatisfiable, we have:
  \begin{gather*}
    \PW{x}{1}\SEMI \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{1}}{}
        \xform{x1d}{\FALSE}{right=of a1}
        \xform{x1i}{\bForm}{right=.5em of x1d}
        \xos{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
  This pomset cannot be part of a top-level pomset, since
  $\aTr{\aEvs}{\aSym}=\FALSE$ for every quiescence symbol $\aSym$.  This is
  what we would hope: that the program $\PW{x}{1}\SEMI \PW{x}{2}$ should only
  be top-level if there is a $(\DW{x}{2})$ event.
\end{example}

\begin{example}
  \label{ex:skolem}
  The predicate transformer we have chosen for \ref{L4} is different from the
  one used traditionally, which is written using substitution.  Substitution
  is also used in \jjr{}.  Attempting to
  write the predicate transformers in this style we have:
  \begin{enumerate}[topsep=0pt]
  \item[\ref{L4})]
    $\aTr{\bEvs}{\bForm} \rimplies \bForm[\aVal/\aReg]$, 
  \item[\ref{L5})]
    $\aTr{\cEvs}{\bForm} \rimplies (\forall\aReg)\bForm$.
  \end{enumerate}
  This phrasing of \ref{L5} says that $\bForm$ must be independent of $\aReg$
  in order to appear in a top-level pomset.  This choice for \ref{L5} is forced
  by \refdef{def:family}, which states that the predicate transformer for a
  small subset of $\aEvs$ must imply the transformer for a larger subset.

  Sadly, this definition fails associativity.

  Consider the following, eliding transformers:
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW{x}{\BANG r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{b}{r{=}0\mid\DW{x}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW{x}{\BANG\BANG r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{b}{r{\neq}0\mid\DW{x}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{b}{\DW{x}{0}}{}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}  
  Associating to the right and merging:
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW{x}{\BANG r} 
      \SEMI \PW{x}{\BANG\BANG r} 
      \SEMI \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{b}{r{=}0 \lor r{\neq}0\mid\DW{x}{1}}{}
          \event{c}{\DW{x}{0}}{right=of b}
          \wk{b}{c}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}  
  The precondition of $\DWP{x}{1}$ is a tautology, thus we have:
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \SEMI \PW{x}{\BANG r} 
      \SEMI \PW{x}{\BANG\BANG r} 
      \SEMI \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
          \event{b}{\DW{x}{1}}{right=of a}
          \event{c}{\DW{x}{0}}{right=of b}
          \wk{b}{c}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  If, instead, we associate to the left:
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \SEMI \PW{x}{\BANG r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
          \event{b}{1{=}0\mid\DW{x}{1}}{right=of a}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW{x}{\BANG\BANG r} 
      \SEMI \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{b}{r{\neq}0\mid\DW{x}{1}}{}
          \event{c}{\DW{x}{0}}{right=of b}
          \wk{b}{c}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}  
  Sequencing and merging:
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \SEMI \PW{x}{\BANG r} 
      \SEMI \PW{x}{\BANG\BANG r} 
      \SEMI \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
          \event{b}{1{=}0 \lor r{\neq}0\mid\DW{x}{1}}{right=of a}
          \event{c}{\DW{x}{0}}{right=of b}
          \wk{b}{c}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  In this case, the precondition of $\DWP{x}{1}$ is not a tautology, forcing
  a dependency $\DRP{y}{1}\xpo \DWP{x}{1}$.

  Our solution is to Skolemize.  We have proven associativity of
  \refdef{def:pomsets-trans} in Agda.  The proof requires that predicate
  transformers distribute through disjunction (\refdef{def:trans}).  The
  attempt to define predicate transformers using substitution fails for
  \ref{L5} because the predicate transformer
  $\aTr{}{\bForm}=(\forall\aReg)\bForm$ does not distribute through
  disjunction:
  \begin{math}
    \aTr{}{\bForm_1\lor \bForm_2}=
    (\forall r)(\bForm_1\lor \bForm_2)
    \neq
    ((\forall r)(\bForm_1)) \lor ((\forall r)(\bForm_2))
    = \aTr{}{\bForm_1} \lor \aTr{}{\bForm_2}
  \end{math}.
\end{example}

\subsection{The Road Ahead}

The final semantic functions for load, store, and thread initialization are
given in \reffig{fig:no-addr}, at the end of the paper.  In
\textsection\ref{sec:q}--\ref{sec:complications}, we explain this definition
by looking at its constituent parts, building on \refdef{def:pomsets-trans}.
In \textsection\ref{sec:q}, we add \emph{quiescence}, which encodes
coherence, release-acquire access, and SC access.  In
\textsection\ref{sec:arm}, we add peculiarities that are necessary for
efficient implementation on \armeight.  In
\textsection\ref{sec:complications}, we discuss other features such as
invariant reasoning, case analysis and register recycling.
% In the appendix,
% we discuss address calculation and read-modify-write operations.

The final definitions of load and store are quite complex, due to the
inherent complexities of relaxed memory.  The core of
\refdef{def:pomsets-trans}, modeling sequential composition, parallel
composition, and conditionals, is stable, remaining unchanged in later
sections.  The messiness of relaxed memory is quarantined to the rules
for load and store, rather than permeating the entire semantics.
