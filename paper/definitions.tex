\section{Model}
\label{sec:model}

%% Batty suggest example where dependencies are added and also go away, perhaps
%% by store forwarding. Something like:
%% \texttt{(r=x; y=1); (s=y; z=s+r)}

In this section, we present the mathematical preliminaries for the
model (which can be skipped on first reading). We then present the
model incrementally, starting with a model built using
\emph{partially ordered multisets}
(\emph{pomsets})~\cite{GISCHER1988199,Plotkin:1997:TSP:266557.266600},
and then adding preconditions and finally predicate transformers.

In later sections, we will discuss extensions to the logic, and to the
semantics of load, store and thread initialization, in order to model
relaxed memory more faithfully. We stress that these features do
\emph{not} change any of the structures of the language: conditionals,
parallel composition, and sequential composition are as defined in this section.

\subsection{Preliminaries}
\label{sec:prelim}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$.
\end{itemize}

\emph{Memory references} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory references, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.

We require that
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
\item expressions include at least registers and values, 
\item expressions do \emph{not} include references: $\aExp[\bExp/\aLoc]=\aExp$.
\end{itemize}

We model the following language.
\begin{align*}
  \amode \BNFDEF& \mRLX
  \BNFSEP \mRA 
  \BNFSEP \mSC
  \\
  \aCmd
  \BNFDEF& \SKIP
  \BNFSEP \LET{\aReg}{\aExp}
  \BNFSEP \PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}
  \BNFSEP \PW[\amode]{\REF{\cExp}}[\ascope]{\aExp}
  \BNFSEP \PF[\ascope]{\fmode}
  \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
  \BNFSEP \aCmd_1 \SEMI \aCmd_2
  \BNFSEP \aCmd_1 \LPAR[\bThrd] \aCmd_2
  \\[-.5ex]
  \BNFSEP& \PCAS[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
  \BNFSEP \PFADD[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  \BNFSEP \PEXCHG[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
\end{align*}

\emph{Memory modes}, $\amode$, are {relaxed} ($\mRLX$), {release-acquire}
($\mRA$), and {sequentially consistent} ($\mSC$).  Relaxed mode is the
default; we regularly elide it from examples.  $\mRA$/$\mSC$ accesses are
collectively known as \emph{synchronized accesses}.  

\emph{Commands}, aka \emph{statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs. Following
\cite{DBLP:conf/icfp/FerreiraHJ96}, $\LPAR$ denotes parallel composition,
preserving thread state on the right after a join.  In examples and
sublanguages without join, we use the symmetric $\PAR$ operator.

The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, $\dEv$, 
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$,
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, 
\end{itemize}
Subsets of $\AllEvents$ are ranged over by $\aEvs$, $\bEvs$, $\cEvs$,
$\dEvs$.

We require that:
\begin{itemize}
\item formulae include equalities $(\aExp{=}\bExp)$ and $(\aLoc{=}\aExp)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$,
\item there is a relation \emph{implies} between
  formulae, capturing entailment, %\subseteq(\Formulae\times\Formulae)$ %
\item \emph{implies} has the expected semantics for $=$, $\lnot$, $\land$, $\lor$,
  $\limplies$ and substitution,
\item there are relations \emph{matches}, \emph{blocks}, and \emph{waits for}
  between actions,  
\item there is a subset of actions, known as \emph{release} actions.
\end{itemize}

Logical formulae include equations over registers, such as
$(\aReg{=}\bReg{+}1)$.
For use in \textsection\ref{sec:tc1}, we also include equations over memory references, such as $(\aLoc{=}1)$.
% I would like to drop this, an be careful about program vs logical syntax
Formulae are subject to substitutions; % of the form $[\aExp/\aReg]$ and
% $[\aExp/\aLoc]$;
actions are not.
We use expressions as formulae, coercing $\aExp$ to $\aExp{\neq}0$.
Equations have precedence over logical operators; thus
$\aReg{=}\aVal\limplies\bReg{>}\bVal$ is read
$(\aReg{=}\aVal)\limplies(\bReg{>}\bVal)$.  As usual, implication associates to the
right; thus $\aForm\limplies\bForm\limplies\cForm$ is read
$\aForm\limplies(\bForm\limplies\cForm)$.

% \begin{definition}
%   \label{def:independent}
%   We say $\aForm$ is \emph{independent of $\aLoc$} if, for every
%   $\aVal$, $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$; it is
%   \emph{dependent} otherwise.
%   We say $\aForm$ is \emph{location independent} if it is independent of
%   every location.
% We say
% $\aForm$ \emph{implies} $\bForm$ if $\aForm\vDash\bForm$.
% We say that
We say
$\aForm$ is a \emph{tautology} if $\TRUE$ implies $\aForm$.
% We say that
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm$ implies $\FALSE$.
% \end{definition}


Throughout \textsection\ref{sec:model}--\ref{sec:arm} we 
additionally require that
\begin{itemize}
\item each register is assigned at most once in a program.
  % \end{itemize}
  % In \textsection\ref{sec:complications} and following, we
  % require instead that
  % \begin{itemize}
  % \end{itemize}
\end{itemize}
In \textsection\ref{sec:complications}, we drop this restriction, requiring
instead that
\begin{itemize}
\item there are registers
  $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$,
\item registers $\uRegs{\AllEvents}$ do not appear in programs: $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$.
\end{itemize}
% In contexts that make no use of $\uRegs{\AllEvents}$, we make the first
% assumption.


In this paper, we let actions be reads, writes and fences:
\begin{displaymath}
  \aAct,\bAct \BNFDEF \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DF[\ascope]{\fmode}[\aThrd]
\end{displaymath}
% % writes $\DWP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% reads $\DRP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
% and fences $\DFP[\ascope]{\fmode}[\aThrd]$.
In definitions, we drop elements of actions that are existentially
quantified.  In examples, we drop elements of actions, using defaults.  We
write $\DXP[\amode]{}[\ascope]{}[\aThrd]$ to stand for
$\DWP[\amode]{}[\ascope]{}[\aThrd]$ or $\DRP[\amode]{}[\ascope]{}[\aThrd]$.
% or $\DFP[\ascope]{\amode}[\aThrd]$.
% We write $\DWP[\gemode\mREL]{}{}$ to stand for either
% $\DWP[\mREL]{}{}$ or $\DWP[\mSC]{}{}$, and similarly for other actions and
% modes.

Action $\DWP{\aLoc}{\aVal}$ \emph{matches} $\DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.

Action $\DWP{\aLoc}{\aVal}$ \emph{blocks} $\DRP{\aLoc}{\bVal}$, for any $\aVal$, $\bVal$.

  Let 
  \begin{math}
    {\eqreordersc}
    =
    \{(\DX[\mSC]{}{},\DX[\mSC]{}{})\}
  \end{math}.
  Let 
  \begin{math}
    {\eqreorderco}
    =
    \{(\DW{\aLoc}{}, \DW{\aLoc}{}),\;(\DR{\aLoc}{}, \DW{\aLoc}{}),\;(\DW{\aLoc}{}, \DR{\aLoc}{})\}
  \end{math}.
  Let \begin{math}
  {\reorderra}
    =
    \{(\aAct,             \DW[\gemode\mREL]{}{}     )\C
    (\aAct,               \DF{\gemode\fREL}        )\C
    (\DR{}{},             \DF{\gemode\fACQ}        )\C
    (\DR{\aLoc}{},        \DR[\gemode\mACQ]{\aLoc}{})\C
    (\DR[\gemode\mACQ]{}{},\aAct                    )\C
    (\DF{\gemode\fACQ},   \aAct                    )\C
    (\DF{\gemode\fREL},   \DW{}{}                  )\C
    (\DW[\gemode\mREL]{\aLoc}{},\DW{\aLoc}{})\}
  \end{math}.

  Action $\aAct$ \emph{delays} $\bAct$ if $\aAct\eqreordersc\bAct$ or $\aAct\eqreorderco\bAct$ or $\aAct\reorderra\bAct$.

Actions $\DWP[\amode\neq\mRLX]{}{}$ and $\DFP{\fmode\neq\fACQ}$ are
\emph{release actions}.


\subsection{Model}

\begin{definition}
  \label{def:pomset}
  A \emph{pomset with predicate transformers} over $\Act$
  is a tuple $(\aEvs, \labeling, \labelingForm, \aTr{}{}, \aTerm, {\le}, {\rrfx})$ where
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
  \item \label{pom-E}
    $\Event\subseteq\AllEvents$ is a set of \emph{events},
  \item \label{pom-lambda}
    $\labeling: \Event \fun \Act$ defines a \emph{label} for each event,
  \item \label{pom-kappa}
    $\labelingForm:\aEvs\fun\Formulae$ defines a \emph{precondition} for each event,
  \item \label{pom-tau}
    $\aTr{}{}:2^{\AllEvents}\fun\Formulae \fun\Formulae$ defines a \emph{predicate transformer} for each set of events,
  \item \label{pom-term}
    $\aTerm:\Formulae$ defines a \emph{termination condition},
  \item \label{pom-le}
    ${\le} \subseteq (\Event\times\Event)$, is a partial order capturing \emph{causality},
  \item \label{pom-rf}
    ${\rrfx} : \Event\fun\Event$ is a partial function capturing \emph{reads-from} such that 
    \begin{enumerate}
    % \item
    %   if $(\bEv,\aEv)\in{\rrfx}$ and $(\cEv,\aEv)\in{\rrfx}$ then $\bEv=\cEv$,
    \item \label{pom-rf-le}
      if $(\bEv,\aEv)\in{\rrfx}$ then $\bEv\le\aEv$.
    \item \label{pom-rf-match}
      if $(\bEv,\aEv)\in{\rrfx}$ then $\labeling(\bEv)$ matches $\labeling(\aEv)$,
    \item \label{pom-rf-block}
      if $(\bEv,\aEv)\in{\rrfx}$ and $\labeling(\cEv)$ blocks
      $\labeling(\aEv)$ then either $\cEv\le\bEv$ or $\aEv\le\cEv$.
    \end{enumerate}
  \end{enumerate}
\end{definition}

\begin{definition}
  A pomset is \emph{top-level} if for every $\aEv\in\aEvs$:
  \begin{enumerate}[,label=(\textsc{t}\arabic*),ref=\textsc{t}\arabic*]
  \item \label{pom-top-true}
    $\labelingForm(\aEv)$ is a tautology,    
  \item \label{pom-top-rf}
    if $\labeling(\aEv)$ is a read then there is some $\bEv\xrfx\aEv$.
  \end{enumerate}
\end{definition}

\begin{definition}
  % \noindent
  If $\aPS \in \sLPAR{\aPSS_1}{\aPSS_2}$ then  
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt]
    \item \label{par-E}
      $\aEvs = (\aEvs_1\cup\aEvs_2)$,
      ${\le}\supseteq\PBR{{\le_1}\cup{\le_2}}$, 
      ${\rrfx}\supseteq\PBR{{\rrfx_1}\cup{\rrfx_2}}$,
    \item \label{par-lambda}
      ${\labeling}=\PBR{{\labeling_1}\cup {\labeling_2}}$, 
      %if $\aEv\in\aEvs_2$ then $\labeling(\aEv) = \labeling_2(\aEv)$,
    % \item \label{par-lambda1}
    %   if $\aEv\in\aEvs_1$ then $\labeling(\aEv) = \labeling_1(\aEv)$, 
    \item \label{par-le}
      ${\le}\supseteq\PBR{{\le_1}\cup{\le_2}}$, 
      % \label{pomsetParLast}
      % \newcounter{pomsetParCount}
      % \setcounter{pomsetParCount}{\value{enumi}}
    \item \label{par-rf}
      ${\rrfx}\supseteq\PBR{{\rrfx_1}\cup{\rrfx_2}}$,\\
      $\PBR{{\rrfx_1}\cup{\rrfx_2}}\subseteq{\rrfx}\subseteq\PBR{{\rrfx_1}\cup{\rrfx_2}\cup{\le}}$,
    \item \label{par-disjoint}
      $\aEvs_1$ and $\aEvs_2$ are disjoint,
      \columnbreak
    \item \label{par-kappa1}
      if $\aEv\in\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$,
    \item \label{par-kappa2}
      if $\aEv\in\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$,
    \item \label{par-tau}
      $\aTr{\bEvs}{\bForm}$ implies $\aTr[1]{\bEvs}{\bForm}$,
    \item \label{par-term}
      $\aTerm$ implies $\aTerm[1]\land\aTerm[2]$.
    \end{enumerate}
      % \item \label{par-tau1}
      %   $\aTr{\bEvs}{\Q{}}$ implies $\aTr[1]{\bEvs}{\Q{}}$,
  \end{multicols}
  \medskip

  If $\aPS \in \sSEMI{\aPSS_1}{\aPSS_2}$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % let
  % \begin{math}
  %   \smash{
  %   \downarrow\aEv=\begin{cases}
  %     \{ \cEv \mid \cEv \lt \aEv \} &\textif \labeling(\aEv) \;\text{is a write}\\
  %     \aEvs_1 &\textotherwise
  %   \end{cases}}
  % \end{math}
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{3}
  \item[(\ref{par-E}--\ref{par-le})] as for $\sLPAR{}{}$,
  \item \label{seq-rf1}
    $\PBR{{\rrfx_1}\cup{\rrfx_2}}\subseteq{\rrfx}\subseteq\PBR{{\rrfx_1}\cup{\rrfx_2}\cup(\aEvs_1\times \aEvs_2)}$, 
  \item \label{seq-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$,
  \item \label{seq-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm'_2(\aEv)$,
  \item \label{seq-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)\lor\labelingForm'_2(\aEv)$,
    % \\ \makebox[5em]{}
    where
    $\labelingForm'_2(\aEv)=\aTr[1]{\Cdown{\aEv}}{\labelingForm_2(\aEv})$,\\
    where $\Cdown{\aEv}=\{ \cEv \mid \cEv \lt \aEv \}$ if $\labeling(\aEv)$ is a write,
    and $\Cdown{\aEv}=\aEvs_1$, otherwise,
  \item \label{seq-reorder}
    if %$\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ then either $\bEv\le\aEv$ or
    $\labeling_1(\bEv)$ and $\labeling_2(\aEv)$,
  \item \label{seq-rf2}
    if $(\bEv,\aEv)\in{\rrfx}$
    and $\labeling(\cEv)$ blocks $\labeling(\aEv)$
    for some $\cEv\in\aEvs_1$ and $\aEv\in\aEvs_2$
    then  $\cEv\le\bEv$,
    % if $\cEv\in\aEvs_1$ and $(\bEv,\aEv)\in\PBR{{\rrfx}\cap(\aEvs_1\times \aEvs_2)}$ then 
    % either $\labeling(\cEv) \reorderca \labeling(\bEv)$
    % or $\cEv\le\bEv$,
  \item \label{seq-release}
    if $\aEv\in\aEvs_2$ and $\labeling(\aEv)$ is a release then $\labelingForm(\aEv)$ implies $\aTerm[1]$,
  \item \label{seq-tau}
    $\aTr{\bEvs}{\bForm}$ implies $\aTr[1]{\bEvs}{\aTr[2]{\bEvs}{\bForm}}$,
  \item \label{seq-term}
    $\aTerm$ implies $\aTerm[1]\land\aTr[1]{\aEvs_1}{\aTerm[2]}$.
  \end{enumerate}
  \medskip

  % \noindent
  If $\aPS \in \sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{3}
  \item[(\ref{par-E}--\ref{par-le})] as for $\sLPAR{}{}$,
  \item
    \label{if-rf}
    ${\rrfx}=\PBR{{\rrfx_1}\cup{\rrfx_2}}$
    and
    $\PBR{{\rrfx}\cap(\aEvs_1\times\aEvs_1)}={\rrfx_1}$
    and
    $\PBR{{\rrfx}\cap(\aEvs_2\times\aEvs_2)}={\rrfx_2}$, 
  \item \label{if-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\aForm\land\labelingForm_1(\aEv)$,
  \item \label{if-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\neg\aForm\land\labelingForm_2(\aEv)$, 
  \item \label{if-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then
    $\labelingForm(\aEv)$ implies $(\aForm\limplies\labelingForm_1(\aEv))\land(\neg\aForm\limplies\labelingForm_2(\aEv))$,
  \item \label{if-tau}
    $\aTr{\bEvs}{\bForm}$ implies
    $(\aForm\limplies\aTr[1]{\bEvs}{\bForm})\land(\neg\aForm\limplies\aTr[2]{\bEvs}{\bForm})$,
  \item \label{if-term}
    $\aTerm$ implies
    $(\aForm\limplies\aTerm[1])\land(\neg\aForm\limplies\aTerm[2])$.
  \end{enumerate}
  \medskip

  % \noindent
  If $\aPS\in\sLET{\aReg}{\aExp}$ then $\aEvs = \emptyset$ and
  $\aTr{\bEvs}{\bForm}$ implies $\bForm[\aExp/\aReg]$.

  % \noindent
  If $\aPS\in\sSKIP$ then $\aEvs = \emptyset$ and
  $\aTr{\bEvs}{\bForm}$ implies $\bForm$.

  If $\aPS \in \sFENCE[\ascope]{\amode}[\aThrd]$ then
  % $(\exists\aLocs\subseteq\Loc)$
  % $(\exists\bmode\in\{\amode,\mRLX\})$
  \begin{enumerate}[topsep=0pt]
  \item%[{\labeltext[F1]{(F1)}{F1}}]
     $\aEvs\neq\emptyset$ and if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item%[{\labeltext[F2]{(F2)}{F2}}]
    $\labelingAct(\aEv) = \DF[\ascope]{\amode}[\aThrd]$,
    % \item%[{\labeltext[F3]{(F3)}{F3}}]
    %   $\labelingForm(\aEv)$ implies $\bigwedge_{\aLoc\in\aLocs}\Dx{\aLoc}$,
  \item%[{\labeltext[F4]{(F4)}{F4}}]
    $\aTr{\bEvs}{\bForm}$ implies $\bForm$,
  \item
    if $\aEvs=\emptyset$ then $\aTerm$ implies $\FALSE$.
  \end{enumerate}
  \medskip

  \begin{multicols}{2}
    If $\aPS \in \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]$ then
    $(\exists\aVal\in\Val)$
    \begin{enumerate}[topsep=0pt]
    \item
     if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
    \item
      $\labelingAct(\aEv) = \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
    \item
      $\labelingForm(\aEv)$ implies
      \begin{math}
        \aExp{=}\aVal
      \end{math},    
    \item
      %if $(\aEvs\cap\bEvs)\neq\emptyset$ then
      $\aTr{\bEvs}{\bForm}$ implies 
      \begin{math}
        \bForm
        % [\aExp/\aLoc]
        %\land\aExp{=}\aVal
      \end{math},
    \item%[{\labeltext[F4]{(F4)}{F4}}]
      if $\aEvs=\emptyset$ then $\aTerm$ implies $\FALSE$,
    \item 
      if $\aEvs\neq\emptyset$ then $\aTerm$ implies $\aExp{=}\aVal$.
    \end{enumerate}
    \columnbreak
    If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]$ then
    $(\exists\aVal\in\Val)$
    \begin{enumerate}[topsep=0pt]
    \item
      if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
    \item
      $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
    % \item
    %   $\labelingForm(\aEv)$ implies
    %   \begin{math}
    %     \TRUE
    %   \end{math},    
    \item
      $\aTr{\bEvs}{\bForm}$ implies
      \begin{math}
        \aVal{=}\aReg
        \limplies \bForm
      \end{math},    
      if $(\aEvs\cap\bEvs)\neq\emptyset$,
    \item
      $\aTr{\bEvs}{\bForm}$ implies
      \begin{math}
        % \PBR{\aVal{=}\aReg \lor \aLoc{=}\aReg} \limplies
        \bForm,
      \end{math}
      if $(\aEvs\cap\bEvs)=\emptyset$.
    \end{enumerate}
  \end{multicols}
  %\smallskip
% Given these definitions, the semantics of commands is:
  \begin{scope}
    \allowdisplaybreaks
    \begin{gather*}
      \sem[\aThrd]{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} = \sIFTHEN{\aExp{\neq}0}{\sem[\aThrd]{\aCmd_1}}{\sem[\aThrd]{\aCmd_2}}
      \\
      \begin{aligned}
        \sem[\aThrd]{\PW[\amode]{\aLoc}{\aExp}} &= \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]
        &
        \sem[\aThrd]{\SKIP} &= \sSKIP 
        \\
        \sem[\aThrd]{\PR[\amode]{\aLoc}{\aReg}} &= \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]
        &
        \sem[\aThrd]{\aCmd_1 \LPAR[\bThrd] \aCmd_2} &= \sLPAR{\sem[\bThrd]{\aCmd_1}}{\sem[\aThrd]{\aCmd_2}}
        \\
        \sem[\aThrd]{\LET{\aReg}{\aExp}} &= \sLET{\aReg}{\aExp}
        & 
        \sem[\aThrd]{\aCmd_1 \SEMI \aCmd_2} &= \sSEMI{\sem[\aThrd]{\aCmd_1}}{\sem[\aThrd]{\aCmd_2}}
        \\
        \sem[\aThrd]{\PF[\ascope]{\fmode}} &= \sFENCE[\ascope]{\fmode}[\aThrd]
        &
      \end{aligned}
    \end{gather*}
  \end{scope}
%  \caption{Semantics}
\end{definition}

Full versions:

\medskip
  If $\aPS \in \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  \begin{enumerate}[topsep=0pt]
  \item
    if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item
    $\labelingAct(\aEv) = \DW[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$,
  \item
    $\labelingForm(\aEv)$ implies
    \begin{math}
      \cForm_\aEv
      \land \aExp{=}\aVal_\aEv
    \end{math},
    
    
  \item
    % \begin{math}
    %   %(\forall\aEv\in\aEvs\cap\bEvs)
    %   (\forall\aEv\in\aEvs)
    % \end{math}
    $\aTr{\bEvs}{\bForm}$ implies 
    \begin{math}
      \cForm_\aEv
      \limplies 
      \bForm[\aExp/\aLoc]
    \end{math},
  % \item
  %   \begin{math}    
  %     (\forall\aEv\in\aEvs\setminus\bEvs)
  %   \end{math}
  %   $\aTr{\bEvs}{\bForm}$ implies
  %   \begin{math}
  %     \cForm_\aEv
  %     \limplies {
  %       \bForm
  %       [\aExp/\aLoc]
  %       % \DS{\aLoc}{\amode}
  %       % [\FALSE/\Q{}]
  %     }
  %   \end{math}
    % \item
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}.
  \item
    $\aTerm$ implies $\bigvee_{\aEv\in\aEvs}\cForm_\aEv$.
  \end{enumerate}

\medskip
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  % $(\exists\bmode\in\{\amode,\mRLX\})$
  \begin{enumerate}[topsep=0pt]
  \item
    if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item
    $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  \item
    $\labelingForm(\aEv)$ implies
    \begin{math}
      \cForm_\aEv
    \end{math},
    
  \item
    \begin{math}
      (\forall\aEv\in\aEvs\cap\bEvs)
    \end{math}
    $\aTr{\bEvs}{\bForm}$ implies
    \begin{math}
      \cForm_\aEv
      \limplies \aVal_\aEv{=}\uReg{\aEv}
      \limplies \bForm[\uReg{\aEv}/\aReg]
    \end{math},
    
  \item
    \begin{math}
      (\forall\aEv\in\aEvs\setminus\bEvs)
    \end{math}
    $\aTr{\bEvs}{\bForm}$ implies
    \begin{math}
      \cForm_\aEv 
      \limplies
      \PBR{\aVal_\aEv{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}}
      \limplies
      \bForm[\uReg{\aEv}/\aReg]
    \end{math},
    \item
      \begin{math}
        (\forall\bReg)
      \end{math}
      $\aTr{\bEvs}{\bForm}$  implies 
      \begin{math}
        %(\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
        (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\bReg/\aReg].
      \end{math}  
  \end{enumerate}  
\medskip

In $\sIFTHEN{}{}{}$, \eqref{if-rf} stops coalescing the rf in
\begin{displaymath}
  \IF{b}\THEN\PR{x}{r}\PAR\PW{x}{1}\ELSE\PR{x}{r}\SEMI\PW{x}{1}\FI
\end{displaymath}


In diagrams, we use different colors for arrows.  We distinguish
$\rrfx$ edges that are included in order from those that are not.
\begin{itemize}
\item \makebox{$\aEv\xrf\bEv$} arises from $\rrfx$, where $\aEv\le\bEv$,
\item \makebox{$\aEv\xrfint\bEv$} arises from $\rrfx$, where $\lnot(\aEv\le\bEv)$.
\end{itemize}
To help the reader understand why order is included, we also different colors
for arrows induced by order.  We adopt the following conventions:
\begin{itemize}  
  % \item relaxed accesses are blue, with a single border,
  % \item synchronized accesses are red, with a double border,
% \item \makebox{$\aEv\xrf\bEv$} arises from fulfillment, where $\aEv$ \emph{matches} $\bEv$,
% \item \makebox{$\aEv\xwk\bEv$} arises either from fulfillment, where $\aEv$
%   \emph{blocks} $\bEv$, or from prefixing, where $\aEv$ was prefixed before
%   $\bEv$ and their actions \emph{conflict},
\item \makebox{$\aEv\xwk\bEv$} arises from \emph{fulfillment},
\item \makebox{$\aEv\xpo\bEv$} arises from control/data/address \emph{dependency},
\item \makebox{$\aEv\xsync\bEv$} arises from \emph{synchronized access}.
\end{itemize}


\subsection{Pomsets}
\label{sec:pomsets}

We first consider a fragment of our language that can be modeled using simple
pomsets.  This captures read and write actions which may be reordered,
but as we shall see does \emph{not} capture control or data dependencies.

\begin{definition}
  \label{def:pomsets}
  A \emph{pomset} over $\Act$ is a tuple
  $(\Event, {\le}, \labeling)$ where
  \begin{itemize}
  \item $\Event\subset\AllEvents$ is a set of \emph{events},
  \item
    ${\le} \subseteq (\Event\times\Event)$ is the \emph{causality} partial order, 
  \item
    $\labeling: \Event \fun \Act$ is a \emph{labeling}.
  \end{itemize}
\end{definition}
Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.  Let $\Pom$
be the set of all pomsets.

We lift terminology from actions to events.  For example, we say that $\aEv$
writes $\aLoc$ if $\labeling(\aEv)$ writes $\aLoc$.  We also drop quantifiers
when clear from context, such as
$(\forall\aEv\in\Event)(\forall\aLoc\in\Loc)$.

\begin{definition}
  \label{def:fulfilled}
  Action $\DWP{\aLoc}{\aVal}$ \emph{matches} $\DRP{\aLoc}{\bVal}$ when $\aVal=\bVal$.
  Action $\DWP{\aLoc}{\aVal}$ \emph{blocks} $\DRP{\aLoc}{\bVal}$, for any
  $\aVal$, $\bVal$.
  
  % A pomset $\aPS$ is \emph{closed} if for every $\aEv$ which can be
  % fulfilled, there is a $\bEv\le\aEv$ which fulfills it, and for any $\cEv$
  % which can block $\aEv$, either $\cEv\le\bEv$ or $\aEv\le\cEv$.

  A read event $\aEv$ is \emph{fulfilled} if there is a $\bEv\le\aEv$ which
  matches it and, for any $\cEv$ which can block $\aEv$, either $\cEv\le\bEv$
  or $\aEv\le\cEv$.

  % Pomset $\aPS$ is \emph{fulfilled} if every read in $\aPS$ is fulfilled.
\end{definition}

We introduce reorderability \cite{DBLP:books/ws/95/Mazurkiewicz95} in order to
provide examples with coherence in this subsection.  In
\textsection\ref{sec:q} we show that coherence can be encoded in the logic,
making reorderability unnecessary.
\begin{definition}
  Actions $\aAct$ and $\bAct$ are \emph{reorderable}
  (${\aAct\reorder\bAct}$) if either both are reads or they are accesses to
  different locations.  Formally
  \begin{math}
    {\reorder} = \{(\DR{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \}
    \cup\{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}.
  \end{math}
  % \emph{Independency} (${\reorder}\subseteq\Act\times\Act$), is defined:
  \begin{comment}
    % {\reorderSC} &= \emptyset
    % \\
    % {\reorderRLX} &=
    \reorder &=
    \{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}
    \\[-.5ex]&\mkern2mu\cup\mkern2mu
    \{(\DR{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \}
    % \\[-.5ex]&\mkern2mu\cup\mkern2mu
    % \{(\DW{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc \lor \aVal=\bVal\}
    % \\[-.5ex]&\mkern2mu\cup\mkern2mu
    % \{(\DR{\aLoc}{\aVal}, \DW{\bLoc}{\bVal}), (\DW{\aLoc}{\aVal}, \DR{\bLoc}{\bVal}) \mid \aLoc\neq\bLoc\}
  \end{comment}

  Actions that are not reorderable are in \emph{conflict}.
\end{definition}
We can now define a model of processes given as sets of pomsets
sufficient to give the semantics for a fragment of our language
without control or data dependencies.
\begin{definition} %$\phantom{\;}$\par
  \label{def:pomset-semantics}

  \noindent
  If $\aPS\in\sNIL$ then $\aEvs = \emptyset$.

  \noindent
  If $\aPS \in \sPAR{\aPSS_1}{\aPSS_2}$ then  
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}[topsep=0pt]
  \item \label{par-E}
    $\aEvs = (\aEvs_1\cup\aEvs_2)$,
  \item \label{par-le1}
    if $\bEv\le_1\aEv$ then $\bEv\le\aEv$, 
  \item \label{par-le2}
    if $\bEv\le_2\aEv$ then $\bEv\le\aEv$, 
  \item \label{par-lambda1}
    if $\aEv\in\aEvs_1$ then $\labeling(\aEv) = \labeling_1(\aEv)$, 
  \item \label{par-lambda2x}
    if $\aEv\in\aEvs_2$ then $\labeling(\aEv) = \labeling_2(\aEv)$,
    \label{pomsetParCountLast}
    \newcounter{pomsetParCount}
    \setcounter{pomsetParCount}{\value{enumi}}
  \item \label{par-disjoint}
    $\aEvs_1$ and $\aEvs_2$ are disjoint.
    \label{pomsetParDisjointCountLast}
    \newcounter{pomsetParDisjointCount}
    \setcounter{pomsetParDisjointCount}{\value{enumi}}
  \end{enumerate}
  \noindent
  If $\aPS \in (\aAct\sPREFIX\aPSS_2)$ then
  $(\exists\aEvs_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}[topsep=0pt]
  \item \label{pre-E}
    $\aEvs=(\aEvs_1 \cup \aEvs_2)$,
  \item \label{pre-unique}
    if $\bEv,\aEv\in\aEvs_1$ then $\bEv=\aEv$,
  \item \label{pre-le2}
    if $\bEv\le_2\aEv$ then $\bEv\le\aEv$, 
  \item \label{pre-lambda1}
    if $\aEv\in\aEvs_1$ then $\labelingAct(\aEv) = \aAct$,
  \item \label{pre-lambda2}
    if $\aEv\in\aEvs_2$ then $\labelingAct(\aEv) = \labelingAct_2(\aEv)$,
  \item
    \label{pre-reorder}
    if $\bEv\in\aEvs_1$, $\aEv\in\aEvs_2$ then either
    $\bEv\leq\aEv$ or $a\reorder\labeling_2(\aEv)$.
    \label{pomsetPrefixOrderCountLast}
    % \newcounter{pomsetPrefixCount}
    % \setcounter{pomsetPrefixCount}{\value{enumi}}
    \newcounter{pomsetPrefixOrderCount}
    \setcounter{pomsetPrefixOrderCount}{\value{enumi}}    
  \end{enumerate}
  \noindent
  If $\aPS \in \sTOP{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}[topsep=0pt]
  \item  \label{top-E} % [{\labeltext[T1]{T1)}{T1}}]
    $\aEvs=\aEvs_1$,
  \item  \label{top-lambda} % [{\labeltext[T2]{T2)}{T2}}]
    $\labelingAct(\aEv) = \labelingAct_1(\aEv)$,
  \item  \label{top-le} % [{\labeltext[T2]{T2)}{T2}}]
    if $\bEv\le_1\aEv$ then $\bEv\le\aEv$, 
  \item  \label{top-fulfilled} % [{\labeltext[T3]{T3)}{T3}}]
    if $\labelingAct_1(\aEv)$ is a read then
    $\aEv$ is fulfilled (\refdef{def:fulfilled}).
    \label{pomsetTopCountLast}
    \newcounter{pomsetTopCount}
    \setcounter{pomsetTopCount}{\value{enumi}}
  \end{enumerate}  
\end{definition}
\begin{definition}
  \noindent
  For a language fragment, the semantics is:
  \begin{align*}
    \sem{\PW[\amode]{\aLoc}{\aVal}\SEMI \aCmd} &= \textstyle\DWP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
    &
    \sem{\SKIP} &= \sem{\NIL} = \sNIL 
    \\
    \sem{\PR[\amode]{\aLoc}{\aReg}\SEMI \aCmd} &= \textstyle\bigcup_{\aVal}\DRP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
    &
    \sem{\aCmd_1 \PAR \aCmd_2} &= \sPAR{\sem{\aCmd_1}}{\sem{\aCmd_2}}
    % \\
    % \sem{\PA{\aLoc}{\aVal}\SEMI \aCmd} &= \textstyle\DRP{\aLoc}{\aVal}\sPREFIX\sem{\aCmd}
  \end{align*}
  % Let $\aPSS$ range over sets of pomsets.
\end{definition}

In this semantics, both $\SKIP$ and $\NIL$ map to the empty pomset.  Parallel
composition is disjoint union, inheriting labeling and order from the two
sides.  Prefixing may add a new action (on the left) to an existing pomset
(on the right), inheriting labeling and order from the right.  

It is worth noting that if ${\reorder}$ is taken to be the empty relation,
then top-level pomsets of \refdef{def:pomsets} correspond to sequentially
consistent executions up to mumbling
\cite{DBLP:journals/iandc/Brookes96}.

\begin{example}
  \label{ex:mumble1}
  Mumbling is allowed, since there is no requirement that left and right be
  disjoint in the definition of prefixing.  Both of the pomsets below are
  allowed.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1} \SEMI \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{\DW{x}{1}}{}
          \event{a2}{\DW{x}{1}}{right=of a1}
          \wk{a1}{a2}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{1} \SEMI \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{\DW{x}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  In the left pomset, the order between the events is enforced by clause
  \ref{pre-reorder}, since the actions are in conflict.
\end{example}

\begin{example}
  \label{ex:pub1}
  Although this model enforces coherence, it is very weak.  For example, it
  makes no distinction between synchronizing and relaxed access, thus
  allowing:
  \begin{gather*}
    \PW{x}{0}\SEMI 
    \PW{x}{1}\SEMI \PW[\mREL]{y}{1} \PAR \PR[\mACQ]{y}{r} \SEMI \PR{x}{s} 
    \\[-.4ex]
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wx0}{\DW{x}{0}}{}
        \event{wx1}{\DW{x}{1}}{right=of wx0}
        \raevent{wy1}{\DW[\mREL]{y}{1}}{right=of wx1}
        \raevent{ry1}{\DR[\mACQ]{y}{1}}{right=2.5em of wy1}
        \event{rx0}{\DR{x}{0}}{right=of ry1}
        % \sync{wx1}{wy1}
        % \sync{ry1}{rx0}
        \rf{wy1}{ry1}
        \wk[in=-15,out=-165]{rx0}{wx1}
        \wk{wx0}{wx1}
        \rf[out=15,in=165]{wx0}{rx0}
      \end{tikzinline}}
  \end{gather*}  
  We show how to enforce the intended semantics, where $\DWP[\mREL]{y}{1}$
  \emph{publishes} $\DWP{x}{1}$ in \refex{ex:pub2}.
\end{example}
In diagrams, we use different shapes and colors for arrows and events.  These
are included only to help the reader understand why order is included.  We
adopt the following conventions (dependency and synchronization order will
appear later in the paper):
\begin{itemize}  
\item relaxed accesses are blue, with a single border,
\item synchronized accesses are red, with a double border,
  % \item sequentially-consistent accesses are orange, with a bold double
  %   border,
\item \makebox{$\aEv\xrf\bEv$} arises from fulfillment, where $\aEv$ \emph{matches} $\bEv$,
\item \makebox{$\aEv\xwk\bEv$} arises either from fulfillment, where $\aEv$
  \emph{blocks} $\bEv$, or from prefixing, where $\aEv$ was prefixed before
  $\bEv$ and their actions \emph{conflict},
\item \makebox{$\aEv\xpo\bEv$} arises from control/data/address \emph{dependency},% (eg, control),
\item \makebox{$\aEv\xsync\bEv$} arises from \emph{synchronized access}.
\end{itemize}

\begin{definition}
  $\aPSS_1$ \emph{refines} $\aPSS_2$ if $\aPSS_1\subseteq\aPSS_2$.
\end{definition}

\begin{example}
  \refex{ex:mumble1} shows that $\sem{\PW{x}{1}}$ refines $\sem{\PW{x}{1}\SEMI\PW{x}{1}}$.
\end{example}

\subsection{Pomsets with Preconditions}
\label{sec:pomsets-pre}

The previous section modeled a language fragment without conditionals (and hence no
control dependencies) or expressions (and hence no data dependencies). We now
address this, by adopting a \emph{pomsets with preconditions} model
similar to~\cite{DBLP:journals/pacmpl/JagadeesanJR20}.
% restricting attention to relaxed access.
% We discuss the differences in \S\ref{sec:discussion}.

\begin{definition}
  A \emph{pomset with preconditions} is
  a pomset (\refdef{def:pomsets}) together with $\labelingForm:\aEvs\fun\Formulae$.
\end{definition}
\begin{definition}
  \label{def:q-sub}
  Let $[\aForm/\Q{}]$ substitute all quiescence symbols by $\aForm$.
\end{definition}


% \begin{definition}
%   Let $\aSub$ be a substitution.  If $\aPS\in(\aPSS\aSub)$ then
%   $(\exists\aPS\in\aPSS)$ $\Event = \Event'$, ${\le} = {\le'}$,
%   $\labelingAct = \labelingAct'$, and
%   $\labelingForm(\aEv) = \labelingForm'(\aEv)\aSub$.
% \end{definition}

% Definition \ref{def:pomsets-pre}, describes operators 
% sufficient to give the semantics to a larger fragment of our language:
We can now define a model of processes given as sets of pomsets with preconditions
sufficient to give the semantics for a fragment of our language
where every use of sequential composition is either
$(\PW[\amode]{\aLoc}{\aExp}\SEMI \aCmd)$ or
$(\PR[\amode]{\aLoc}{\aReg}\SEMI \aCmd)$.
\begin{definition}%$\phantom{\;}$\par
  \label{def:pomsets-pre}
  
  \noindent
  If $\aPS\in\sNIL$ then $\aEvs = \emptyset$.

  \noindent
  If $\aPS \in \sPAR{\aPSS_1}{\aPSS_2}$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetParDisjointCount}}
  \item[1--\ref{pomsetParDisjointCountLast})]
    as for $\sPAR{}{}$ in \refdef{def:pomset-semantics},
  \item \label{par-kappa1}
    if $\aEv\in\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$,
  \item \label{par-kappa2}
    if $\aEv\in\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$.
    \newcounter{pomsetPreParCount}
    \setcounter{pomsetPreParCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS \in \sIFTHEN{\aForm}{\aPSS_1}{\aPSS_2}$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[1--\ref{pomsetParCountLast})] 
    as for $\sPAR{}{}$  in \refdef{def:pomset-semantics} (ignoring disjointness),
  \item \label{if-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\aForm\land\labelingForm_1(\aEv)$,
  \item \label{if-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\neg\aForm\land\labelingForm_2(\aEv)$, 
  \item \label{if-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then\\
    $\labelingForm(\aEv)$ implies $(\aForm\limplies\labelingForm_1(\aEv))\land(\neg\aForm\limplies\labelingForm_2(\aEv))$.
    % $\labelingForm(\aEv)$ implies $(\aForm\land\labelingForm_1(\aEv))\lor(\neg\aForm\land\labelingForm_2(\aEv))$.
    \label{pomsetPreIfCountLast}
    \newcounter{pomsetPreIfCount}
    \setcounter{pomsetPreIfCount}{\value{enumi}}
  \end{enumerate}

  \noindent
  If $\aPS \in \sSTOREPRE{\aLoc}{\aExp}{\aPSS_2}$ then
  $(\exists\aPS_2\in\aPSS_2)$
  $(\exists\aVal\in\Val)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetPrefixOrderCount}}
  \item[1--\ref{pomsetPrefixOrderCountLast})]
    as for $\DWP{\aLoc}{\aVal}\sPREFIX\aPSS_2$ in \refdef{def:pomset-semantics}, % (ignoring \thepomsetPrefixOrderCount),
  \item \label{storepre-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\aExp{=}\aVal$,
  \item \label{storepre-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$,
  \item \label{storepre-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm(\aEv)$ implies $\aExp{=}\aVal \lor \labelingForm_2(\aEv)$.
    % \item if $\aEv\in\aEvs_2$ then either
    %   $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$ or\\
    %   $\aEv\in\aEvs_1$ and $\labelingForm(\aEv)$ implies $(\aExp{=}\aVal)\lor \labelingForm_2(\aEv)$.
  \end{enumerate}

  \noindent
  If $\aPS \in \sLOADPRE{\aReg}{\aLoc}{\aPSS_2}$ then
  $(\exists\aPS_2\in\aPSS_2)$
  $(\exists\aVal\in\Val)$
  % there is $\aPS_2\in\aPSS$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetPrefixOrderCount}}
  \item[1--\ref{pomsetPrefixOrderCountLast})]
    as for $\DRP{\aLoc}{\aVal}\sPREFIX\aPSS_2$ in \refdef{def:pomset-semantics}, % (ignoring \thepomsetPrefixOrderCount),
  \item \label{loadpre-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then either \\
    $\labelingForm(\aEv)$ implies $\aReg{=}\aVal\limplies\labelingForm_2(\aEv)$ and $(\exists\bEv\in\aEvs_1)\;\bEv<\aEv$, or \\
    $\labelingForm(\aEv)$ implies $\labelingForm_2(\aEv)$.
    % \\ \mbox{$\quad$} for some $\bEv\in\aEvs_1$.
  \end{enumerate}  

  \label{def:pomsets-top}
  \labeltext[\ensuremath{\sTOP{}}]{}{sTOP}
  \noindent
  If $\aPS \in \sTOP{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetTopCount}}
  \item[1--\ref{pomsetTopCountLast})] % \label{top-E} % [{\labeltext[T1]{T1)}{T1}}]
    as for $\sTOP{}$ in \refdef{def:pomset-semantics},
  \item \label{top-kappa-write} % [{\labeltext[T3]{T3)}{T3}}]
    if $\labelingAct_1(\aEv)$ is a write,
    $\labelingForm_1(\aEv) [\TRUE/\Q{}][\TRUE/\RW]$ is a tautology,
  \item \label{top-kappa-read} % [{\labeltext[T3]{T3)}{T3}}]
    if $\labelingAct_1(\aEv)$ is a read,
    $\labelingForm_1(\aEv) [\TRUE/\Q{}][\FALSE/\RW]$ is a tautology.
    \newcounter{pomsetPreTopCount}
    \setcounter{pomsetPreTopCount}{\value{enumi}}
  \end{enumerate}  
\end{definition}
Let $\PomPre$ be the set of all pomsets with preconditions.
% A pomset with preconditions is \emph{top level} if it is fulfilled
% (\refdef{def:fulfilled}) and every precondition is a tautology.
The function $\sTOP{}:2^{\PomPre}\fun2^{\Pom}$ embeds sets of pomsets with preconditions into sets of
pomsets.  It also substitutes formulae for quiescence and write symbols, for
use in \textsection\ref{sec:q}-\ref{sec:arm}.  In these ``top-level''
pomsets, every read is fulfilled and every precondition is a tautology.
\begin{definition}
  \noindent
  For a language fragment, the semantics is:
  \begin{gather*}
    \sem{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} = \sIFTHEN{\aExp{\neq}0}{\sem{\aCmd_1}}{\sem{\aCmd_2}}
    \\
    \begin{aligned}
      \sem{\PW[\amode]{\aLoc}{\aExp}\SEMI \aCmd} &=
      \sSTOREPRE{\aLoc}{\aExp}{\sem{\aCmd}}
      &
      \sem{\SKIP} &= \sem{\NIL} = \sNIL 
      \\
      \sem{\PR[\amode]{\aLoc}{\aReg}\SEMI \aCmd} &=
      \sLOADPRE{\aReg}{\aLoc}{\sem{\aCmd}}
      &
      \makebox[3.5em][r]{$\sem{\aCmd_1 \PAR \aCmd_2}$} &= \sPAR{\sem{\aCmd_1}}{\sem{\aCmd_2}}
    \end{aligned}
  \end{gather*}
\end{definition}
%% Following our convention for subscripts, in the final clause of
%% $\sLOADPRE{}{}{}$, $<$ refers to the order of $\aPS$.  Also note that
%% $\sLOADPRE{}{}{}$ does not constrain $\labelingForm(\aEv)$ if
%% $\aEv\in\aEvs_1$.

\begin{example}
  \label{ex:data}
  A simple example of a data dependency
  is a pomset $\aPS\in\sem{\PR{x}{r}\SEMI \PW{y}{r}}$,
  for which there must be an $\aVal\in\Val$ and $\aPS'\in \sem{\PW{y}{r}}$
  such as the following, where $\aVal=1$:
  % \vspace{-.5\baselineskip}
  \begin{gather*}
    \PW{y}{r}
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{r{=}1\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gather*}
  The value chosen for the read may be different from that chosen for the write:
  % \vspace{-.5\baselineskip}
  \begin{gather*}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx0}{\DR{x}{0}}{}
        \event{wy1}{r{=}0\limplies r{=}1 \mid \DW{y}{1}}{right=of rx0}
        \po{rx0}{wy1}
      \end{tikzinline}}
  \end{gather*}
  In this case, the pomset's preconditions depend on a bound register, so
  cannot contribute to a top-level pomset.

  If the values chosen for read and write are compatible, then we have two
  cases: the independent case, which again cannot be part of a top-level
  pomset,
  \begin{gather*}
    \PR{x}{r}\SEMI \PW{y}{r}
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx1}{\DR{x}{1}}{}
        \event{wy1}{r{=}1 \mid \DW{y}{1}}{right=of rx1}
      \end{tikzinline}}
  \end{gather*}
  and the dependent case:
  \begin{gather*}
    % \PR{x}{r}\SEMI \PW{y}{r}
    % \\
    % \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx1}{\DR{x}{1}}{}
        \event{wy1}{r{=}1\limplies r{=}1 \mid \DW{y}{1}}{right=of rx1}
        \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gather*}
  Since $r{=}1\limplies r{=}1$ is a tautology, this can be part of
  a top-level pomset.
\end{example}

\begin{example}
  Control dependencies are similar, for example
  for any $\aPS\in\sem{\PR{x}{r}\SEMI \IF r \THEN \PW{y}{1} \FI}$,
  there must be an $\aVal\in\Val$ and $\aPS'\in \sem{\IF r \THEN \PW{y}{1} \FI}$
  such as:
  \begin{gather*}
    \IF r \THEN \PW{y}{1} \FI
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{r{\ne}0\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gather*}
  The rest of the reasoning is the same as \refex{ex:data}.
\end{example}

\begin{example}
  A simple example of an independency
  is a pomset $\aPS\in\sem{\PR{x}{r}\SEMI \PW{y}{1}}$,
  for which there must be:
  % an %$\aVal\in\Val$ and
  % $\aPS'\in \sem{\PW{y}{r}}$
  % such as:
  % \vspace{-1\baselineskip}
  \begin{gather*}
    \PW{y}{1}
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{1{=}1\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gather*}
  In this case it doesn't matter what value the read chooses:
  \begin{gather*}
    \PR{x}{r}\SEMI \PW{y}{1}
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{rx0}{\DR{x}{0}}{}
        \event{wy1}{1{=}1 \mid \DW{y}{1}}{right=of rx0}
      \end{tikzinline}}
  \end{gather*}
  % Since $1{=}1$ is a tautology, this can be part of
  % a top-level pomset.
\end{example}

\begin{example}
  Consider $\aPS\in\sem{\IF {r{=}1} \THEN \PW{y}{r} \ELSE \PW{y}{1}\FI}$, so
  there must be $\aPS_1\in\sem{\PW{y}{r}}$,
  and $\aPS_2\in\sem{\PW{y}{1}}$, such as:
  \begin{align*}
    \begin{gathered}
      \PW{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
          \event{wy1}{r{=}1 \mid \DW{y}{1}}{}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{y}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
          \event{wy1}{1{=}1 \mid \DW{y}{1}}{}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  Since there is no requirement for disjointness in the semantics of conditionals,
  we can consider the case where the event \emph{coalesces} from the two pomsets,
  in which case:
  \begin{gather*}
    \IF{r{=}1} \THEN \PW{y}{r} \ELSE \PW{y}{1}\FI
    \\
    \nonumber
    \hbox{\begin{tikzinline}[node distance=1ex and 1.5em]
        \event{wy1}{(r{=}1 \limplies r{=}1) \land (r{\ne}1 \limplies 1{=}1) \mid \DW{y}{1}}{}
      \end{tikzinline}}
  \end{gather*}
  Here, the precondition is a tautology, 
  independent of $r$.
  % We refer to event sharing as \emph{coalescing} or \emph{merging}.
\end{example}

\subsection{Pomsets with Predicate Transformers}
\label{sec:pomsets-trans}

Having reviewed the work we are building on, we now turn to
the contribution of this paper, which is a model of \emph{pomsets with predicate transformers}.
\emph{Predicate transformers} are
functions on formulae which preserve logical structure, providing a natural model of sequential composition.


\begin{definition}
  \label{def:trans}
  A \emph{predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{itemize}
  \item $\aTr{}{\FALSE}$ is $\FALSE$,    
  \item $\aTr{}{\bForm_1\land\bForm_2}$ is $\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$,    
  \item $\aTr{}{\bForm_1\lor\bForm_2}$ is $\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$, 
  \item if $\aForm$ implies $\bForm$, then $\aTr{}{\aForm}$ implies $\aTr{}{\bForm}$.
  \end{itemize}
\end{definition}
\noindent
Note that substitutions ($\aTr{}{\psi}=\psi[\aExp/\aReg]$) and implications on the right
($\aTr{}{\psi}=\phi\limplies\psi$) are predicate transformers.

As discussed in \S\ref{sec:intro}, predicate transformers suffice for sequentially consistent
models, but not relaxed models, where dependency calculation is crucial.
For dependency calculation, we use a \emph{family} of predicate transformers,
indexed by sets of events. We use $\aTr{\bEvs}{}$ as the predicate transformer
applied to any event $\aEv$ where if $\bEv\in\bEvs$ then $\bEv<\aEv$.

\begin{definition}
  \label{def:family}
  A \emph{family of predicate transformers} for $\aEvs$ consists of a
  predicate transformer $\aTr{\bEvs}{}$ for each $\bEvs\subseteq\AllEvents$,
  such that if $\cEvs \cap \aEvs \subseteq \bEvs$ then $\aTr{\cEvs}{\bForm}$
  implies $\aTr{\bEvs}{\bForm}$.
\end{definition}

%% Note that in a family of predicate transformers for $\aEvs$, transformers for
%% smaller subsets of $\aEvs$ are stronger.

\begin{definition}
  A \emph{pomset with predicate transformers} is a pomset with preconditions (\refdef{def:pomsets-pre}),
  together with a family of predicate transformers for $\aEvs$.
\end{definition}
\begin{comment}
  Let $\PomTrans$ be the set of all pomsets with predicate transformers.
  % \begin{definition}
  %   For pomset $\aPS$ and $\aEv\in\aEvs$, let
  %   $\downclose[0]{\aEv} = \{ \bEv\in\aEvs \mid \bEv < \aEv \}$.
  % \end{definition}
  We can covert between pomsets with preconditions and pomsets with predicate
  transformers. In one direction, $\sTHREAD{}:2^{\PomTrans}\fun2^{\PomPre}$
  drops predicate transformers, and in the other,
  $\sFORK{}:2^{\PomPre}\fun2^{\PomTrans}$ adopts the identity transformer.

  \begin{definition}
    \label{def:pomsets-group}
    \noindent
    If $\aPS \in \sTHREAD{\aPSS}$ then
    $(\exists\aPS_1\in\aPSS)$
    \begin{enumerate}[topsep=0pt]
    \item  \label{thread-E} % [{\labeltext[T1]{T1)}{T1}}]
      $\aEvs=\aEvs_1$,
    \item  \label{thread-lambda} % [{\labeltext[T2]{T2)}{T2}}]
      $\labelingAct(\aEv) = \labelingAct_1(\aEv)$,
    \item \label{thread-le} % [{\labeltext[T2]{T2)}{T2}}]
      if $\bEv\le_1\aEv$ then $\bEv\le\aEv$,
    \item  \label{thread-kappa}\label{T3} % [{\labeltext[T3]{T3)}{T3}}]
      $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$.
      \newcounter{pomsetXThreadCount}
      \setcounter{pomsetXThreadCount}{\value{enumi}}
    \end{enumerate}  

    \noindent
    If $\aPS \in \sFORK{\aPSS}$ then
    $(\exists\aPS_1\in\aPSS)$
    \begin{enumerate}[topsep=0pt]
    \item \label{fork-E} % [{\labeltext[F1]{F1)}{F1}}]
      $\aEvs=\aEvs_1$,
    \item  \label{fork-lambda} % [{\labeltext[F2]{F2)}{F2}}]
      $\labelingAct(\aEv) = \labelingAct_1(\aEv)$,
    \item \label{fork-le} % [{\labeltext[T2]{T2)}{T2}}]
      if $\bEv\le_1\aEv$ then $\bEv\le\aEv$,
      \newcounter{pomsetXForkCount}
      \setcounter{pomsetXForkCount}{\value{enumi}}
    \item  \label{fork-kappa}\label{F3}  % [{\labeltext[F3]{F3)}{F3}}]
      $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$, 
    \item  \label{fork-tau}\label{F4}  % [{\labeltext[F4]{F4)}{F4}}]
      $\aTr{\bEvs}{\bForm}$ implies $\bForm$.
    \end{enumerate}  
  \end{definition}

  We model thread groups as sets of pomsets with preconditions,
  as in \S\ref{sec:pomsets-pre}.

  \begin{definition}
    \noindent
    Adopting $\sNIL$ and $\sPAR{}{}$ from \refdef{def:pomsets-pre},
    the semantics of thread groups is:
    \begin{align*}
      \sem{\THREAD{\aCmd}} &= \sTHREAD{}\sem{\aCmd}
      &
      \sem{\aGrp_1 \PAR \aGrp_2} &= \sPAR{\sem{\aGrp_1}}{\sem{\aGrp_2}}
      &
      \sem{\NIL} &= \sNIL     
    \end{align*}
    % , and
    % $\sTHREAD{}$ is as follows.
  \end{definition}

  We model commands by adding predicate transformers to
  \refdef{def:pomsets-pre}, in order to calculate preconditions.
\end{comment}
\begin{definition}
  \label{def:pomsets-trans}

  \noindent
  If $\aPS\in\sABORT$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm}$ implies $\FALSE$.
  \end{itemize}

  \noindent
  If $\aPS\in\sSKIP$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm}$ implies $\bForm$.
  \end{itemize}

  \noindent
  If $\aPS\in\sLET{\aReg}{\aExp}$ then $\aEvs = \emptyset$ and
  \begin{itemize}
  \item $\aTr{\bEvs}{\bForm}$ implies $\bForm[\aExp/\aReg]$.
  \end{itemize}

  \noindent
  If $\aPS \in \sIF{\aForm}\sTHEN\aPSS_1\sELSE\aPSS_2\sFI$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetPreIfCount}}
  \item[1--\ref{pomsetPreIfCountLast})] as for $\sIF{}$ in \refdef{def:pomsets-pre},
  \item \label{if-tau}
    $\aTr{\bEvs}{\bForm}$ implies
    $(\aForm\limplies\aTr[1]{\bEvs}{\bForm})\land(\neg\aForm\limplies\aTr[2]{\bEvs}{\bForm})$.
    % $(\aForm\land\aTr[1]{\bEvs%\cap\aEvs_1
    % }{\bForm})\lor(\neg\aForm\land\aTr[2]{\bEvs%\cap\aEvs_2
    % }{\bForm})$.
  \end{enumerate}

  \noindent
  If $\aPS \in \sLPAR{\aPSS_1}{\aPSS_2}$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetPreParCount}}
  \item[\ref{par-E}--\ref{par-kappa2})]
    as for $\sPAR{}{}$ in \refdef{def:pomsets-pre},
  \item \label{par-tau1}
    $\aTr{\bEvs}{\bForm}$ implies $\aTr[2]{\bEvs}{\bForm}$,
  \item \label{par-tau2}
    $\aTr{\bEvs}{\aSym}$ implies $\aTr[1]{\bEvs}{\aSym}$,
    for every quiescence symbol $\aSym$.
  \end{enumerate}

  \noindent
  If $\aPS \in \sSEMI{\aPSS_1}{\aPSS_2}$ then
  $(\exists\aPS_1\in\aPSS_1)$ $(\exists\aPS_2\in\aPSS_2)$
  % there are $\aPS_1\in\aPSS_1$ and $\aPS_2\in\aPSS_2$ such that
  % let $\labelingForm'_2(\aEv)=\aTr[1]{{\downclose[0]{\aEv}}}{\labelingForm_2(\aEv)}$  
  % let $\labelingForm'_2(\aEv)=\aTr[1]{\{ \bEv \mid \bEv < \aEv \}}{\labelingForm_2(\aEv})$  
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetParCount}}
  \item[1--\ref{pomsetParCountLast})]
    as for $\sPAR{}{}$  in \refdef{def:pomset-semantics} (ignoring disjointness),
  \item \label{seq-kappa1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)$,
  \item \label{seq-kappa2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv)$ implies $\labelingForm'_2(\aEv)$,
  \item \label{seq-kappa12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labelingForm(\aEv)$ implies $\labelingForm_1(\aEv)\lor\labelingForm'_2(\aEv)$,
    \\ where $\labelingForm'_2(\aEv)=\aTr[1]{\cEvs%\cap\aEvs_1
    }{\labelingForm_2(\aEv})$, where $\cEvs=\{ \cEv \mid \cEv < \aEv \}$,
  \item \label{seq-tau}
    $\aTr{\bEvs}{\bForm}$ implies $\aTr[1]{\bEvs}{\aTr[2]{\bEvs}{\bForm}}$.
    \newcounter{pomsetXSemiCount}
    \setcounter{pomsetXSemiCount}{\value{enumi}}
    % \item if $\bEv\in\aEvs_1$ and $\aEv\in\aEvs_2$ either $\bEv<\aEv$ or $a\reorder\labeling_2(\aEv)$.
  \end{enumerate}
  % where we define $\labelingForm'_2(\aEv)$ to be $\aTr[1]{\{ \bEv \mid \bEv < \aEv \}}{\labelingForm_2(\aEv})$.

  \noindent
  If $\aPS \in \sSTORE[\amode]{\aLoc}{\aExp}$ then
  $(\exists\aVal\in\Val)$
  % $(\forall\bEvs\neq\emptyset)$
  \begin{enumerate}[topsep=0pt]
  \item[{\labeltext[S1]{S1)}{S1}}]
    if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item[{\labeltext[S2]{S2)}{S2}}]
    $\labelingAct(\aEv) = \DW{\aLoc}{\aVal}$,
  \item[{\labeltext[S3]{S3)}{S3}}]
    $\labelingForm(\aEv)$ implies $\aExp{=}\aVal$,
  \item[{\labeltext[S4]{S4)}{S4}}]
    $\aTr{\bEvs}{\bForm}$ implies $\bForm\noSUB{[\aExp/\aLoc]}\land\aExp{=}\aVal$, % \land (\Q{}\limplies\aExp{=}\aVal)$,
  \item[{\labeltext[S5]{S5)}{S5}}]
    $\aTr{\cEvs}{\bForm}$ implies $\bForm\noSUB{[\aExp/\aLoc]}$, % \land % \lnot\Q{}$.
    \\ where $\bEvs\cap\aEvs\neq\emptyset$ and $\cEvs\cap\aEvs=\emptyset$.
    % \item %if $\bEvs\neq\emptyset$ then
    %   $\aTr{\bEvs}{\bForm}$ implies $(\aExp{=}\aVal) \land \bForm[\aExp/\aLoc]$, if $\bEvs\neq\emptyset$,
    %   \newcounter{pomsetXStoreCount}
    %   \setcounter{pomsetXStoreCount}{\value{enumi}}
  \end{enumerate}

  % \noindent
  % If $\aPS \in \sLOAD[\amode]{\aReg}{\aLoc}$ then
  % $(\exists\aVal\in\Val)$
  % $(\forall\bEvs\neq\emptyset)$
  % \begin{enumerate}[topsep=0pt]
  % \item[{\labeltext[L1]{L1)}{L1}}] 
  %   if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  % \item[{\labeltext[L2]{L2)}{L2}}]
  %   $\labelingAct(\aEv) = \DRP{\aLoc}{\aVal}$,
  % \item[{\labeltext[L3]{L3)}{L3}}]
  %   $\labelingForm(\aEv)$ implies $\TRUE$,
  % \item[{\labeltext[L4]{L4)}{L4}}]
  %   %   if $\bEvs\neq\emptyset$ then
  %   $\aTr{\bEvs}{\bForm}$ implies %$\phantom{(\aLoc{=}\aReg\lor{}}
  %   $\aVal{=}\aReg\limplies\bForm$, 
  % \item[{\labeltext[L5]{L5)}{L5}}]
  %   %   if $\bEvs=\emptyset$ then
  %   $\aTr{\emptyset}{\bForm}\;$ implies $((\aLoc{=}\aReg\lor\aVal{=}\aReg)\limplies\bForm) \land \lnot\Q{}$.
  % \item[{\labeltext[L6]{L6)}{L6}}]
  %   if $\aEvs=\emptyset$ then
  %   $\aTr{\emptyset}{\bForm}\;$ implies $\bForm \land \lnot\Q{}$.
  % \end{enumerate}

  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}{\aLoc}$ then %either $\aEvs\neq\emptyset$ and
  $(\exists\aVal\in\Val)$
  % $(\forall\bEvs{\neq}\emptyset)$
  \begin{enumerate}[topsep=0pt]
  \item[{\labeltext[L1]{L1)}{L1}}] 
    if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item[{\labeltext[L2]{L2)}{L2}}]
    $\labelingAct(\aEv) = \DR{\aLoc}{\aVal}$,
  \item[{\labeltext[L3]{L3)}{L3}}]
    $\labelingForm(\aEv)$ implies $\TRUE$,
  \item[{\labeltext[L4]{L4)}{L4}}]
    $\aTr{\bEvs}{\bForm}$ implies $\aVal{=}\aReg\limplies\bForm$, 
  \item[{\labeltext[L5]{L5)}{L5}}]
    % $\aTr{\cEvs}{\bForm}$ implies $(\aVal{=}\aReg\lor\aLoc{=}\aReg)\limplies\bForm$, % \land \lnot\Q{}$,
    $\aTr{\cEvs}{\bForm}$ implies $\bForm$, % \land \lnot\Q{}$,
    \\ where $\bEvs\cap\aEvs\neq\emptyset$ and $\cEvs\cap\aEvs=\emptyset$,
  \end{enumerate}
  % or
  % $\aEvs=\emptyset$ and 
  % \begin{enumerate}[topsep=0pt]
  % \item[{\labeltext[L6]{L6)}{L6}}] 
  %   $\aTr{\dEvs}{\bForm}\;$ implies $\bForm$. % \land \lnot\Q{}$.
  % \end{enumerate}
  If $\aPS \in \sTOP{\aPSS}$ then
  $(\exists\aPS_1\in\aPSS)$
  \begin{enumerate}[topsep=0pt]
    \setcounter{enumi}{\value{pomsetPreTopCount}}
  \item[1--\ref{top-kappa-read})] as in \refdef{def:pomsets-top},    
  \item $\aTr{\aEvs_1}{\aSym}$ implies $\aSym$, for every quiescence symbol $\aSym$.
  \end{enumerate}
\end{definition}
\begin{definition}
  \label{def:sem-funs}
  \noindent
  The semantics of commands is:
  \begin{scope}
    \allowdisplaybreaks
    \begin{gather*}
      \sem[\aThrd]{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} = \sIFTHEN{\aExp{\neq}0}{\sem[\aThrd]{\aCmd_1}}{\sem[\aThrd]{\aCmd_2}}
      \\
      \begin{aligned}
        \sem[\aThrd]{\PW[\amode]{\aLoc}{\aExp}} &= \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]
        &
        \sem[\aThrd]{\SKIP} &= \sSKIP 
        \\
        \sem[\aThrd]{\PR[\amode]{\aLoc}{\aReg}} &= \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]
        &
        \sem[\aThrd]{\aCmd_1 \LPAR[\bThrd] \aCmd_2} &= \sLPAR{\sem[\aThrd]{\aCmd_1}}{\sem[\bThrd]{\aCmd_2}}
        \\
        \sem[\aThrd]{\LET{\aReg}{\aExp}} &= \sLET{\aReg}{\aExp}
        & 
        \sem[\aThrd]{\aCmd_1 \SEMI \aCmd_2} &= \sSEMI{\sem[\aThrd]{\aCmd_1}}{\sem[\aThrd]{\aCmd_2}}
        \\
        \sem[\aThrd]{\PF[\ascope]{\amode}} &= \sFENCE[\ascope]{\amode}[\aThrd]
        &
      \end{aligned}
    \end{gather*}
  \end{scope}
\end{definition}

Most of these definitions are straightforward adaptations of
\S\ref{sec:pomsets-pre}, but the treatment of sequential composition
is new.  This uses the usual rule for composition of predicate
transformers (but preserving the indexing set). For the pomset, we
take the union of their events, preserving actions, but crucially in
cases~\ref{seq-kappa2} and~\ref{seq-kappa12} we apply a predicate
transformer $\aTr[1]{\cEvs}{}$ from the left-hand side to a precondition
$\labelingForm_2(\aEv)$ from the right-hand side to build the precondition
$\labelingForm'_2(\aEv)$.  The indexing set $\cEvs$ for the predicate
transformer is $\{ \cEv\mid \cEv<\aEv \}$, so can depend on the causal
order.

%% In the predicate transformers for store and load, \ref{S4} and \ref{L4}
%% denote the \emph{dependent case}, whereas \ref{S5} and \ref{L5}
%% denote the \emph{independent case}.  For stores, the dependent and
%% independent cases are the same; this will change in the next section, where
%% we introduce quiescence.  In the dependent case for load, we can assume that
%% $\aReg$ is the value $\aVal$, which has appears in the read action, when
%% proving $\bForm$.  In the independent case for load, we can only make the
%% weaker assumption that either $\aReg$ is $\aVal$ or it is value defined by
%% preceding code for $\aLoc$.  That is, we do not know whether subsequent code
%% sees the value $\aVal$, or the value of some preceding write of $\aLoc$.


% Recall that $\uRegs{\bEvs}=\{\uReg{\bEv}\mid\bEv\in\bEvs\}$.



% [Note that we could change the premise of $\aTr{\emptyset}{}$ in $\sLOAD{}{}$
% from $(\aVal{=}\aReg\lor\aLoc{=}\aReg)$ to $(\aLoc{=}\aReg)$. The
% requirements of a family of predicate transforms effectively adds the
% additional requirement.]


% \aCmd if P is top-level and quiescent then predicate transformer may be wp(\aCmd,phi).
% Only thing is we are substituting v/r, rather than x/r.


% \aCmd any substitution/valuation sigma giving values for register, can find a
% pomset P such that when you apply the substitution to all the preconditions
% are tautologies and if the substitution validates the wp, then the
% substitution validates the $tau_E$

% substitution validates the wp: wp(\aCmd,phi)sigma is a tautology





\begin{comment} Consider the following executions.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{1{=}1\mid\DW{x}{1}}{}
          \xform{x1d}{\bForm[1/x]}{right=of a1}
          \xform{x1i}{\bForm[1/x]}{below=of x1d}
          \xos{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{2{=}1\mid\DW{x}{1}}{}
          \xform{x1d}{\bForm[2/x]}{right=of a1}
          \xform{x1i}{\bForm[2/x]}{below=of x1d}
          \xos{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  % Simplifying:
  % \begin{align*}
  %   \begin{gathered}
  %   %     \PW{x}{1}
  %   %     \\
  %     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %       \event{a1}{\DW{x}{1}}{}
  %       \xform{x1d}{\bForm[1/x]}{right=of a1}
  %       \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %       \xos{a1}{x1d}
  %     \end{tikzinline}}
  %   \end{gathered}
  %   &&
  %   \begin{gathered}
  %   %     \PW{x}{2}
  %   %     \\
  %     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %       \event{a1}{\FALSE\mid\DW{x}{1}}{}
  %       \xform{x1d}{\FALSE}{right=of a1}
  %       \xform{x1i}{\bForm[2/x]}{right=of x1d}
  %       \xos{a1}{x1d}
  %     \end{tikzinline}}
  %   \end{gathered}
  % \end{align*}
  Merging the actions, we have:
  % \begin{gather*}
  %   \PW{x}{1}\SEMI \PW{x}{2}
  %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
  %     \xform{x1d}{(\bForm[1/x])[2/x]}{below=of a1}
  %     \xform{x1i}{(\bForm[1/x])[2/x]}{below=of x1d}
  %     \xos{a1}{x1d}
  %   \end{tikzinline}}
  % \end{gather*}
  % which simplifies to
  % \begin{gather*}
  %   %   \PW{x}{1}\SEMI \PW{x}{2}
  %   %   \\
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \event{a1}{\DW{x}{1}}{}
  %     \xform{x1d}{\bForm[1/x] }{right=of a1}
  %     \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %     \xos{a1}{x1d}
  %   \end{tikzinline}}
  % \end{gather*}
  % which simplifies to
  \begin{gather*}
    \PW{x}{1}\SEMI \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{1{=}1\lor2{=}1\mid\DW{x}{1}}{}
        \xform{x1d}{(\bForm[2/x])[1/x]}{right=of a1}
        \xform{x1i}{(\bForm[2/x])[1/x]}{right=of x1d}
        \xos{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
  which simplifies to
  \begin{gather*}
    % \PW{x}{1}\SEMI \PW{x}{2}
    % \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{1}}{}
        \xform{x1d}{\bForm[2/x]}{right=of a1}
        \xform{x1i}{\bForm[2/x]}{right=of x1d}
        \xos{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
  % \end{figure}
  % \begin{example} Merging right.
  %   \begin{align*}
  %     \begin{gathered}
  %       \PW{x}{1}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{1{=}2\mid\DW{x}{1}}{}
  %         \xform{x1d}{\bForm[1/x]}{right=of a1}
  %         \xform{x1i}{\bForm[1/x]}{below=of x1d}
  %         \xos{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %     &&
  %     \begin{gathered}
  %       \PW{x}{2}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{2{=}2\mid\DW{x}{1}}{}
  %         \xform{x1d}{\bForm[2/x]}{right=of a1}
  %         \xform{x1i}{\bForm[2/x]}{below=of x1d}
  %         \xos{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %   \end{align*}
  %   Simplifying:
  %   \begin{align*}
  %     \begin{gathered}
  %       \PW{x}{1}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{\FALSE\mid\DW{x}{2}}{}
  %         \xform{x1d}{\FALSE}{right=of a1}
  %         \xform{x1i}{\bForm[1/x]}{right=of x1d}
  %         \xos{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %     &&
  %     \begin{gathered}
  %       \PW{x}{2}
  %       \\
  %       \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %         \event{a1}{\DW{x}{2}}{}
  %         \xform{x1d}{\bForm[2/x]}{right=of a1}
  %         \xform{x1i}{\bForm[2/x]}{right=of x1d}
  %         \xos{a1}{x1d}
  %       \end{tikzinline}}
  %     \end{gathered}
  %   \end{align*}
  %   Merging the actions, we have:
  The programs are also capable of writing 2.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{1{=}2\mid\DW{x}{2}}{}
          \xform{x1d}{\bForm[1/x]}{right=of a1}
          \xform{x1i}{\bForm[1/x]}{below=of x1d}
          \xos{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{2{=}2\mid\DW{x}{2}}{}
          \xform{x1d}{\bForm[2/x]}{right=of a1}
          \xform{x1i}{\bForm[2/x]}{below=of x1d}
          \xos{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  Merging right.
  \begin{gather*}
    % \PW{x}{1}\SEMI \PW{x}{2}
    % \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{2}}{}
        \xform{x1d}{\bForm[2/x]}{right=of a1}
        \xform{x1i}{\bForm[2/x]}{right=of x1d}
        \xos{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
\end{comment}

\begin{comment}
  Separate actions:
  \begin{align*}
    \begin{gathered}
      \PW{x}{1} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[1/x]}{}
          \xform{xi}{\bForm[1/x]}{below=of xd}
          \event{a1}{1{=}1\mid\DW{x}{1}}{left=of xd}
          \xos{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[2/x]}{}
          \xform{xi}{\bForm[2/x]}{below=of xd}
          \event{a2}{2{=}2\mid\DW{x}{2}}{left=of xd}      
          \xos{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Simplifying:
  \begin{align*}
    \begin{gathered}
      % \PW{x}{1} 
      % \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[1/x]}{}
          \xform{xi}{\bForm[1/x]}{right=of xd}
          \event{a1}{\DW{x}{1}}{left=of xd}
          \xos{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      % \PW{x}{2}
      % \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm[2/x]}{}
          \xform{xi}{\bForm[2/x]}{right=of xd}
          \event{a2}{\DW{x}{2}}{left=of xd}      
          \xos{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together unordered:
  \begin{gather*}
    \PW{x}{1}\SEMI \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdi}{\bForm[2/x]}{}
        \xform{xdd}{\bForm[2/x]}{right=of xdi}
        \xform{xid}{\bForm[2/x]}{right=of xdd}
        \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
        \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
        \xform{xii}{\bForm[2/x]}{right=of xid}
        \xos{a1}{xdi}
        \xos{a2}{xid}
        \xos{a1}{xdd}
        \xos{a2}{xdd}
      \end{tikzinline}}
  \end{gather*}
  Adding order does nothing since the preconditions are tautologies.
  % \begin{gather*}
  %   \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %     \xform{xdi}{\bForm[1/x]}{}
  %     \xform{xdd}{\bForm[1/x]}{right=of xdi}
  %     \xform{xid}{\bForm[1/x]}{right=of xdd}
  %     \event{a1}{\DW{x}{1}}{above left=.5em and -1em of xdd}
  %     \event{a2}{\DW{x}{2}}{above right=.5em and -1em of xdd}
  %     \xform{xii}{\bForm[1/x]}{right=of xid}
  %     \xos{a1}{xdi}
  %     \xos{a2}{xid}
  %     \xos{a1}{xdd}
  %     \xos{a2}{xdd}
  %     \po{a1}{a2}
  %   \end{tikzinline}}
  % \end{gather*}
\end{comment}

\begin{example}
  For read to write dependency, consider:
  \begin{align*}
    \begin{gathered}
      \PR{x}{r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{1{=}r\limplies\bForm}{}
          \xform{xi}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm}{right=.5em of xd}
          \eventl{\bEv}{a1}{\DR{x}{1}}{left=of xd}
          \xos{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{r{=}1\land\bForm\noSUB{[r/y]}}{}
          \xform{xi}{\bForm\noSUB{[r/y]}}{right=.5em of xd}
          \eventl{\aEv}{a2}{r{=}1\mid\DW{y}{1}}{left=of xd}      
          \xos{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together without order,
  we calculate the precondition $\labelingForm(\aEv)$
  as $\aTr[1]{\cEvs}{\labelingForm_2(\aEv)}$, where $\cEvs$ is $\{\cEv\mid\cEv<\aEv\}$, which is $\emptyset$.
  Since $\aTr[1]{\emptyset}{\bForm}$ is $\bForm$, this gives that 
  $\labelingForm(\aEv)$ is $\labelingForm_2(\aEv)$, which is $\aReg{=}1$.
  This gives the pomsaet with predicate transformers:
  \begin{gather*}
    \PR{x}{r} \SEMI
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdd}{1{=}r\limplies(r{=}1\land \bForm\noSUB{[r/y]})}{}
        \xform{xdi}{1{=}r\limplies\bForm\noSUB{[r/y]}}{left=of xdd}
        \xform{xid}{r{=}1\land\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xdd}
        \xform{xii}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xid}
        \eventl{\bEv}{a1}{\DR{x}{1}}{above left=.5em and -2em of xdd}
        \eventl{\aEv}{a2}{\noOR{(x{=}r\lor1{=}r)\limplies} r{=}1\mid\DW{y}{1}}{above right=.5em and -4em of xdd}
        \xos{a1}{xdi}
        \xos{a2}{xid}
        \xos{a1}{xdd}
        \xos{a2}{xdd}
      \end{tikzinline}}
  \end{gather*}
  This pomset's preconditions depend on a bound register, so cannot contribute
  to a top-level pomset.
  
  Putting them together with order,
  we calculate the precondition $\labelingForm(\aEv)$
  as $\aTr[1]{\cEvs}{\labelingForm_2(\aEv)}$, where $\cEvs$ is $\{\cEv\mid\cEv<\aEv\}$, which is $\{\bEv\}$.
  Since $\aTr[1]{\{\bEv\}}{\bForm}$ is $(1{=}\aReg \limplies \bForm)$, this gives that 
  $\labelingForm(\aEv)$ is $(1{=}\aReg \limplies \labelingForm_2(\aEv))$, which is $(1{=}\aReg \limplies \aReg{=}1)$.
  This gives the pomset with predicate transformers:
  \begin{gather*}
    \PR{x}{r} \SEMI
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdd}{1{=}r\limplies(r{=}1\land \bForm\noSUB{[r/y]})}{}
        \xform{xdi}{1{=}r\limplies\bForm\noSUB{[r/y]}}{left=of xdd}
        \xform{xid}{r{=}1\land\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xdd}
        \xform{xii}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xid}
        \eventl{\bEv}{a1}{\DR{x}{1}}{above left=.5em and -2em of xdd}
        \eventl{\aEv}{a2}{1{=}r\limplies r{=}1\mid\DW{y}{1}}{above right=.5em and -4em of xdd}
        \xos{a1}{xdi}
        \xos{a2}{xid}
        \xos{a1}{xdd}
        \xos{a2}{xdd}
        \po{a1}{a2}
      \end{tikzinline}}
  \end{gather*}
  This pomset's preconditions do not depend on a bound register, so can contribute
  to a top-level pomset.
\end{example}

\begin{example}
  If the read and write choose different values:
  \begin{align*}
    \begin{gathered}
      \PR{x}{r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{1{=}r\limplies\bForm}{}
          \xform{xi}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm}{right=.5em of xd}
          \event{a1}{\DR{x}{1}}{left=of xd}
          \xos{a1}{xd}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}
      \PW{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \xform{xd}{\bForm\noSUB{[r/y]}}{}
          \xform{xi}{r{=}2\land\bForm\noSUB{[r/y]}}{right=.5em of xd}
          \event{a2}{r{=}2\mid\DW{y}{2}}{left=of xd}      
          \xos{a2}{xd}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  Putting these together with order, we have the following, which cannot be
  part of a top-level pomset:
  \begin{gather*}
    \PR{x}{r} \SEMI
    \PW{y}{r}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \xform{xdd}{1{=}r\limplies(r{=}2\land \bForm\noSUB{[r/y]})}{}
        \xform{xdi}{1{=}r\limplies\bForm\noSUB{[r/y]}}{left=of xdd}
        \xform{xid}{r{=}2\land\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xdd}
        \xform{xii}{\noOR{(x{=}r\lor1{=}r)\limplies}\bForm\noSUB{[r/y]}}{right=of xid}
        \eventl{\bEv}{a1}{\DR{x}{1}}{above left=.5em and -2em of xdd}
        \eventl{\aEv}{a2}{1{=}r\limplies r{=}2\mid\DW{y}{2}}{above right=.5em and -4em of xdd}
        \xos{a1}{xdi}
        \xos{a2}{xid}
        \xos{a1}{xdd}
        \xos{a2}{xdd}
        \po{a1}{a2}
      \end{tikzinline}}
  \end{gather*}

  % The precondition of $\DWP{y}{2}$ is unsatisfiable if no further assumptions
  % can be made on $r$; that is the case here, since we assume each register
  % occurs at most once in source programs. If we choose a pomset that without
  % the order $\DRP{x}{1}\xpo\DWP{y}{2}$, the precondition of $\DWP{y}{1}$ is
  % strengthened to $(r{=}2)$, which is also unsatisfiable without further
  % assumptions on $r$; the predicate transformers are unchanged.
\end{example}

\begin{example}
  \label{ex:left-merge}
  \ref{S4} includes $\aExp{=}\aVal$ to ensure that
  spurious merges do not go undetected.  Consider the following.
  \begin{align*}
    \begin{gathered}
      \PW{x}{1}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a1}{1{=}1\mid\DW{x}{1}}{}
          \xform{x1d}{1{=}1\land\bForm}{right=of a1}
          \xform{x1i}{\bForm}{right=.5em of x1d}
          \xos{a1}{x1d}
        \end{tikzinline}}
    \end{gathered}
    &&
    \begin{gathered}
      \PW{x}{2}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a2}{2{=}1\mid\DW{x}{1}}{}
          \xform{x2d}{2{=}1\land\bForm}{right=of a2}
          \xform{x2i}{\bForm}{right=.5em of x2d}
          \xos{a2}{x2d}
        \end{tikzinline}}
    \end{gathered}
  \end{align*}
  % Simplifying
  %% \begin{align*}
  %%   \begin{gathered}
  %%     \PW{x}{1}
  %%     \\
  %%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %%       \event{a1}{\Qr{\aLoc}\land\Qw{\aLoc}\mid\DW{x}{1}}{}
  %%       \xform{x1d}{\bForm}{below=of a1}
  %%       \xform{x1i}{\bForm[\FALSE/\Qw{\aLoc}]}{below=of x1d}
  %%       \xo{a1}{x1d}
  %%     \end{tikzinline}}
  %%   \end{gathered}
  %%   &&
  %%   \begin{gathered}
  %%     \PW{x}{2}
  %%     \\
  %%     \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
  %%       \event{a2}{\FALSE\mid\DW{x}{1}}{}
  %%       \xform{x2d}{\bForm[\FALSE/\Qw{\aLoc}]}{below=of a2}
  %%       \xform{x2i}{\bForm[\FALSE/\Qw{\aLoc}]}{below=of x2d}
  %%       \xo{a2}{x2d}
  %%     \end{tikzinline}}
  %%   \end{gathered}
  %% \end{align*}
  Merging the actions, since $2{=}1$ is unsatisfiable, we have:
  \begin{gather*}
    \PW{x}{1}\SEMI \PW{x}{2}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
        \event{a1}{\DW{x}{1}}{}
        \xform{x1d}{\FALSE}{right=of a1}
        \xform{x1i}{\bForm}{right=.5em of x1d}
        \xos{a1}{x1d}
      \end{tikzinline}}
  \end{gather*}
  This pomset cannot be part of a top-level pomset, since
  $\aTr{\aEvs}{\aSym}=\FALSE$ for every quiescence symbol $\aSym$.  This is
  what we would hope: that the program $\PW{x}{1}\SEMI \PW{x}{2}$ should only
  be top-level if there is a $(\DW{x}{2})$ event.
\end{example}

\begin{example}
  \label{ex:skolem}
  The predicate transformer we have chosen for \ref{L4} is different from the
  one used traditionally, which is written using substitution.  Substitution
  is also used in \jjr{}.  Attempting to
  write the predicate transformers in this style we have:
  \begin{enumerate}[topsep=0pt]
  \item[\ref{L4})]
    $\aTr{\bEvs}{\bForm}$ implies $\bForm[\aVal/\aReg]$, 
  \item[\ref{L5})]
    $\aTr{\cEvs}{\bForm}$ implies $(\forall\aReg)\bForm$.
  \end{enumerate}
  This phrasing of \ref{L5} says that $\bForm$ must be independent of $\aReg$
  in order to appear in a top-level pomset.  This choice for \ref{L5} is forced
  by \refdef{def:family}, which states that the predicate transformer for a
  small subset of $\aEvs$ must imply the transformer for a larger subset.

  Sadly, this definition fails associativity.

  Consider the following, eliding transformers:
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW{x}{\BANG r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{b}{r{=}0\mid\DW{x}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW{x}{\BANG\BANG r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{b}{r{\neq}0\mid\DW{x}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{b}{\DW{x}{0}}{}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}  
  Associating to the right and merging:
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW{x}{\BANG r} 
      \SEMI \PW{x}{\BANG\BANG r} 
      \SEMI \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{b}{r{=}0 \lor r{\neq}0\mid\DW{x}{1}}{}
          \event{c}{\DW{x}{0}}{right=of b}
          \wk{b}{c}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}  
  The precondition of $\DWP{x}{1}$ is a tautology, thus we have:
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \SEMI \PW{x}{\BANG r} 
      \SEMI \PW{x}{\BANG\BANG r} 
      \SEMI \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
          \event{b}{\DW{x}{1}}{right=of a}
          \event{c}{\DW{x}{0}}{right=of b}
          \wk{b}{c}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  If, instead, we associate to the left:
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \SEMI \PW{x}{\BANG r} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
          \event{b}{1{=}0\mid\DW{x}{1}}{right=of a}
        \end{tikzinline}}    
    \end{gathered}
    &&
    \begin{gathered}[t]
      \PW{x}{\BANG\BANG r} 
      \SEMI \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{b}{r{\neq}0\mid\DW{x}{1}}{}
          \event{c}{\DW{x}{0}}{right=of b}
          \wk{b}{c}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}  
  Sequencing and merging:
  \begin{align*}
    \begin{gathered}[t]
      \PR{y}{r}
      \SEMI \PW{x}{\BANG r} 
      \SEMI \PW{x}{\BANG\BANG r} 
      \SEMI \PW{x}{0} 
      \\
      \hbox{\begin{tikzinline}[node distance=.5em and 1.5em]
          \event{a}{\DR{y}{1}}{}
          \event{b}{1{=}0 \lor r{\neq}0\mid\DW{x}{1}}{right=of a}
          \event{c}{\DW{x}{0}}{right=of b}
          \wk{b}{c}
        \end{tikzinline}}    
    \end{gathered}
  \end{align*}
  In this case, the precondition of $\DWP{x}{1}$ is not a tautology, forcing
  a dependency $\DRP{y}{1}\xpo \DWP{x}{1}$.

  Our solution is to Skolemize.  We have proven associativity of
  \refdef{def:pomsets-trans} in Agda.  The proof requires that predicate
  transformers distribute through disjunction (\refdef{def:trans}).
  Since universal quantification does not distribute through disjunction, the
  attempt to define predicate transformers using substitution fails (in
  particular for \ref{L5}.)
\end{example}

\subsection{The Road Ahead}

The final semantic functions for load, store, and thread initialization are
given in \reffig{fig:no-addr}, at the end of the paper.  In
\textsection\ref{sec:q}--\ref{sec:complications}, we explain this definition
by looking at its constituent parts, building on \refdef{def:pomsets-trans}.
In \textsection\ref{sec:q}, we add \emph{quiescence}, which encodes
coherence, release-acquire access, and SC access.  In
\textsection\ref{sec:arm}, we add peculiarities that are necessary for
efficient implementation on \armeight.  In
\textsection\ref{sec:complications}, we discuss other features such as
invariant reasoning, case analysis and register recycling.
% In the appendix,
% we discuss address calculation and read-modify-write operations.

The final definitions of load and store are quite complex, due to the
inherent complexities of relaxed memory.  The core of
\refdef{def:pomsets-trans}, modeling sequential composition, parallel
composition, and conditionals, is stable, remaining unchanged in later
sections.  The messiness of relaxed memory is quarantined to the rules
for load and store, rather than permeating the entire semantics.
