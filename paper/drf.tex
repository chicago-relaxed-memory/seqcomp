\section{Local Data Race Freedom and Sequential Consistency}
\label{sec:sc}

Idea: merging reads can only make a difference is if there is a race.
Let $\sempomca{i}{}$ be the semantic function generated by applying the
construction of \reflem{lem:po} to $\semmca{i}{}$.


We adapt \citeauthor{Dolan:2018:BDR:3192366.3192421}'s
[\citeyear{Dolan:2018:BDR:3192366.3192421}] notion of \emph{Local Data Race
  Freedom (LDRF)} to our setting.

The result requires that locations are properly initialized.  We assume a
sufficient condition: that programs have the form
``$\aLoc_1\GETS\aVal_1\SEMI \cdots \aLoc_n\GETS\aVal_n\SEMI\aCmd$'' where
every location mentioned in $\aCmd$ is some $\aLoc_i$.

We make two further restrictions to simplify the exposition.  To simplify the
definition of \emph{happens-before}, we ban fences and \RMWs.  To simplify
the proof, we assume there are no local declarations of the form
$(\VAR\aLoc\SEMI \aCmd)$.

To state the theorem, we require several technical definitions.  The reader
unfamiliar with \citep{Dolan:2018:BDR:3192366.3192421} may prefer to skip to
the examples in the proof sketch, referring back as needed.

\bookmark{Definitions}
\paragraph{Data Race}
Data races are defined using \emph{program} order $(\rpox)$, not
\emph{pomset} order $(\le)$. %, and thus is stable with respect to augmentation.
In \ref{SB}, for example, $(\DR{x}{0})$ has an $x$-race with $(\DW{x}{1})$,
but not $(\DW{x}{0})$, which is $\rpox$-before it.

It is obvious how to enhance the semantics of prefixing and most other
operators to define $\rpox$.  When combining pomsets using the conditional,
the obvious definition may result in cycles, since $\rpox$-ordered reads may
coalesce---see the discussion of \ref{CA} in \textsection\ref{sec:refine}.  In
this case we include a separate pomset for each way of breaking these cycles.

Because we ignore the features of
\textsection\ref{sec:variants}, we can adopt the simplest definition of
\emph{synchronizes\hyp{}with}~($\rsw$): Let $\bEv\xsw\aEv$ exactly when
$\bEv$ fulfills $\aEv$, $\bEv$ is a release, $\aEv$ is an acquire, and
$\lnot(\bEv\xpox\aEv)$.

Let ${\rhb}=({\rpox}\cup{\rsw})^+$ be the \emph{happens-before} relation.  In
\ref{Pub1}, for example, $(\DW{x}{1})$ happens-before $(\DR{x}{0})$, but this
fails if either $\mRA$ access is relaxed.

Let $L\subseteq\Loc$ be a set of locations.  We say that $\bEv$ \emph{has an
  $L$-race with} $\aEv$ (notation $\bEv\lrace{L}\aEv$) when at least one is
relaxed, they \emph{conflict}
(Def.~\ref{def:rf}) at
some location in $L$, and they are unordered by $\rhb$: neither $\bEv\xhb\aEv$ nor
$\aEv\xhb\bEv$.  

\paragraph{Generators}
We say that $\aPS'$ \emph{generates} $\aPS$ if either
$\aPS$ augments $\aPS'$ or $\aPS$ implies $\aPS'$.  For example, the
unordered pomset $(\DR{x}{1})$ $(\DW{y}{1})$ generates the ordered pomset
$(\DR{x}{1})\xpo(\aReg=1\mid\DW{y}{1})$.

We say that $\aPS$ is a \emph{generation-minimal} in $\aPSS$ if $\aPS\in\aPSS$ and
there is no $\aPS\neq\aPS'\in\aPSS$ that generates $\aPS$.

Let $\semmin{\aCmd}=\{\aPS\in\sem{\aCmd} \mid \aPS$ is \emph{top-level}
(Def.~\ref{def:top}) and generation-minimal in $\sem{\aCmd}\}$.

\paragraph{Extensions}

We say that $\aPS'$ \emph{$\aCmd$-extends} $\aPS$ if %$\aPS\in\semmin{\aCmd}$,
$\aPS\neq\aPS'\in\semmin{\aCmd}$ and $\aPS$ is a downset of $\aPS'$.

\paragraph{Similarity}
We say that \emph{$\aPS'$ is $\aEv$-similar to $\aPS$} if they differ at most
in (1) pomset order adjacent to $\aEv$ and (2) the value associated with
event $\aEv$, if it is a
read.  % We say they are \emph{similar} if they are $\aEv$-similar for some $\aEv$.
Formally: $\Event'=\Event$, $\labelingForm'=\labelingForm$,
$\restrict {\le'}{\Event\setminus\{\aEv\}}=\restrict {\le}{\Event\setminus\{\aEv\}}$,
if $\aEv$ is not a read then $\labelingAct'=\labelingAct$, and if $\aEv$ is a
read then
$\restrict{\labelingAct'}{\Event\setminus\{\aEv\}}=\restrict{\labelingAct}{\Event\setminus\{\aEv\}}$
and $\labelingAct'(\aEv) = \labelingAct(\aEv)[\aVal'/\aVal]$, for some
$\aVal'$, $\aVal$.

\paragraph{Stability}
We say that $\aPS$ is \emph{$L$-stable in $\aCmd$} if
(1) $\aPS\in\semmin{\aCmd}$, 
(2) $\aPS$ is $\rpox$-convex (nothing missing in program order),
(3) there is no $\aCmd$-extension of $\aPS$ with a \emph{crossing} $L$-race:
that is, there is no $\bEv\in\Event$, no $\aPS'$ $\aCmd$-extending
$\aPS$, and no $\aEv\in\Event'\setminus\Event$ such that $\bEv\lrace{L}\aEv$.
The empty pomset is $L$-stable.

\paragraph{Sequentiality}
Let ${\pole{L}}={\lt_L}\cup{\rpox}$, where $\lt_L$ is the restriction of $\lt$ to events that access locations in $L$.
We say that $\aPS'$ is \emph{$L$-sequential after $\aPS$} if 
$\aPS'$ is $\rpox$-convex and %
$\pole{L}$ is acyclic in $\Event'\setminus\Event$.

\bookmark{Theorem and Proof Sketch}
\begin{theorem}
  Let $\aPS$ be $L$-stable in $\aCmd$.  Let $\aPS'$ be a $\aCmd$-extension of
  $\aPS$ that is $L$-sequential after $\aPS$.  Let $\aPS''$ be a
  $\aCmd$-extension of $\aPS'$ that is $\rpox$-convex, such that no subset of
  $\Event''$ satisfies these criteria.
  Then either (1) $\aPS''$ is $L$-sequential after $\aPS$ or (2) there is
  some $\aCmd$-extension $\aPS'''$ of $\aPS'$ and some
  $\aEv\in(\Event''\setminus\Event')$ such that (a) $\aPS'''$ is
  $\aEv$-similar to $\aPS''$, (b) $\aPS'''$ is $L$-sequential after $\aPS$,
  and (c) $\bEv\lrace{L}\aEv$, for some $\bEv\in(\Event''\setminus\Event)$.
\end{theorem}
The theorem provides an inductive characterization of \emph{Sequential
  Consistency for Local
  Data-Race Freedom (SC-LDRF)}: Any extension of a $L$-stable pomset is either
$L$-sequential, or is $\aEv$-similar to a $L$-sequential extension that
includes a race involving $\aEv$.
\begin{proof}[Proof Sketch]
  In order to develop a technique to find $\aPS'''$ from $\aPS''$, we analyze
  pomset order in generation-minimal top-level pomsets.  First, we note that
  $\le_*$ (the transitive reduction $\le$) can be decomposed into three
  disjoint relations.  Let ${\rppo}=({\le_*}\cap{\rpox})$ denote
  \emph{preserved} program order, as required by prefixing (Def.~\ref{def:prefix}).  The other two relations are cross-thread subsets of
  $({\le_*}\setminus{\rpox})$, as required by fulfillment (Def.~\ref{def:rf}): $\rrfe$ orders writes before reads, satisfying fulfillment
  requirement \ref{rf3}; $\rxw$ orders read and write accesses before writes,
  satisfying requirement \ref{rf4}. ({Within a thread, \ref{rf3} and
    \ref{rf4} follow from prefixing requirement \ref{5b}, which is included
    in ${\rppo}$.})

  Using this decomposition, we can show the following.
  \begin{lemma}
    Suppose $\aPS''\in\semmin{\aCmd}$ has a read $\aEv$ that is maximal in
    $({\rppo}\cup{\rrfe})$ and such that every $\rpox$-following read is
    also $\le$-following ($\aEv\xpox\bEv$ implies $\aEv\le\bEv$, for every
    read $\bEv$).  Further, suppose there is an $\aEv$-similar $\aPS'''$
    that satisfies the requirements of fulfillment.  Then
    $\aPS'''\in\semmin{\aCmd}$.
  \end{lemma}
  The proof of the lemma follows an inductive construction of
  $\semmin{\aCmd}$, starting from a large set with little order, and
  pruning the set as order is added: We begin with all pomsets generated by
  the semantics without imposing the requirements of fulfillment (including
  only $\rppo$).  We then prune reads which cannot be fulfilled, starting
  with those that are minimally ordered.  This proof is simplified by
  precluding local declarations.

  We can prove a similar result for $({\rpox}\cup{\rrfe})$-maximal read
  and write accesses.

  Turning to the proof of the theorem, if $\aPS''$ is $L$-sequential after
  $\aPS$, then the result follows from (1).  Otherwise, there must be a
  $\pole{L}$ cycle in $\aPS''$ involving all of the actions in
  $(\Event''\setminus\Event')$: If there were no such cycle, then $\aPS''$
  would be $L$-sequential; if there were elements outside the cycle, then
  there would be a subset of $\Event''$ that satisfies these criteria.

  If there is a $({\rpox}\cup{\rrfe})$-maximal access, we select one of
  these as $\aEv$.  If $\aEv$ is a write, we reverse the outgoing order in
  $\rxw$; the ability to reverse this order witnesses the race.  If $\aEv$
  is a read, we switch its fulfilling write to a ``newer'' one, updating
  $\rxw$; the ability to switch witnesses the race.  For
  example, for $\aPS''$ on the left below, we choose the $\aPS'''$ on the
  right;  $\aEv$ is the read of $x$, which races with $(\DW{x}{1})$.  % Program order
  \begin{gather*}
    x\GETS 0 \SEMI y\GETS 0 \SEMI  (x \GETS 1  \SEMI y \GETS 1
    \PAR
    \IF{y}\THEN \aReg \GETS x \FI)
    \\[-.5ex]
    \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
        \event{wy0}{\DW{y}{0}}{}
        \event{wx0}{\DW{x}{0}}{below=of wy0}
        \event{wx1}{\DW{x}{1}}{right=3em of wy0}
        \event{wy1}{\DW{y}{1}}{right=of wx1}
        \event{ry1}{\DR{y}{1}}{below=of wx1}
        \event{rx}{\DR{x}{0}}{below=of wy1}
        \rf[bend right]{wx0}{rx}
        \rf{wy1}{ry1}
        \wk[bend left]{wy0}{wy1}
        \pox{wx1}{wy1}
        \pox{ry1}[below]{rx}
        \wk{rx}{wx1}
        \node(ix)[left=of wx0]{};
        \node(iy)[left=of wy0]{};
        \bgoval[yellow!50]{(ix)(iy)}{P}
        \bgoval[pink!50]{(wx0)(wy0)}{P'\setminus P}
        \bgoval[green!10]{(ry1)(wx1)(rx)(wy1)}{P''\setminus P'}
        \pox{wx0}{wy0}
        \pox{wy0}{wx1}
        \pox{wy0}[below]{ry1}
      \end{tikzinline}}
    \qquad
    \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
        \event{wy0}{\DW{y}{0}}{}
        \event{wx0}{\DW{x}{0}}{below=of wy0}
        \event{wx1}{\DW{x}{1}}{right=3em of wy0}
        \event{wy1}{\DW{y}{1}}{right=of wx1}
        \event{ry1}{\DR{y}{1}}{below=of wx1}
        \event{rx}{\DR{x}{1}}{below=of wy1}
        \rf{wx1}{rx}
        \rf{wy1}{ry1}
        \wk[bend left]{wy0}{wy1}
        \pox{wx1}{wy1}
        \pox{ry1}[below]{rx}
        \wk{wx0}{wx1}
        \node(ix)[left=of wx0]{};
        \node(iy)[left=of wy0]{};
        \bgoval[yellow!50]{(ix)(iy)}{P}
        \bgoval[pink!50]{(wx0)(wy0)}{P'\setminus P}
        \bgoval[green!10]{(ry1)(wx1)(rx)(wy1)}{P'''\setminus P'}
        \pox{wx0}{wy0}
        \pox{wy0}{wx1}
        \pox{wy0}[below]{ry1}
      \end{tikzinline}}
  \end{gather*}    
  It is important that $\aEv$ be $({\rpox}\cup{\rrfe})$-maximal, not just
  $({\rppo}\cup{\rrfe})$-maximal.  The latter criterion would allow us to
  choose $\aEv$ to be the read of $y$, but then there would be no
  $\aEv$-similar pomset: if an execution reads $0$ for $y$ then there is no
  read of $x$, due to the conditional.

  If there is no $({\rpox}\cup{\rrfe})$-maximal access, then all
  cross-thread order must be from $\rrfe$.  In this case, we select a
  $({\rppo}\cup{\rrfe})$-maximal read, switching its fulfilling write to an
  ``older'' one.  As an example, consider the following; once again,
  $\aEv$ is the read of $x$, which races with $(\DW{x}{1})$.
  \begin{gather*}
    x\GETS 0 \SEMI y\GETS 0 \SEMI (\aReg \GETS x  \SEMI y \GETS 1
    \PAR
    \bReg \GETS y \SEMI x \GETS \bReg)
    \\[-.5ex]
    \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
        \event{wx0}{\DW{y}{0}}{}
        \event{ry}{\DR{x}{1}}{right=3em of wx0}
        \event{wx1}{\DW{y}{1}}{right=of ry}
        \event{wy0}{\DW{x}{0}}{below=of wx0}
        \event{rx1}{\DR{y}{1}}{right=3em of wy0}
        \event{wy1}{\DW{x}{1}}{right=of rx1}
        \rf{wx1}{rx1}
        \rf{wy1}{ry}
        \po{rx1}{wy1}
        \pox{ry}{wx1}
        \wk[bend left]{wx0}{wx1}
        \wk[bend right]{wy0}{wy1}
        \node(ix)[left=of wx0]{};
        \node(iy)[left=of wy0]{};
        \bgoval[yellow!50]{(ix)(iy)}{P}
        \bgoval[pink!50]{(wx0)(wy0)}{P'\setminus P}
        \bgoval[green!10]{(ry)(wx1)(rx1)(wy1)}{P''\setminus P'}
        \pox{wy0}{wx0}
        \pox{wx0}{ry}
        \pox{wx0}[below]{rx1}
      \end{tikzinline}}
    \qquad
    \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
        \event{wx0}{\DW{y}{0}}{}
        \event{ry}{\DR{x}{0}}{right=3em of wx0}
        \event{wx1}{\DW{y}{1}}{right=of ry}
        \event{wy0}{\DW{x}{0}}{below=of wx0}
        \event{rx1}{\DR{y}{1}}{right=3em of wy0}
        \event{wy1}{\DW{x}{1}}{right=of rx1}
        \pox{ry}{wx1}
        \wk[bend left]{wx0}{wx1}
        \rf{wx1}{rx1}
        \rf{wy0}{ry}
        \po{rx1}{wy1}
        \wk{ry}{wy1}
        \node(ix)[left=of wx0]{};
        \node(iy)[left=of wy0]{};
        \bgoval[yellow!50]{(ix)(iy)}{P}
        \bgoval[pink!50]{(wx0)(wy0)}{P'\setminus P}
        \bgoval[green!10]{(ry)(wx1)(rx1)(wy1)}{P'''\setminus P'}
        \pox{wy0}{wx0}
        \pox{wx0}{ry}
        \pox{wx0}[below]{rx1}
      \end{tikzinline}}
  \end{gather*}
  This example requires $(\DW{x}{0})$.  Proper initialization ensures the
  existence of such ``older'' writes.
\end{proof}

\bookmark{Mixed Races}
The premises of the theorem allow us to avoid the complications caused by ``mixed races'' in
\cite{DBLP:conf/ppopp/DongolJR19}.  In the left pomset below, $\aPS''$ is not
an extension of $\aPS'$, since $\aPS'$ is not a downset of $\aPS''$.  
When considering this pomset, we must perform the decomposition on the right.
\begin{gather*}
  (x\GETS 0 \SEMI   x^\mRA \GETS 1)
  \PAR
  (\aReg\GETS x^\mRA)
  \\[-2ex]
  \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
      \event{wx0}{\DW{x}{0}}{}
      \event{wx1}{\DWRel{x}{1}}{right=of wx0}
      \event{rx}{\DRAcq{x}{0}}{below=of wx0}
      \rf{wx0}{rx}
      \pox{wx0}{wx1}
      \wk{rx}{wx1}
      \node(ix)[left=of wx0]{};
      \bgoval[yellow!50]{(ix)}{P}
      \bgoval[pink!50]{(wx0)(wx1)}{P'\setminus P}
      \bgovalright[green!10]{(rx)}{P''\setminus P'}
    \end{tikzinline}}
  \qquad
  \qquad
  \qquad
  \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
      \event{wx0}{\DW{x}{0}}{}
      \event{wx1}{\DWRel{x}{1}}{right=of wx0}
      \event{rx}{\DRAcq{x}{0}}{below=of wx0}
      \rf{wx0}{rx}
      \pox{wx0}{wx1}
      \wk{rx}{wx1}
      \node(ix)[left=of wx0]{};
      \bgoval[yellow!50]{(ix)}{P}
      \bgoval[pink!50]{(wx0)(rx)}{P'\setminus P}
      \bgoval[green!10]{(wx1)}{P''\setminus P'}
    \end{tikzinline}}
\end{gather*}
This affects the inductive order in which we move across pomsets, but does
not affect the set of pomsets that are considered.  This simplification is
enabled by denotational reasoning.

\bookmark{Comparison to Java}
In our language, past races are always resolved at a stable point, as in
\ref{Co3}.  As another example, consider the following, which is disallowed
here, but allowed by Java \cite[Ex.~2]{Dolan:2018:BDR:3192366.3192421}.  We
include an SC fence here to mimic the behavior of volatiles in the JMM.
\begin{gather*}
  \taglabel{past}
  \begin{gathered}
    (x\GETS 1 \SEMI   y^\mRA \GETS 1)
    \PAR
    (x\GETS 2 \SEMI \FENCE{\mSC} \SEMI \IF{y^\mRA}\THEN r\GETS x \SEMI s\GETS x\FI)
    \\[-2ex]
    \hbox{\begin{tikzinline}[node distance=1.2em]
        \event{wx1}{\DW{x}{1}}{}
        \event{wy1}{\DWRel{y}{1}}{right=of wx0}
        \sync{wx1}{wy1}
        \event{wx2}{\DW{x}{2}}{right=3em of wy1}
        \event{f}{\DFS{\mSC}}{right=of wx2}
        \sync{wx2}{f}
        \event{ry1}{\DR[\mRA]{y}{1}}{right=of f}
        \sync{f}{ry1}
        \event{rx1}{\DR{x}{1}}{right=3em of ry1}
        \event{rx2}{\DR{x}{2}}{right=of rx1}
        \sync{ry1}{rx1}
        \sync[out=15,in=165]{ry1}{rx2}
        \rf[out=10,in=170]{wy1}{ry1}
        \wk[out=10,in=170]{wx1}{wx2}
        \wk[out=-170,in=-10]{rx1}{wx2}
        \bgellipsesmaller[yellow!50]{(wy1)(f)}{}
      \end{tikzinline}}
  \end{gathered}
\end{gather*}
The highlighted events are $L$-stable.  The order from $(\DR{x}{1})$ to
$(\DW{x}{2})$ is required by fulfillment, causing the cycle.  If the fence is
removed, there would be no order from $(\DW{x}{2})$ to
$(\DRAcq{y}{1})$, the highlighted events would no longer be $L$-stable, and
the execution would be allowed.  This more relaxed notion of ``past'' is not
expressible using \citeauthor{Dolan:2018:BDR:3192366.3192421}'s
synchronization primitives.

The notion of ``future'' is also richer here.  Consider \cite[Ex.~3]{Dolan:2018:BDR:3192366.3192421}:
\begin{gather*}
  \taglabel{future}
  \begin{gathered}
    (r\GETS 1 \SEMI \REF{r}\GETS 42\SEMI s\GETS \REF{r}\SEMI  x^\mRA\GETS r)
    \PAR
    (r\GETS x \SEMI \REF{r}\GETS 7)
    \\[-1ex]
    \hbox{\begin{tikzinline}[node distance=1.2em]
        \event{a1}{\DW{\REF{1}}{42}}{}
        \event{a2}{\DR{\REF{1}}{7}}{right=of a1}
        \wk{a1}{a2}
        \event{a4}{\DWRel{x}{1}}{right=of a2}
        \sync{a2}{a4}
        \event{b1}{\DR{x}{1}}{right=3em of a4}
        \event{b2}{\DW{\REF{1}}{7}}{right=of b1}
        \po{b1}{b2}
        \rf{a4}{b1}
        \wk[out=170,in=10]{b2}{a2}
      \end{tikzinline}}
  \end{gathered}
\end{gather*}
There is no interesting stable point here.  The execution is disallowed
because of a read from the causal future.  If we changed $x^\mRA$ to
$x^\mRLX$, then there would be no order from $(\DR{\REF{1}}{7})$ to
$(\DW[\mRLX]{x}{1})$, and the execution would be allowed.  The distinction
between ``causal future'' and ``temporal future'' is not expressible in
\citeauthor{Dolan:2018:BDR:3192366.3192421}'s operational semantics.

Our definition of $L$-sequentiality does not quite correspond to SC
executions, since actions may be elided by read/write elimination
(\textsection\ref{sec:refine}).  However, for any properly initialized
$L$-sequential pomset that uses elimination, there is larger $L$-sequential
pomset that does not use elimination. This can be shown inductively---in the
inductive step, writes that are introduced can be ignored by existing reads,
and reads that are introduced can be fulfilled, for some value, by some
preceding write.
